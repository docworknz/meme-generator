(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
            case REACT_VIEW_TRANSITION_TYPE:
                return "ViewTransition";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
        var refProp = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
    }
    function validateChildKeys(node) {
        isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        if (trackActualOwner) {
            var previousStackTraceLimit = Error.stackTraceLimit;
            Error.stackTraceLimit = 10;
            var debugStackDEV = Error("react-stack-top-frame");
            Error.stackTraceLimit = previousStackTraceLimit;
        } else debugStackDEV = unknownOwnerDebugStack;
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStackDEV, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/weakHash.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 *
 * Unique Hashing implementation inspired by djb2/fnv1a algorithms,
 * where we are not concerned with the hash being decoded.
 * Focuses on speed while maintaining good hash distribution
 *
 * Note: We could also use something like Murmurhash instead
 * https://github.com/jensyt/imurmurhash-js/blob/master/imurmurhash.js
 *
 * @param {any} input - Value to hash
 * @returns {string} - Hash in hex format
 */ __turbopack_context__.s([
    "default",
    ()=>weakHash
]);
function weakHash(input) {
    // Handle primitives without JSON stringify for better performance
    if (typeof input === 'number') {
        // Use a larger number space for numeric values
        return (Math.abs(input * 2654435761) >>> 0).toString(16);
    }
    if (typeof input === 'boolean') return input ? '1' : '0';
    if (input === null) return 'null';
    if (input === undefined) return 'undefined';
    // For strings, use FNV-1a algorithm
    if (typeof input === 'string') {
        let hash = 0x811c9dc5; // FNV offset basis (32 bit)
        for(let i = 0; i < input.length; i++){
            hash ^= input.charCodeAt(i);
            hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
            hash = hash >>> 0; // Convert to unsigned 32-bit after each iteration
        }
        return hash.toString(16);
    }
    // For arrays, hash elements directly
    if (Array.isArray(input)) {
        let hash = 0x811c9dc5;
        for(let i = 0; i < input.length; i++){
            // Add array position to hash calculation
            hash ^= (i + 1) * 2654435761;
            // Recursively hash array elements
            const elementHash = weakHash(input[i]);
            // Mix the element hash into the running hash
            for(let j = 0; j < elementHash.length; j++){
                hash ^= elementHash.charCodeAt(j);
                hash *= 16777619; // FNV prime (32 bit)
                hash = hash >>> 0;
            }
        }
        return hash.toString(16);
    }
    // For objects, hash keys and values
    if (typeof input === 'object') {
        let hash = 0x811c9dc5;
        const keys = Object.keys(input).sort(); // Sort for consistency
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            // Hash the key using string hash
            const keyHash = weakHash(key);
            hash ^= parseInt(keyHash, 16);
            hash *= 16777619;
            hash = hash >>> 0;
            // Hash the value recursively
            const valueHash = weakHash(input[key]);
            hash ^= parseInt(valueHash, 16);
            hash *= 16777619;
            hash = hash >>> 0;
        }
        return hash.toString(16);
    }
    // Fallback for other types
    return weakHash(String(input));
} //# sourceMappingURL=weakHash.js.map
}),
"[project]/node_modules/mutative/dist/mutative.esm.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "apply",
    ()=>apply,
    "castDraft",
    ()=>castDraft,
    "castImmutable",
    ()=>castImmutable,
    "castMutable",
    ()=>castMutable,
    "create",
    ()=>create,
    "current",
    ()=>current,
    "isDraft",
    ()=>isDraft,
    "isDraftable",
    ()=>isDraftable,
    "makeCreator",
    ()=>makeCreator,
    "markSimpleObject",
    ()=>markSimpleObject,
    "original",
    ()=>original,
    "rawReturn",
    ()=>rawReturn,
    "unsafe",
    ()=>unsafe
]);
const Operation = {
    Remove: 'remove',
    Replace: 'replace',
    Add: 'add'
};
// Don't use `Symbol()` just for 3rd party access the draft
const PROXY_DRAFT = Symbol.for('__MUTATIVE_PROXY_DRAFT__');
const RAW_RETURN_SYMBOL = Symbol('__MUTATIVE_RAW_RETURN_SYMBOL__');
const iteratorSymbol = Symbol.iterator;
const dataTypes = {
    mutable: 'mutable',
    immutable: 'immutable'
};
const internal = {};
function has(target, key) {
    return target instanceof Map ? target.has(key) : Object.prototype.hasOwnProperty.call(target, key);
}
function getDescriptor(target, key) {
    if (key in target) {
        let prototype = Reflect.getPrototypeOf(target);
        while(prototype){
            const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);
            if (descriptor) return descriptor;
            prototype = Reflect.getPrototypeOf(prototype);
        }
    }
    return;
}
function isBaseSetInstance(obj) {
    return Object.getPrototypeOf(obj) === Set.prototype;
}
function isBaseMapInstance(obj) {
    return Object.getPrototypeOf(obj) === Map.prototype;
}
function latest(proxyDraft) {
    var _a;
    return (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original;
}
/**
 * Check if the value is a draft
 */ function isDraft(target) {
    return !!getProxyDraft(target);
}
function getProxyDraft(value) {
    if (typeof value !== 'object') return null;
    return value === null || value === void 0 ? void 0 : value[PROXY_DRAFT];
}
function getValue(value) {
    var _a;
    const proxyDraft = getProxyDraft(value);
    return proxyDraft ? (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original : value;
}
/**
 * Check if a value is draftable
 */ function isDraftable(value, options) {
    if (!value || typeof value !== 'object') return false;
    let markResult;
    return Object.getPrototypeOf(value) === Object.prototype || Array.isArray(value) || value instanceof Map || value instanceof Set || !!(options === null || options === void 0 ? void 0 : options.mark) && ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable || typeof markResult === 'function');
}
function getPath(target, path = []) {
    if (Object.hasOwnProperty.call(target, 'key')) {
        // check if the parent is a draft and the original value is not equal to the current value
        const parentCopy = target.parent.copy;
        const proxyDraft = getProxyDraft(get(parentCopy, target.key));
        if (proxyDraft !== null && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== target.original) {
            return null;
        }
        const isSet = target.parent.type === 3 /* DraftType.Set */ ;
        const key = isSet ? Array.from(target.parent.setMap.keys()).indexOf(target.key) : target.key;
        // check if the key is still in the next state parent
        if (!(isSet && parentCopy.size > key || has(parentCopy, key))) return null;
        path.push(key);
    }
    if (target.parent) {
        return getPath(target.parent, path);
    }
    // `target` is root draft.
    path.reverse();
    try {
        // check if the path is valid
        resolvePath(target.copy, path);
    } catch (e) {
        return null;
    }
    return path;
}
function getType(target) {
    if (Array.isArray(target)) return 1 /* DraftType.Array */ ;
    if (target instanceof Map) return 2 /* DraftType.Map */ ;
    if (target instanceof Set) return 3 /* DraftType.Set */ ;
    return 0 /* DraftType.Object */ ;
}
function get(target, key) {
    return getType(target) === 2 /* DraftType.Map */  ? target.get(key) : target[key];
}
function set(target, key, value) {
    const type = getType(target);
    if (type === 2 /* DraftType.Map */ ) {
        target.set(key, value);
    } else {
        target[key] = value;
    }
}
function peek(target, key) {
    const state = getProxyDraft(target);
    const source = state ? latest(state) : target;
    return source[key];
}
function isEqual(x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
function revokeProxy(proxyDraft) {
    if (!proxyDraft) return;
    while(proxyDraft.finalities.revoke.length > 0){
        const revoke = proxyDraft.finalities.revoke.pop();
        revoke();
    }
}
// handle JSON Pointer path with spec https://www.rfc-editor.org/rfc/rfc6901
function escapePath(path, pathAsArray) {
    return pathAsArray ? path : [
        ''
    ].concat(path).map((_item)=>{
        const item = `${_item}`;
        if (item.indexOf('/') === -1 && item.indexOf('~') === -1) return item;
        return item.replace(/~/g, '~0').replace(/\//g, '~1');
    }).join('/');
}
function unescapePath(path) {
    if (Array.isArray(path)) return path;
    return path.split('/').map((_item)=>_item.replace(/~1/g, '/').replace(/~0/g, '~')).slice(1);
}
function resolvePath(base, path) {
    for(let index = 0; index < path.length - 1; index += 1){
        const key = path[index];
        // use `index` in Set draft
        base = get(getType(base) === 3 /* DraftType.Set */  ? Array.from(base) : base, key);
        if (typeof base !== 'object') {
            throw new Error(`Cannot resolve patch at '${path.join('/')}'.`);
        }
    }
    return base;
}
function strictCopy(target) {
    const copy = Object.create(Object.getPrototypeOf(target));
    Reflect.ownKeys(target).forEach((key)=>{
        let desc = Reflect.getOwnPropertyDescriptor(target, key);
        if (desc.enumerable && desc.configurable && desc.writable) {
            copy[key] = target[key];
            return;
        }
        // for freeze
        if (!desc.writable) {
            desc.writable = true;
            desc.configurable = true;
        }
        if (desc.get || desc.set) desc = {
            configurable: true,
            writable: true,
            enumerable: desc.enumerable,
            value: target[key]
        };
        Reflect.defineProperty(copy, key, desc);
    });
    return copy;
}
const propIsEnum = Object.prototype.propertyIsEnumerable;
function shallowCopy(original, options) {
    let markResult;
    if (Array.isArray(original)) {
        return Array.prototype.concat.call(original);
    } else if (original instanceof Set) {
        if (!isBaseSetInstance(original)) {
            const SubClass = Object.getPrototypeOf(original).constructor;
            return new SubClass(original.values());
        }
        return Set.prototype.difference ? Set.prototype.difference.call(original, new Set()) : new Set(original.values());
    } else if (original instanceof Map) {
        if (!isBaseMapInstance(original)) {
            const SubClass = Object.getPrototypeOf(original).constructor;
            return new SubClass(original);
        }
        return new Map(original);
    } else if ((options === null || options === void 0 ? void 0 : options.mark) && (markResult = options.mark(original, dataTypes), markResult !== undefined) && markResult !== dataTypes.mutable) {
        if (markResult === dataTypes.immutable) {
            return strictCopy(original);
        } else if (typeof markResult === 'function') {
            if (options.enablePatches || options.enableAutoFreeze) {
                throw new Error(`You can't use mark and patches or auto freeze together.`);
            }
            return markResult();
        }
        throw new Error(`Unsupported mark result: ${markResult}`);
    } else if (typeof original === 'object' && Object.getPrototypeOf(original) === Object.prototype) {
        // For best performance with shallow copies,
        // don't use `Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));` by default.
        const copy = {};
        Object.keys(original).forEach((key)=>{
            copy[key] = original[key];
        });
        Object.getOwnPropertySymbols(original).forEach((key)=>{
            if (propIsEnum.call(original, key)) {
                copy[key] = original[key];
            }
        });
        return copy;
    } else {
        throw new Error(`Please check mark() to ensure that it is a stable marker draftable function.`);
    }
}
function ensureShallowCopy(target) {
    if (target.copy) return;
    target.copy = shallowCopy(target.original, target.options);
}
function deepClone(target) {
    if (!isDraftable(target)) return getValue(target);
    if (Array.isArray(target)) return target.map(deepClone);
    if (target instanceof Map) {
        const iterable = Array.from(target.entries()).map(([k, v])=>[
                k,
                deepClone(v)
            ]);
        if (!isBaseMapInstance(target)) {
            const SubClass = Object.getPrototypeOf(target).constructor;
            return new SubClass(iterable);
        }
        return new Map(iterable);
    }
    if (target instanceof Set) {
        const iterable = Array.from(target).map(deepClone);
        if (!isBaseSetInstance(target)) {
            const SubClass = Object.getPrototypeOf(target).constructor;
            return new SubClass(iterable);
        }
        return new Set(iterable);
    }
    const copy = Object.create(Object.getPrototypeOf(target));
    for(const key in target)copy[key] = deepClone(target[key]);
    return copy;
}
function cloneIfNeeded(target) {
    return isDraft(target) ? deepClone(target) : target;
}
function markChanged(proxyDraft) {
    var _a;
    proxyDraft.assignedMap = (_a = proxyDraft.assignedMap) !== null && _a !== void 0 ? _a : new Map();
    if (!proxyDraft.operated) {
        proxyDraft.operated = true;
        if (proxyDraft.parent) {
            markChanged(proxyDraft.parent);
        }
    }
}
function throwFrozenError() {
    throw new Error('Cannot modify frozen object');
}
function deepFreeze(target, subKey, updatedValues, stack, keys) {
    {
        updatedValues = updatedValues !== null && updatedValues !== void 0 ? updatedValues : new WeakMap();
        stack = stack !== null && stack !== void 0 ? stack : [];
        keys = keys !== null && keys !== void 0 ? keys : [];
        const value = updatedValues.has(target) ? updatedValues.get(target) : target;
        if (stack.length > 0) {
            const index = stack.indexOf(value);
            if (value && typeof value === 'object' && index !== -1) {
                if (stack[0] === value) {
                    throw new Error(`Forbids circular reference`);
                }
                throw new Error(`Forbids circular reference: ~/${keys.slice(0, index).map((key, index)=>{
                    if (typeof key === 'symbol') return `[${key.toString()}]`;
                    const parent = stack[index];
                    if (typeof key === 'object' && (parent instanceof Map || parent instanceof Set)) return Array.from(parent.keys()).indexOf(key);
                    return key;
                }).join('/')}`);
            }
            stack.push(value);
            keys.push(subKey);
        } else {
            stack.push(value);
        }
    }
    if (Object.isFrozen(target) || isDraft(target)) {
        {
            stack.pop();
            keys.pop();
        }
        return;
    }
    const type = getType(target);
    switch(type){
        case 2 /* DraftType.Map */ :
            for (const [key, value] of target){
                deepFreeze(key, key, updatedValues, stack, keys);
                deepFreeze(value, key, updatedValues, stack, keys);
            }
            target.set = target.clear = target.delete = throwFrozenError;
            break;
        case 3 /* DraftType.Set */ :
            for (const value of target){
                deepFreeze(value, value, updatedValues, stack, keys);
            }
            target.add = target.clear = target.delete = throwFrozenError;
            break;
        case 1 /* DraftType.Array */ :
            Object.freeze(target);
            let index = 0;
            for (const value of target){
                deepFreeze(value, index, updatedValues, stack, keys);
                index += 1;
            }
            break;
        default:
            Object.freeze(target);
            // ignore non-enumerable or symbol properties
            Object.keys(target).forEach((name)=>{
                const value = target[name];
                deepFreeze(value, name, updatedValues, stack, keys);
            });
    }
    {
        stack.pop();
        keys.pop();
    }
}
function forEach(target, iter) {
    const type = getType(target);
    if (type === 0 /* DraftType.Object */ ) {
        Reflect.ownKeys(target).forEach((key)=>{
            iter(key, target[key], target);
        });
    } else if (type === 1 /* DraftType.Array */ ) {
        let index = 0;
        for (const entry of target){
            iter(index, entry, target);
            index += 1;
        }
    } else {
        target.forEach((entry, index)=>iter(index, entry, target));
    }
}
function handleValue(target, handledSet, options) {
    if (isDraft(target) || !isDraftable(target, options) || handledSet.has(target) || Object.isFrozen(target)) return;
    const isSet = target instanceof Set;
    const setMap = isSet ? new Map() : undefined;
    handledSet.add(target);
    forEach(target, (key, value)=>{
        var _a;
        if (isDraft(value)) {
            const proxyDraft = getProxyDraft(value);
            ensureShallowCopy(proxyDraft);
            // A draft where a child node has been changed, or assigned a value
            const updatedValue = ((_a = proxyDraft.assignedMap) === null || _a === void 0 ? void 0 : _a.size) || proxyDraft.operated ? proxyDraft.copy : proxyDraft.original;
            // final update value
            set(isSet ? setMap : target, key, updatedValue);
        } else {
            handleValue(value, handledSet, options);
        }
    });
    if (setMap) {
        const set = target;
        const values = Array.from(set);
        set.clear();
        values.forEach((value)=>{
            set.add(setMap.has(value) ? setMap.get(value) : value);
        });
    }
}
function finalizeAssigned(proxyDraft, key) {
    // handle the draftable assigned valuesï¼Œ and the value is not a draft
    const copy = proxyDraft.type === 3 /* DraftType.Set */  ? proxyDraft.setMap : proxyDraft.copy;
    if (proxyDraft.finalities.revoke.length > 1 && proxyDraft.assignedMap.get(key) && copy) {
        handleValue(get(copy, key), proxyDraft.finalities.handledSet, proxyDraft.options);
    }
}
function finalizeSetValue(target) {
    if (target.type === 3 /* DraftType.Set */  && target.copy) {
        target.copy.clear();
        target.setMap.forEach((value)=>{
            target.copy.add(getValue(value));
        });
    }
}
function finalizePatches(target, generatePatches, patches, inversePatches) {
    const shouldFinalize = target.operated && target.assignedMap && target.assignedMap.size > 0 && !target.finalized;
    if (shouldFinalize) {
        if (patches && inversePatches) {
            const basePath = getPath(target);
            if (basePath) {
                generatePatches(target, basePath, patches, inversePatches);
            }
        }
        target.finalized = true;
    }
}
function markFinalization(target, key, value, generatePatches) {
    const proxyDraft = getProxyDraft(value);
    if (proxyDraft) {
        // !case: assign the draft value
        if (!proxyDraft.callbacks) {
            proxyDraft.callbacks = [];
        }
        proxyDraft.callbacks.push((patches, inversePatches)=>{
            var _a;
            const copy = target.type === 3 /* DraftType.Set */  ? target.setMap : target.copy;
            if (isEqual(get(copy, key), value)) {
                let updatedValue = proxyDraft.original;
                if (proxyDraft.copy) {
                    updatedValue = proxyDraft.copy;
                }
                finalizeSetValue(target);
                finalizePatches(target, generatePatches, patches, inversePatches);
                if (target.options.enableAutoFreeze) {
                    target.options.updatedValues = (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();
                    target.options.updatedValues.set(updatedValue, proxyDraft.original);
                }
                // final update value
                set(copy, key, updatedValue);
            }
        });
        if (target.options.enableAutoFreeze) {
            // !case: assign the draft value in cross draft tree
            if (proxyDraft.finalities !== target.finalities) {
                target.options.enableAutoFreeze = false;
            }
        }
    }
    if (isDraftable(value, target.options)) {
        // !case: assign the non-draft value
        target.finalities.draft.push(()=>{
            const copy = target.type === 3 /* DraftType.Set */  ? target.setMap : target.copy;
            if (isEqual(get(copy, key), value)) {
                finalizeAssigned(target, key);
            }
        });
    }
}
function generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray) {
    let { original, assignedMap, options } = proxyState;
    let copy = proxyState.copy;
    if (copy.length < original.length) {
        [original, copy] = [
            copy,
            original
        ];
        [patches, inversePatches] = [
            inversePatches,
            patches
        ];
    }
    for(let index = 0; index < original.length; index += 1){
        if (assignedMap.get(index.toString()) && copy[index] !== original[index]) {
            const _path = basePath.concat([
                index
            ]);
            const path = escapePath(_path, pathAsArray);
            patches.push({
                op: Operation.Replace,
                path,
                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
                value: cloneIfNeeded(copy[index])
            });
            inversePatches.push({
                op: Operation.Replace,
                path,
                // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
                value: cloneIfNeeded(original[index])
            });
        }
    }
    for(let index = original.length; index < copy.length; index += 1){
        const _path = basePath.concat([
            index
        ]);
        const path = escapePath(_path, pathAsArray);
        patches.push({
            op: Operation.Add,
            path,
            // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
            value: cloneIfNeeded(copy[index])
        });
    }
    if (original.length < copy.length) {
        // https://www.rfc-editor.org/rfc/rfc6902#appendix-A.4
        // For performance, here we only generate an operation that replaces the length of the array,
        // which is inconsistent with JSON Patch specification
        const { arrayLengthAssignment = true } = options.enablePatches;
        if (arrayLengthAssignment) {
            const _path = basePath.concat([
                'length'
            ]);
            const path = escapePath(_path, pathAsArray);
            inversePatches.push({
                op: Operation.Replace,
                path,
                value: original.length
            });
        } else {
            for(let index = copy.length; original.length < index; index -= 1){
                const _path = basePath.concat([
                    index - 1
                ]);
                const path = escapePath(_path, pathAsArray);
                inversePatches.push({
                    op: Operation.Remove,
                    path
                });
            }
        }
    }
}
function generatePatchesFromAssigned({ original, copy, assignedMap }, basePath, patches, inversePatches, pathAsArray) {
    assignedMap.forEach((assignedValue, key)=>{
        const originalValue = get(original, key);
        const value = cloneIfNeeded(get(copy, key));
        const op = !assignedValue ? Operation.Remove : has(original, key) ? Operation.Replace : Operation.Add;
        if (isEqual(originalValue, value) && op === Operation.Replace) return;
        const _path = basePath.concat(key);
        const path = escapePath(_path, pathAsArray);
        patches.push(op === Operation.Remove ? {
            op,
            path
        } : {
            op,
            path,
            value
        });
        inversePatches.push(op === Operation.Add ? {
            op: Operation.Remove,
            path
        } : op === Operation.Remove ? {
            op: Operation.Add,
            path,
            value: originalValue
        } : {
            op: Operation.Replace,
            path,
            value: originalValue
        });
    });
}
function generateSetPatches({ original, copy }, basePath, patches, inversePatches, pathAsArray) {
    let index = 0;
    original.forEach((value)=>{
        if (!copy.has(value)) {
            const _path = basePath.concat([
                index
            ]);
            const path = escapePath(_path, pathAsArray);
            patches.push({
                op: Operation.Remove,
                path,
                value
            });
            inversePatches.unshift({
                op: Operation.Add,
                path,
                value
            });
        }
        index += 1;
    });
    index = 0;
    copy.forEach((value)=>{
        if (!original.has(value)) {
            const _path = basePath.concat([
                index
            ]);
            const path = escapePath(_path, pathAsArray);
            patches.push({
                op: Operation.Add,
                path,
                value
            });
            inversePatches.unshift({
                op: Operation.Remove,
                path,
                value
            });
        }
        index += 1;
    });
}
function generatePatches(proxyState, basePath, patches, inversePatches) {
    const { pathAsArray = true } = proxyState.options.enablePatches;
    switch(proxyState.type){
        case 0 /* DraftType.Object */ :
        case 2 /* DraftType.Map */ :
            return generatePatchesFromAssigned(proxyState, basePath, patches, inversePatches, pathAsArray);
        case 1 /* DraftType.Array */ :
            return generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray);
        case 3 /* DraftType.Set */ :
            return generateSetPatches(proxyState, basePath, patches, inversePatches, pathAsArray);
    }
}
let readable = false;
const checkReadable = (value, options, ignoreCheckDraftable = false)=>{
    if (typeof value === 'object' && value !== null && (!isDraftable(value, options) || ignoreCheckDraftable) && !readable) {
        throw new Error(`Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`);
    }
};
/**
 * `unsafe(callback)` to access mutable data directly in strict mode.
 *
 * ## Example
 *
 * ```ts
 * import { create, unsafe } from '../index';
 *
 * class Foobar {
 *   bar = 1;
 * }
 *
 * const baseState = { foobar: new Foobar() };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *    unsafe(() => {
 *      draft.foobar.bar = 2;
 *    });
 *   },
 *   {
 *     strict: true,
 *   }
 * );
 *
 * expect(state).toBe(baseState);
 * expect(state.foobar).toBe(baseState.foobar);
 * expect(state.foobar.bar).toBe(2);
 * ```
 */ function unsafe(callback) {
    readable = true;
    let result;
    try {
        result = callback();
    } finally{
        readable = false;
    }
    return result;
}
const mapHandler = {
    get size () {
        const current = latest(getProxyDraft(this));
        return current.size;
    },
    has (key) {
        return latest(getProxyDraft(this)).has(key);
    },
    set (key, value) {
        const target = getProxyDraft(this);
        const source = latest(target);
        if (!source.has(key) || !isEqual(source.get(key), value)) {
            ensureShallowCopy(target);
            markChanged(target);
            target.assignedMap.set(key, true);
            target.copy.set(key, value);
            markFinalization(target, key, value, generatePatches);
        }
        return this;
    },
    delete (key) {
        if (!this.has(key)) {
            return false;
        }
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        markChanged(target);
        if (target.original.has(key)) {
            target.assignedMap.set(key, false);
        } else {
            target.assignedMap.delete(key);
        }
        target.copy.delete(key);
        return true;
    },
    clear () {
        const target = getProxyDraft(this);
        if (!this.size) return;
        ensureShallowCopy(target);
        markChanged(target);
        target.assignedMap = new Map();
        for (const [key] of target.original){
            target.assignedMap.set(key, false);
        }
        target.copy.clear();
    },
    forEach (callback, thisArg) {
        const target = getProxyDraft(this);
        latest(target).forEach((_value, _key)=>{
            callback.call(thisArg, this.get(_key), _key, this);
        });
    },
    get (key) {
        var _a, _b;
        const target = getProxyDraft(this);
        const value = latest(target).get(key);
        const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;
        if (target.options.strict) {
            checkReadable(value, target.options, mutable);
        }
        if (mutable) {
            return value;
        }
        if (target.finalized || !isDraftable(value, target.options)) {
            return value;
        }
        // drafted or reassigned
        if (value !== target.original.get(key)) {
            return value;
        }
        const draft = internal.createDraft({
            original: value,
            parentDraft: target,
            key,
            finalities: target.finalities,
            options: target.options
        });
        ensureShallowCopy(target);
        target.copy.set(key, draft);
        return draft;
    },
    keys () {
        return latest(getProxyDraft(this)).keys();
    },
    values () {
        const iterator = this.keys();
        return {
            [iteratorSymbol]: ()=>this.values(),
            next: ()=>{
                const result = iterator.next();
                if (result.done) return result;
                const value = this.get(result.value);
                return {
                    done: false,
                    value
                };
            }
        };
    },
    entries () {
        const iterator = this.keys();
        return {
            [iteratorSymbol]: ()=>this.entries(),
            next: ()=>{
                const result = iterator.next();
                if (result.done) return result;
                const value = this.get(result.value);
                return {
                    done: false,
                    value: [
                        result.value,
                        value
                    ]
                };
            }
        };
    },
    [iteratorSymbol] () {
        return this.entries();
    }
};
const mapHandlerKeys = Reflect.ownKeys(mapHandler);
const getNextIterator = (target, iterator, { isValuesIterator })=>()=>{
        var _a, _b;
        const result = iterator.next();
        if (result.done) return result;
        const key = result.value;
        let value = target.setMap.get(key);
        const currentDraft = getProxyDraft(value);
        const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;
        if (target.options.strict) {
            checkReadable(key, target.options, mutable);
        }
        if (!mutable && !currentDraft && isDraftable(key, target.options) && !target.finalized && target.original.has(key)) {
            // draft a draftable original set item
            const proxy = internal.createDraft({
                original: key,
                parentDraft: target,
                key,
                finalities: target.finalities,
                options: target.options
            });
            target.setMap.set(key, proxy);
            value = proxy;
        } else if (currentDraft) {
            // drafted
            value = currentDraft.proxy;
        }
        return {
            done: false,
            value: isValuesIterator ? value : [
                value,
                value
            ]
        };
    };
const setHandler = {
    get size () {
        const target = getProxyDraft(this);
        return target.setMap.size;
    },
    has (value) {
        const target = getProxyDraft(this);
        // reassigned or non-draftable values
        if (target.setMap.has(value)) return true;
        ensureShallowCopy(target);
        const valueProxyDraft = getProxyDraft(value);
        // drafted
        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) return true;
        return false;
    },
    add (value) {
        const target = getProxyDraft(this);
        if (!this.has(value)) {
            ensureShallowCopy(target);
            markChanged(target);
            target.assignedMap.set(value, true);
            target.setMap.set(value, value);
            markFinalization(target, value, value, generatePatches);
        }
        return this;
    },
    delete (value) {
        if (!this.has(value)) {
            return false;
        }
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        markChanged(target);
        const valueProxyDraft = getProxyDraft(value);
        if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) {
            // delete drafted
            target.assignedMap.set(valueProxyDraft.original, false);
            return target.setMap.delete(valueProxyDraft.original);
        }
        if (!valueProxyDraft && target.setMap.has(value)) {
            // non-draftable values
            target.assignedMap.set(value, false);
        } else {
            // reassigned
            target.assignedMap.delete(value);
        }
        // delete reassigned or non-draftable values
        return target.setMap.delete(value);
    },
    clear () {
        if (!this.size) return;
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        markChanged(target);
        for (const value of target.original){
            target.assignedMap.set(value, false);
        }
        target.setMap.clear();
    },
    values () {
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        const iterator = target.setMap.keys();
        return {
            [Symbol.iterator]: ()=>this.values(),
            next: getNextIterator(target, iterator, {
                isValuesIterator: true
            })
        };
    },
    entries () {
        const target = getProxyDraft(this);
        ensureShallowCopy(target);
        const iterator = target.setMap.keys();
        return {
            [Symbol.iterator]: ()=>this.entries(),
            next: getNextIterator(target, iterator, {
                isValuesIterator: false
            })
        };
    },
    keys () {
        return this.values();
    },
    [iteratorSymbol] () {
        return this.values();
    },
    forEach (callback, thisArg) {
        const iterator = this.values();
        let result = iterator.next();
        while(!result.done){
            callback.call(thisArg, result.value, result.value, this);
            result = iterator.next();
        }
    }
};
if (Set.prototype.difference) {
    // for compatibility with new Set methods
    // https://github.com/tc39/proposal-set-methods
    // And `https://github.com/tc39/proposal-set-methods/blob/main/details.md#symbolspecies` has some details about the `@@species` symbol.
    // So we can't use SubSet instance constructor to get the constructor of the SubSet instance.
    Object.assign(setHandler, {
        intersection (other) {
            return Set.prototype.intersection.call(new Set(this.values()), other);
        },
        union (other) {
            return Set.prototype.union.call(new Set(this.values()), other);
        },
        difference (other) {
            return Set.prototype.difference.call(new Set(this.values()), other);
        },
        symmetricDifference (other) {
            return Set.prototype.symmetricDifference.call(new Set(this.values()), other);
        },
        isSubsetOf (other) {
            return Set.prototype.isSubsetOf.call(new Set(this.values()), other);
        },
        isSupersetOf (other) {
            return Set.prototype.isSupersetOf.call(new Set(this.values()), other);
        },
        isDisjointFrom (other) {
            return Set.prototype.isDisjointFrom.call(new Set(this.values()), other);
        }
    });
}
const setHandlerKeys = Reflect.ownKeys(setHandler);
const proxyHandler = {
    get (target, key, receiver) {
        var _a, _b;
        const copy = (_a = target.copy) === null || _a === void 0 ? void 0 : _a[key];
        // Improve draft reading performance by caching the draft copy.
        if (copy && target.finalities.draftsCache.has(copy)) {
            return copy;
        }
        if (key === PROXY_DRAFT) return target;
        let markResult;
        if (target.options.mark) {
            // handle `Uncaught TypeError: Method get Map.prototype.size called on incompatible receiver #<Map>`
            // or `Uncaught TypeError: Method get Set.prototype.size called on incompatible receiver #<Set>`
            const value = key === 'size' && (target.original instanceof Map || target.original instanceof Set) ? Reflect.get(target.original, key) : Reflect.get(target.original, key, receiver);
            markResult = target.options.mark(value, dataTypes);
            if (markResult === dataTypes.mutable) {
                if (target.options.strict) {
                    checkReadable(value, target.options, true);
                }
                return value;
            }
        }
        const source = latest(target);
        if (source instanceof Map && mapHandlerKeys.includes(key)) {
            if (key === 'size') {
                return Object.getOwnPropertyDescriptor(mapHandler, 'size').get.call(target.proxy);
            }
            const handle = mapHandler[key];
            return handle.bind(target.proxy);
        }
        if (source instanceof Set && setHandlerKeys.includes(key)) {
            if (key === 'size') {
                return Object.getOwnPropertyDescriptor(setHandler, 'size').get.call(target.proxy);
            }
            const handle = setHandler[key];
            return handle.bind(target.proxy);
        }
        if (!has(source, key)) {
            const desc = getDescriptor(source, key);
            return desc ? `value` in desc ? desc.value : (_b = desc.get) === null || _b === void 0 ? void 0 : _b.call(target.proxy) : undefined;
        }
        const value = source[key];
        if (target.options.strict) {
            checkReadable(value, target.options);
        }
        if (target.finalized || !isDraftable(value, target.options)) {
            return value;
        }
        // Ensure that the assigned values are not drafted
        if (value === peek(target.original, key)) {
            ensureShallowCopy(target);
            target.copy[key] = createDraft({
                original: target.original[key],
                parentDraft: target,
                key: target.type === 1 /* DraftType.Array */  ? Number(key) : key,
                finalities: target.finalities,
                options: target.options
            });
            // !case: support for custom shallow copy function
            if (typeof markResult === 'function') {
                const subProxyDraft = getProxyDraft(target.copy[key]);
                ensureShallowCopy(subProxyDraft);
                // Trigger a custom shallow copy to update to a new copy
                markChanged(subProxyDraft);
                return subProxyDraft.copy;
            }
            return target.copy[key];
        }
        if (isDraft(value)) {
            target.finalities.draftsCache.add(value);
        }
        return value;
    },
    set (target, key, value) {
        var _a;
        if (target.type === 3 /* DraftType.Set */  || target.type === 2 /* DraftType.Map */ ) {
            throw new Error(`Map/Set draft does not support any property assignment.`);
        }
        let _key;
        if (target.type === 1 /* DraftType.Array */  && key !== 'length' && !(Number.isInteger(_key = Number(key)) && _key >= 0 && (key === 0 || _key === 0 || String(_key) === String(key)))) {
            throw new Error(`Only supports setting array indices and the 'length' property.`);
        }
        const desc = getDescriptor(latest(target), key);
        if (desc === null || desc === void 0 ? void 0 : desc.set) {
            // !case: cover the case of setter
            desc.set.call(target.proxy, value);
            return true;
        }
        const current = peek(latest(target), key);
        const currentProxyDraft = getProxyDraft(current);
        if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {
            // !case: ignore the case of assigning the original draftable value to a draft
            target.copy[key] = value;
            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();
            target.assignedMap.set(key, false);
            return true;
        }
        // !case: handle new props with value 'undefined'
        if (isEqual(value, current) && (value !== undefined || has(target.original, key))) return true;
        ensureShallowCopy(target);
        markChanged(target);
        if (has(target.original, key) && isEqual(value, target.original[key])) {
            // !case: handle the case of assigning the original non-draftable value to a draft
            target.assignedMap.delete(key);
        } else {
            target.assignedMap.set(key, true);
        }
        target.copy[key] = value;
        markFinalization(target, key, value, generatePatches);
        return true;
    },
    has (target, key) {
        return key in latest(target);
    },
    ownKeys (target) {
        return Reflect.ownKeys(latest(target));
    },
    getOwnPropertyDescriptor (target, key) {
        const source = latest(target);
        const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
        if (!descriptor) return descriptor;
        return {
            writable: true,
            configurable: target.type !== 1 /* DraftType.Array */  || key !== 'length',
            enumerable: descriptor.enumerable,
            value: source[key]
        };
    },
    getPrototypeOf (target) {
        return Reflect.getPrototypeOf(target.original);
    },
    setPrototypeOf () {
        throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);
    },
    defineProperty () {
        throw new Error(`Cannot call 'defineProperty()' on drafts`);
    },
    deleteProperty (target, key) {
        var _a;
        if (target.type === 1 /* DraftType.Array */ ) {
            return proxyHandler.set.call(this, target, key, undefined, target.proxy);
        }
        if (peek(target.original, key) !== undefined || key in target.original) {
            // !case: delete an existing key
            ensureShallowCopy(target);
            markChanged(target);
            target.assignedMap.set(key, false);
        } else {
            target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : new Map();
            // The original non-existent key has been deleted
            target.assignedMap.delete(key);
        }
        if (target.copy) delete target.copy[key];
        return true;
    }
};
function createDraft(createDraftOptions) {
    const { original, parentDraft, key, finalities, options } = createDraftOptions;
    const type = getType(original);
    const proxyDraft = {
        type,
        finalized: false,
        parent: parentDraft,
        original,
        copy: null,
        proxy: null,
        finalities,
        options,
        // Mapping of draft Set items to their corresponding draft values.
        setMap: type === 3 /* DraftType.Set */  ? new Map(original.entries()) : undefined
    };
    // !case: undefined as a draft map key
    if (key || 'key' in createDraftOptions) {
        proxyDraft.key = key;
    }
    const { proxy, revoke } = Proxy.revocable(type === 1 /* DraftType.Array */  ? Object.assign([], proxyDraft) : proxyDraft, proxyHandler);
    finalities.revoke.push(revoke);
    proxyDraft.proxy = proxy;
    if (parentDraft) {
        const target = parentDraft;
        target.finalities.draft.push((patches, inversePatches)=>{
            var _a, _b;
            const oldProxyDraft = getProxyDraft(proxy);
            // if target is a Set draft, `setMap` is the real Set copies proxy mapping.
            let copy = target.type === 3 /* DraftType.Set */  ? target.setMap : target.copy;
            const draft = get(copy, key);
            const proxyDraft = getProxyDraft(draft);
            if (proxyDraft) {
                // assign the updated value to the copy object
                let updatedValue = proxyDraft.original;
                if (proxyDraft.operated) {
                    updatedValue = getValue(draft);
                }
                finalizeSetValue(proxyDraft);
                finalizePatches(proxyDraft, generatePatches, patches, inversePatches);
                if (target.options.enableAutoFreeze) {
                    target.options.updatedValues = (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : new WeakMap();
                    target.options.updatedValues.set(updatedValue, proxyDraft.original);
                }
                // final update value
                set(copy, key, updatedValue);
            }
            // !case: handle the deleted key
            (_b = oldProxyDraft.callbacks) === null || _b === void 0 ? void 0 : _b.forEach((callback)=>{
                callback(patches, inversePatches);
            });
        });
    } else {
        // !case: handle the root draft
        const target = getProxyDraft(proxy);
        target.finalities.draft.push((patches, inversePatches)=>{
            finalizeSetValue(target);
            finalizePatches(target, generatePatches, patches, inversePatches);
        });
    }
    return proxy;
}
internal.createDraft = createDraft;
function finalizeDraft(result, returnedValue, patches, inversePatches, enableAutoFreeze) {
    var _a;
    const proxyDraft = getProxyDraft(result);
    const original = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : result;
    const hasReturnedValue = !!returnedValue.length;
    if (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated) {
        while(proxyDraft.finalities.draft.length > 0){
            const finalize = proxyDraft.finalities.draft.pop();
            finalize(patches, inversePatches);
        }
    }
    const state = hasReturnedValue ? returnedValue[0] : proxyDraft ? proxyDraft.operated ? proxyDraft.copy : proxyDraft.original : result;
    if (proxyDraft) revokeProxy(proxyDraft);
    if (enableAutoFreeze) {
        deepFreeze(state, state, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options.updatedValues);
    }
    return [
        state,
        patches && hasReturnedValue ? [
            {
                op: Operation.Replace,
                path: [],
                value: returnedValue[0]
            }
        ] : patches,
        inversePatches && hasReturnedValue ? [
            {
                op: Operation.Replace,
                path: [],
                value: original
            }
        ] : inversePatches
    ];
}
function draftify(baseState, options) {
    var _a;
    const finalities = {
        draft: [],
        revoke: [],
        handledSet: new WeakSet(),
        draftsCache: new WeakSet()
    };
    let patches;
    let inversePatches;
    if (options.enablePatches) {
        patches = [];
        inversePatches = [];
    }
    const isMutable = ((_a = options.mark) === null || _a === void 0 ? void 0 : _a.call(options, baseState, dataTypes)) === dataTypes.mutable || !isDraftable(baseState, options);
    const draft = isMutable ? baseState : createDraft({
        original: baseState,
        parentDraft: null,
        finalities,
        options
    });
    return [
        draft,
        (returnedValue = [])=>{
            const [finalizedState, finalizedPatches, finalizedInversePatches] = finalizeDraft(draft, returnedValue, patches, inversePatches, options.enableAutoFreeze);
            return options.enablePatches ? [
                finalizedState,
                finalizedPatches,
                finalizedInversePatches
            ] : finalizedState;
        }
    ];
}
function handleReturnValue(options) {
    const { rootDraft, value, useRawReturn = false, isRoot = true } = options;
    forEach(value, (key, item, source)=>{
        const proxyDraft = getProxyDraft(item);
        // just handle the draft which is created by the same rootDraft
        if (proxyDraft && rootDraft && proxyDraft.finalities === rootDraft.finalities) {
            options.isContainDraft = true;
            const currentValue = proxyDraft.original;
            // final update value, but just handle return value
            if (source instanceof Set) {
                const arr = Array.from(source);
                source.clear();
                arr.forEach((_item)=>source.add(key === _item ? currentValue : _item));
            } else {
                set(source, key, currentValue);
            }
        } else if (typeof item === 'object' && item !== null) {
            options.value = item;
            options.isRoot = false;
            handleReturnValue(options);
        }
    });
    if (isRoot) {
        if (!options.isContainDraft) console.warn(`The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`);
        if (useRawReturn) {
            console.warn(`The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`);
        }
    }
}
function getCurrent(target) {
    var _a;
    const proxyDraft = getProxyDraft(target);
    if (!isDraftable(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options)) return target;
    const type = getType(target);
    if (proxyDraft && !proxyDraft.operated) return proxyDraft.original;
    let currentValue;
    function ensureShallowCopy() {
        currentValue = type === 2 /* DraftType.Map */  ? !isBaseMapInstance(target) ? new (Object.getPrototypeOf(target)).constructor(target) : new Map(target) : type === 3 /* DraftType.Set */  ? Array.from(proxyDraft.setMap.values()) : shallowCopy(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options);
    }
    if (proxyDraft) {
        // It's a proxy draft, let's create a shallow copy eagerly
        proxyDraft.finalized = true;
        try {
            ensureShallowCopy();
        } finally{
            proxyDraft.finalized = false;
        }
    } else {
        // It's not a proxy draft, let's use the target directly and let's see
        // lazily if we need to create a shallow copy
        currentValue = target;
    }
    forEach(currentValue, (key, value)=>{
        if (proxyDraft && isEqual(get(proxyDraft.original, key), value)) return;
        const newValue = getCurrent(value);
        if (newValue !== value) {
            if (currentValue === target) ensureShallowCopy();
            set(currentValue, key, newValue);
        }
    });
    if (type === 3 /* DraftType.Set */ ) {
        const value = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : currentValue;
        return !isBaseSetInstance(value) ? new (Object.getPrototypeOf(value)).constructor(currentValue) : new Set(currentValue);
    }
    return currentValue;
}
function current(target) {
    if (!isDraft(target)) {
        throw new Error(`current() is only used for Draft, parameter: ${target}`);
    }
    return getCurrent(target);
}
/**
 * `makeCreator(options)` to make a creator function.
 *
 * ## Example
 *
 * ```ts
 * import { makeCreator } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const create = makeCreator({ enableAutoFreeze: true });
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *   },
 * );
 *
 * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });
 * expect(state).not.toBe(baseState);
 * expect(state.foo).not.toBe(baseState.foo);
 * expect(state.arr).toBe(baseState.arr);
 * expect(Object.isFrozen(state)).toBeTruthy();
 * ```
 */ const makeCreator = (arg)=>{
    if (arg !== undefined && Object.prototype.toString.call(arg) !== '[object Object]') {
        throw new Error(`Invalid options: ${String(arg)}, 'options' should be an object.`);
    }
    return function create(arg0, arg1, arg2) {
        var _a, _b, _c;
        if (typeof arg0 === 'function' && typeof arg1 !== 'function') {
            return function(base, ...args) {
                return create(base, (draft)=>arg0.call(this, draft, ...args), arg1);
            };
        }
        const base = arg0;
        const mutate = arg1;
        let options = arg2;
        if (typeof arg1 !== 'function') {
            options = arg1;
        }
        if (options !== undefined && Object.prototype.toString.call(options) !== '[object Object]') {
            throw new Error(`Invalid options: ${options}, 'options' should be an object.`);
        }
        options = Object.assign(Object.assign({}, arg), options);
        const state = isDraft(base) ? current(base) : base;
        const mark = Array.isArray(options.mark) ? (value, types)=>{
            for (const mark of options.mark){
                if (typeof mark !== 'function') {
                    throw new Error(`Invalid mark: ${mark}, 'mark' should be a function.`);
                }
                const result = mark(value, types);
                if (result) {
                    return result;
                }
            }
            return;
        } : options.mark;
        const enablePatches = (_a = options.enablePatches) !== null && _a !== void 0 ? _a : false;
        const strict = (_b = options.strict) !== null && _b !== void 0 ? _b : false;
        const enableAutoFreeze = (_c = options.enableAutoFreeze) !== null && _c !== void 0 ? _c : false;
        const _options = {
            enableAutoFreeze,
            mark,
            strict,
            enablePatches
        };
        if (!isDraftable(state, _options) && typeof state === 'object' && state !== null) {
            throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
        }
        const [draft, finalize] = draftify(state, _options);
        if (typeof arg1 !== 'function') {
            if (!isDraftable(state, _options)) {
                throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
            }
            return [
                draft,
                finalize
            ];
        }
        let result;
        try {
            result = mutate(draft);
        } catch (error) {
            revokeProxy(getProxyDraft(draft));
            throw error;
        }
        const returnValue = (value)=>{
            const proxyDraft = getProxyDraft(draft);
            if (!isDraft(value)) {
                if (value !== undefined && !isEqual(value, draft) && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated)) {
                    throw new Error(`Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`);
                }
                const rawReturnValue = value === null || value === void 0 ? void 0 : value[RAW_RETURN_SYMBOL];
                if (rawReturnValue) {
                    const _value = rawReturnValue[0];
                    if (_options.strict && typeof value === 'object' && value !== null) {
                        handleReturnValue({
                            rootDraft: proxyDraft,
                            value,
                            useRawReturn: true
                        });
                    }
                    return finalize([
                        _value
                    ]);
                }
                if (value !== undefined) {
                    if (typeof value === 'object' && value !== null) {
                        handleReturnValue({
                            rootDraft: proxyDraft,
                            value
                        });
                    }
                    return finalize([
                        value
                    ]);
                }
            }
            if (value === draft || value === undefined) {
                return finalize([]);
            }
            const returnedProxyDraft = getProxyDraft(value);
            if (_options === returnedProxyDraft.options) {
                if (returnedProxyDraft.operated) {
                    throw new Error(`Cannot return a modified child draft.`);
                }
                return finalize([
                    current(value)
                ]);
            }
            return finalize([
                value
            ]);
        };
        if (result instanceof Promise) {
            return result.then(returnValue, (error)=>{
                revokeProxy(getProxyDraft(draft));
                throw error;
            });
        }
        return returnValue(result);
    };
};
/**
 * `create(baseState, callback, options)` to create the next state
 *
 * ## Example
 *
 * ```ts
 * import { create } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *   },
 * );
 *
 * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });
 * expect(state).not.toBe(baseState);
 * expect(state.foo).not.toBe(baseState.foo);
 * expect(state.arr).toBe(baseState.arr);
 * ```
 */ const create = makeCreator();
/**
 * `apply(state, patches)` to apply patches to state
 *
 * ## Example
 *
 * ```ts
 * import { create, apply } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const [state, patches] = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *   },
 *   { enablePatches: true }
 * );
 * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });
 * expect(patches).toEqual([{ op: 'replace', path: ['foo', 'bar'], value: 'str2' }]);
 * expect(state).toEqual(apply(baseState, patches));
 * ```
 */ function apply(state, patches, applyOptions) {
    let i;
    for(i = patches.length - 1; i >= 0; i -= 1){
        const { value, op, path } = patches[i];
        if (!path.length && op === Operation.Replace || path === '' && op === Operation.Add) {
            state = value;
            break;
        }
    }
    if (i > -1) {
        patches = patches.slice(i + 1);
    }
    const mutate = (draft)=>{
        patches.forEach((patch)=>{
            const { path: _path, op } = patch;
            const path = unescapePath(_path);
            let base = draft;
            for(let index = 0; index < path.length - 1; index += 1){
                const parentType = getType(base);
                let key = path[index];
                if (typeof key !== 'string' && typeof key !== 'number') {
                    key = String(key);
                }
                if ((parentType === 0 /* DraftType.Object */  || parentType === 1 /* DraftType.Array */ ) && (key === '__proto__' || key === 'constructor') || typeof base === 'function' && key === 'prototype') {
                    throw new Error(`Patching reserved attributes like __proto__ and constructor is not allowed.`);
                }
                // use `index` in Set draft
                base = get(parentType === 3 /* DraftType.Set */  ? Array.from(base) : base, key);
                if (typeof base !== 'object') {
                    throw new Error(`Cannot apply patch at '${path.join('/')}'.`);
                }
            }
            const type = getType(base);
            // ensure the original patch is not modified.
            const value = deepClone(patch.value);
            const key = path[path.length - 1];
            switch(op){
                case Operation.Replace:
                    switch(type){
                        case 2 /* DraftType.Map */ :
                            return base.set(key, value);
                        case 3 /* DraftType.Set */ :
                            throw new Error(`Cannot apply replace patch to set.`);
                        default:
                            return base[key] = value;
                    }
                case Operation.Add:
                    switch(type){
                        case 1 /* DraftType.Array */ :
                            // If the "-" character is used to
                            // index the end of the array (see [RFC6901](https://datatracker.ietf.org/doc/html/rfc6902)),
                            // this has the effect of appending the value to the array.
                            return key === '-' ? base.push(value) : base.splice(key, 0, value);
                        case 2 /* DraftType.Map */ :
                            return base.set(key, value);
                        case 3 /* DraftType.Set */ :
                            return base.add(value);
                        default:
                            return base[key] = value;
                    }
                case Operation.Remove:
                    switch(type){
                        case 1 /* DraftType.Array */ :
                            return base.splice(key, 1);
                        case 2 /* DraftType.Map */ :
                            return base.delete(key);
                        case 3 /* DraftType.Set */ :
                            return base.delete(patch.value);
                        default:
                            return delete base[key];
                    }
                default:
                    throw new Error(`Unsupported patch operation: ${op}.`);
            }
        });
    };
    if (applyOptions === null || applyOptions === void 0 ? void 0 : applyOptions.mutable) {
        {
            if (Object.keys(applyOptions).filter((key)=>key !== 'mutable').length) {
                console.warn('The "mutable" option is not allowed to be used with other options.');
            }
        }
        mutate(state);
        return undefined;
    }
    if (isDraft(state)) {
        if (applyOptions !== undefined) {
            throw new Error(`Cannot apply patches with options to a draft.`);
        }
        mutate(state);
        return state;
    }
    return create(state, mutate, Object.assign(Object.assign({}, applyOptions), {
        enablePatches: false
    }));
}
/**
 * `original(draft)` to get original state in the draft mutation function.
 *
 * ## Example
 *
 * ```ts
 * import { create, original } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     draft.foo.bar = 'str2';
 *     expect(original(draft.foo)).toEqual({ bar: 'str' });
 *   }
 * );
 * ```
 */ function original(target) {
    const proxyDraft = getProxyDraft(target);
    if (!proxyDraft) {
        throw new Error(`original() is only used for a draft, parameter: ${target}`);
    }
    return proxyDraft.original;
}
/**
 * Use rawReturn() to wrap the return value to skip the draft check and thus improve performance.
 *
 * ## Example
 *
 * ```ts
 * import { create, rawReturn } from '../index';
 *
 * const baseState = { foo: { bar: 'str' }, arr: [] };
 * const state = create(
 *   baseState,
 *   (draft) => {
 *     return rawReturn(baseState);
 *   },
 * );
 * expect(state).toBe(baseState);
 * ```
 */ function rawReturn(value) {
    if (arguments.length === 0) {
        throw new Error('rawReturn() must be called with a value.');
    }
    if (arguments.length > 1) {
        throw new Error('rawReturn() must be called with one argument.');
    }
    if (value !== undefined && (typeof value !== 'object' || value === null)) {
        console.warn('rawReturn() must be called with an object(including plain object, arrays, Set, Map, etc.) or `undefined`, other types do not need to be returned via rawReturn().');
    }
    return {
        [RAW_RETURN_SYMBOL]: [
            value
        ]
    };
}
const constructorString = Object.prototype.constructor.toString();
/**
 * Check if the value is a simple object(No prototype chain object or iframe same-origin object),
 * support case: https://github.com/unadlib/mutative/issues/17
 */ const isSimpleObject = (value)=>{
    if (!value || typeof value !== 'object') return false;
    const prototype = Object.getPrototypeOf(value);
    if (prototype === null) {
        return true;
    }
    const constructor = Object.hasOwnProperty.call(prototype, 'constructor') && prototype.constructor;
    if (constructor === Object) return true;
    return typeof constructor === 'function' && Function.toString.call(constructor) === constructorString;
};
const markSimpleObject = (value)=>{
    if (isSimpleObject(value)) {
        return dataTypes.immutable;
    }
    return;
};
/**
 * Cast a value to an Draft type value.
 */ function castDraft(value) {
    return value;
}
/**
 * Cast a value to an Immutable type value.
 */ function castImmutable(value) {
    return value;
}
/**
 * Cast a value to an Mutable type value.
 */ function castMutable(draft) {
    return draft;
}
;
 //# sourceMappingURL=mutative.esm.mjs.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/object.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "areObjectKeysEqual",
    ()=>areObjectKeysEqual,
    "areObjectsDeepEqual",
    ()=>areObjectsDeepEqual,
    "areObjectsShallowEqual",
    ()=>areObjectsShallowEqual,
    "assocInMutative",
    ()=>assocInMutative,
    "dissocInMutative",
    ()=>dissocInMutative,
    "immutableDeepMerge",
    ()=>immutableDeepMerge,
    "immutableDeepReplace",
    ()=>immutableDeepReplace,
    "immutableOmitValue",
    ()=>immutableOmitValue,
    "immutableRemoveUndefined",
    ()=>immutableRemoveUndefined,
    "insertInMutative",
    ()=>insertInMutative,
    "isObject",
    ()=>isObject
]);
function areObjectKeysEqual(a, b) {
    const ak = Object.keys(a);
    const bk = Object.keys(b);
    return ak.length === bk.length && Object.keys(a).every((k)=>b.hasOwnProperty(k));
}
function areObjectsShallowEqual(obj1, obj2) {
    return Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key)=>obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);
}
function areObjectsDeepEqual(obj1, obj2) {
    if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || obj1 === null || obj2 === null) {
        return obj1 === obj2;
    }
    if (!areObjectKeysEqual(obj1, obj2)) {
        return false;
    }
    return Object.keys(obj1).every((key)=>areObjectsDeepEqual(obj1[key], obj2[key]));
}
function immutableRemoveUndefined(obj) {
    if (!isObject(obj)) {
        return obj;
    }
    const result = {};
    for (const [key, value] of Object.entries(obj)){
        if (value === undefined) continue;
        result[key] = value;
    }
    return result;
}
function immutableDeepMerge(target, source) {
    if (!isObject(target) || !isObject(source)) {
        return source;
    }
    const result = {
        ...target
    };
    for (const key of Object.keys(source)){
        if (source[key] === undefined) continue;
        if (source[key] === null) {
            delete result[key];
            continue;
        }
        const areBothObjects = isObject(target[key]) && isObject(source[key]);
        result[key] = areBothObjects ? immutableDeepMerge(target[key], source[key]) : source[key];
    }
    return result;
}
function immutableDeepReplace(target, replaceValue, replacementValue) {
    if (!isObject(target)) {
        return target;
    }
    const result = {};
    for (const [key, value] of Object.entries(target)){
        result[key] = isObject(value) ? immutableDeepReplace(value, replaceValue, replacementValue) : value === replaceValue ? replacementValue : value;
    }
    return result;
}
function isObject(val) {
    return typeof val === 'object' && val !== null && !Array.isArray(val);
}
function immutableOmitValue(obj, v) {}
function insertInMutative(obj, path, value) {
    if (!obj) {
        return;
    }
    if (path.length === 0) {
        return;
    }
    let current = obj || {};
    for(let i = 0; i < path.length - 1; i++){
        const key = path[i];
        if (!(key in current) || typeof current[key] !== 'object') {
            current[key] = typeof path[i + 1] === 'number' ? [] : {};
        }
        current = current[key];
    }
    const key = path[path.length - 1];
    if (Array.isArray(current) && typeof key === 'number') {
        current.splice(key, 0, value);
    } else {
        current[key] = value;
    }
}
function assocInMutative(obj, path, value) {
    if (!obj) {
        return;
    }
    if (path.length === 0) {
        return;
    }
    let current = obj || {};
    for(let i = 0; i < path.length - 1; i++){
        const key = path[i];
        if (!(key in current) || typeof current[key] !== 'object') {
            current[key] = typeof path[i + 1] === 'number' ? [] : {};
        }
        current = current[key];
    }
    current[path[path.length - 1]] = value;
}
function dissocInMutative(obj, path) {
    if (!obj) {
        return;
    }
    if (path.length === 0) {
        return;
    }
    const [key, ...restPath] = path;
    if (!(key in obj)) {
        return;
    }
    if (restPath.length === 0) {
        if (Array.isArray(obj)) {
            obj.splice(key, 1);
        } else {
            delete obj[key];
        }
        return;
    }
    dissocInMutative(obj[key], restPath);
    if (isEmpty(obj[key])) {
        delete obj[key];
    }
}
function isEmpty(obj) {
    return obj && Object.keys(obj).length === 0;
} //# sourceMappingURL=object.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/pgtime.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "pgTimezoneAbbrevs",
    ()=>pgTimezoneAbbrevs,
    "pgTimezoneMatch",
    ()=>pgTimezoneMatch
]);
const pgTimezoneMatch = /ZULU|YEKT|YEKST|YAPT|YAKT|YAKST|XJT|WGT|WGST|WFT|WETDST|WET|WDT|WAT|WAST|WAKT|WADT|VUT|VOLT|VLAT|VLAST|VET|UZT|UZST|UYT|UYST|UTC|UT|ULAT|ULAST|UCT|TVT|TRUT|TOT|TMT|TKT|TJT|TFT|TAHT|SGT|SCT|SAST|SADT|RET|PYT|PYST|PWT|PST|PONT|PMST|PMDT|PKT|PKST|PHT|PGT|PETT|PETST|PET|PDT|OMST|OMSST|NZT|NZST|NZDT|NUT|NST|NPT|NOVT|NOVST|NFT|NDT|MYT|MVT|MUT|MUST|MST|MSK|MSD|MPT|MMT|MHT|MEZ|METDST|MET|MESZ|MEST|MDT|MAWT|MART|MAGT|MAGST|LKT|LINT|LIGT|LHST|LHDT|KST|KRAT|KRAST|KOST|KGT|KGST|KDT|JST|JAYT|IST|IRT|IRKT|IRKST|IOT|IDT|ICT|HST|HKT|GYT|GMT|GILT|GFT|GET|GEST|GAMT|GALT|FNT|FNST|FKT|FKST|FJT|FJST|FET|EST|EGT|EGST|EETDST|EET|EEST|EDT|EAT|EAST|EASST|DDUT|DAVT|CXT|CST|COT|CLT|CLST|CKT|CHUT|CHAST|CHADT|CETDST|CET|CEST|CDT|CCT|CAST|CADT|BTT|BST|BRT|BRST|BRA|BOT|BORT|BNT|BDT|BDST|AZT|AZST|AZOT|AZOST|AWST|AWSST|AST|ART|ARST|ANAT|ANAST|AMT|AMST|ALMT|ALMST|AKST|AKDT|AFT|AEST|AESST|AEDT|ADT|ACWST|ACT|ACST|ACSST|ACDT$/;
const pgTimezoneAbbrevs = {
    ZULU: 0,
    YEKT: 18000,
    YEKST: 21600,
    YAPT: 36000,
    YAKT: 32400,
    YAKST: 32400,
    XJT: 21600,
    WGT: -10800,
    WGST: -7200,
    WFT: 43200,
    WETDST: 3600,
    WET: 0,
    WDT: 32400,
    WAT: 3600,
    WAST: 25200,
    WAKT: 43200,
    WADT: 28800,
    VUT: 39600,
    VOLT: 10800,
    VLAT: 36000,
    VLAST: 36000,
    VET: -14400,
    UZT: 18000,
    UZST: 21600,
    UYT: -10800,
    UYST: -7200,
    UTC: 0,
    UT: 0,
    ULAT: 28800,
    ULAST: 32400,
    UCT: 0,
    TVT: 43200,
    TRUT: 36000,
    TOT: 46800,
    TMT: 18000,
    TKT: 46800,
    TJT: 18000,
    TFT: 18000,
    TAHT: -36000,
    SGT: 28800,
    SCT: 14400,
    SAST: 7200,
    SADT: 37800,
    RET: 14400,
    PYT: -14400,
    PYST: -10800,
    PWT: 32400,
    PST: -28800,
    PONT: 39600,
    PMST: -10800,
    PMDT: -7200,
    PKT: 18000,
    PKST: 21600,
    PHT: 28800,
    PGT: 36000,
    PETT: 43200,
    PETST: 43200,
    PET: -18000,
    PDT: -25200,
    OMST: 21600,
    OMSST: 21600,
    NZT: 43200,
    NZST: 43200,
    NZDT: 46800,
    NUT: -39600,
    NST: -12600,
    NPT: 20700,
    NOVT: 25200,
    NOVST: 25200,
    NFT: -12600,
    NDT: -9000,
    MYT: 28800,
    MVT: 18000,
    MUT: 14400,
    MUST: 18000,
    MST: -25200,
    MSK: 10800,
    MSD: 14400,
    MPT: 36000,
    MMT: 23400,
    MHT: 43200,
    MEZ: 3600,
    METDST: 7200,
    MET: 3600,
    MESZ: 7200,
    MEST: 7200,
    MDT: -21600,
    MAWT: 18000,
    MART: -34200,
    MAGT: 39600,
    MAGST: 39600,
    LKT: 19800,
    LINT: 50400,
    LIGT: 36000,
    LHST: 37800,
    LHDT: 37800,
    KST: 32400,
    KRAT: 25200,
    KRAST: 25200,
    KOST: 39600,
    KGT: 21600,
    KGST: 21600,
    KDT: 36000,
    JST: 32400,
    JAYT: 32400,
    IST: 7200,
    IRT: 12600,
    IRKT: 28800,
    IRKST: 28800,
    IOT: 21600,
    IDT: 10800,
    ICT: 25200,
    HST: -36000,
    HKT: 28800,
    GYT: -14400,
    GMT: 0,
    GILT: 43200,
    GFT: -10800,
    GET: 14400,
    GEST: 14400,
    GAMT: -32400,
    GALT: -21600,
    FNT: -7200,
    FNST: -3600,
    FKT: -10800,
    FKST: -10800,
    FJT: 43200,
    FJST: 46800,
    FET: 10800,
    EST: -18000,
    EGT: -3600,
    EGST: 0,
    EETDST: 10800,
    EET: 7200,
    EEST: 10800,
    EDT: -14400,
    EAT: 10800,
    EAST: -21600,
    EASST: -21600,
    DDUT: 36000,
    DAVT: 25200,
    CXT: 25200,
    CST: -21600,
    COT: -18000,
    CLT: -14400,
    CLST: -10800,
    CKT: -36000,
    CHUT: 36000,
    CHAST: 45900,
    CHADT: 49500,
    CETDST: 7200,
    CET: 3600,
    CEST: 7200,
    CDT: -18000,
    CCT: 28800,
    CAST: 34200,
    CADT: 37800,
    BTT: 21600,
    BST: 3600,
    BRT: -10800,
    BRST: -7200,
    BRA: -10800,
    BOT: -14400,
    BORT: 28800,
    BNT: 28800,
    BDT: 21600,
    BDST: 7200,
    AZT: 14400,
    AZST: 14400,
    AZOT: -3600,
    AZOST: 0,
    AWST: 28800,
    AWSST: 32400,
    AST: -14400,
    ART: -10800,
    ARST: -10800,
    ANAT: 43200,
    ANAST: 43200,
    AMT: -14400,
    AMST: 14400,
    ALMT: 21600,
    ALMST: 25200,
    AKST: -32400,
    AKDT: -28800,
    AFT: 16200,
    AEST: 36000,
    AESST: 39600,
    AEDT: 39600,
    ADT: -10800,
    ACWST: 31500,
    ACT: -18000,
    ACST: 34200,
    ACSST: 37800,
    ACDT: 37800
}; //# sourceMappingURL=pgtime.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/dates.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "coerceToDate",
    ()=>coerceToDate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$pgtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/pgtime.js [app-client] (ecmascript)");
;
// Date parsing functions
function zonedDateTimeStrToInstant(s) {
    return new Date(s);
}
function localDateTimeStrToInstant(s) {
    // Parse as UTC since there's no timezone info
    return new Date(s + 'Z');
}
const localDateStrRe = /^(\d+)[\./-](\d+)[\./-](\d+)$/;
function localDateStrToInstant(s) {
    const match = s.match(localDateStrRe);
    if (!match) {
        return null;
    }
    const [_, part1, part2, part3] = match;
    if (part1 <= 0 || part2 <= 0 || part3 <= 0) {
        return null;
    }
    if (part1 > 999) {
        return new Date(Date.UTC(part1, part2 - 1, part3, 0, 0, 0, 0));
    }
    return new Date(Date.UTC(part3, part1 - 1, part2, 0, 0, 0, 0));
}
// Custom date formatters
function offioDateStrToInstant(s) {
    // Format: "yyyy-MM-dd HH:mm:ss"
    // Treat as UTC
    const [datePart, timePart] = s.split(' ');
    return new Date(datePart + 'T' + timePart + 'Z');
}
function zenecaDateStrToInstant(s) {
    // Format: "yyyy-MM-dd HH:mm:ss.n"
    // Treat as UTC
    const [datePart, timeWithNanos] = s.split(' ');
    // JavaScript Date can handle fractional seconds
    return new Date(datePart + 'T' + timeWithNanos + 'Z');
}
function rfc1123ToInstant(s) {
    // RFC 1123 format is natively supported by Date constructor
    return new Date(s);
}
function dowMonDayYearStrToInstant(s) {
    // Format: "EEE MMM dd yyyy" (e.g., "Wed Jan 15 2025")
    //Only parse if the string is in the correct format
    const regex = /^(\w{3}) (\w{3}) (\d{2}) (\d{4})$/;
    const match = s.match(regex);
    if (!match) {
        throw new Error(`Unable to parse \`${s}\` as a date.`);
    }
    const date = new Date(s + ' UTC'); // Force UTC parsing
    return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0, 0));
}
function iso8601IncompleteOffsetToInstant(s) {
    // Format: "2025-01-02T00:00:00-08" (missing minutes in timezone offset)
    // Convert to proper ISO 8601 format by adding ":00" to the timezone offset
    const regex = /^(.+T.+)([+-])(\d{2})$/;
    const match = s.match(regex);
    if (match) {
        const [, dateTimePart, sign, hours] = match;
        const correctedString = `${dateTimePart}${sign}${hours}:00`;
        return new Date(correctedString);
    }
    return null;
}
function iso8601SingleDigitToInstant(s) {
    // Format: "2025-11-2T00:00:00.000Z" or "2025-1-2T00:00:00Z" (single-digit month/day)
    // Also handles space separator: "2025-1-2 00:00:00"
    // Normalize to proper ISO 8601 format with two-digit month and day
    const regex = /^(\d+)-(\d{1,2})-(\d{1,2})([ T])(.+)$/;
    const match = s.match(regex);
    if (match) {
        const [, year, month, day, separator, rest] = match;
        const paddedMonth = month.padStart(2, '0');
        const paddedDay = day.padStart(2, '0');
        const correctedString = `${year}-${paddedMonth}-${paddedDay}T${rest}`;
        return new Date(correctedString);
    }
    return null;
}
function usDateTimeStrToInstant(s) {
    // Format: "M/d/yyyy, h:mm:ss a" (e.g., "8/4/2025, 11:02:31 PM")
    const [datePart, timePart] = s.split(', ');
    const [month, day, year] = datePart.split('/').map(Number);
    // Parse time with AM/PM
    const timeMatch = timePart.match(/(\d{1,2}):(\d{2}):(\d{2}) (AM|PM)/);
    if (!timeMatch) {
        throw new Error(`Unable to parse time from: ${s}`);
    }
    let [, hours, minutes, seconds, ampm] = timeMatch;
    hours = Number(hours);
    minutes = Number(minutes);
    seconds = Number(seconds);
    // Convert 12-hour to 24-hour format
    if (ampm === 'PM' && hours !== 12) {
        hours += 12;
    } else if (ampm === 'AM' && hours === 12) {
        hours = 0;
    }
    // Create date in UTC
    return new Date(Date.UTC(year, month - 1, day, hours, minutes, seconds));
}
// https://www.postgresql.org/docs/17/datatype-datetime.html#DATATYPE-DATETIME-SPECIAL-VALUES
function specialStrToInstant(s) {
    switch(s){
        case 'epoch':
            return new Date(0);
        // These are not implemented yet because we need some way for the
        // client and server to aggree on the values
        case 'infinity':
        case '-infinity':
        case 'today':
        case 'tomorrow':
        case 'yesterday':
            return null;
    }
}
function pgTimezoneStrToInstant(s) {
    const match = s.match(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$pgtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pgTimezoneMatch"]);
    if (!match) {
        return null;
    }
    const [tz] = match;
    const offset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$pgtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pgTimezoneAbbrevs"][tz];
    const baseDate = new Date(s.replace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$pgtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pgTimezoneMatch"], 'Z'));
    return new Date(baseDate.getTime() - offset * 1000);
}
// Array of parsers
const dateParsers = [
    localDateStrToInstant,
    zenecaDateStrToInstant,
    dowMonDayYearStrToInstant,
    usDateTimeStrToInstant,
    rfc1123ToInstant,
    localDateTimeStrToInstant,
    iso8601IncompleteOffsetToInstant,
    offioDateStrToInstant,
    zonedDateTimeStrToInstant,
    specialStrToInstant,
    pgTimezoneStrToInstant,
    iso8601SingleDigitToInstant
];
// Try to parse with a specific parser
function tryParseDateString(parser, s) {
    try {
        const result = parser(s);
        // Check if result is valid date
        if (result instanceof Date && !isNaN(result.getTime())) {
            return result;
        }
        return null;
    } catch (e) {
        return null;
    }
}
// Try all parsers until one succeeds
function dateStrToInstant(s) {
    for (const parser of dateParsers){
        const instant = tryParseDateString(parser, s);
        if (instant) {
            return instant;
        }
    }
    return null;
}
// Parse JSON string and then try date parsing
function jsonStrToInstant(maybeJson) {
    try {
        const s = JSON.parse(maybeJson);
        if (typeof s === 'string') {
            return dateStrToInstant(s);
        }
        return null;
    } catch (e) {
        return null;
    }
}
function coerceToDate(x) {
    if (x === undefined) {
        return undefined;
    }
    if (x === null) {
        return null;
    }
    if (x instanceof Date) {
        return x;
    }
    if (typeof x === 'string') {
        const result = dateStrToInstant(x) || jsonStrToInstant(x) || dateStrToInstant(x.trim());
        if (!result) {
            throw new Error(`Unable to parse \`${x}\` as a date.`);
        }
        return result;
    } else if (typeof x === 'number') {
        return new Date(x);
    }
    throw new Error(`Invalid date value \`${x}\`. Expected a date, number, or string, got type ${typeof x}.`);
} //# sourceMappingURL=dates.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/store.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AttrsStoreClass",
    ()=>AttrsStoreClass,
    "addTriple",
    ()=>addTriple,
    "allMapValues",
    ()=>allMapValues,
    "attrsStoreFromJSON",
    ()=>attrsStoreFromJSON,
    "createStore",
    ()=>createStore,
    "fromJSON",
    ()=>fromJSON,
    "getAsObject",
    ()=>getAsObject,
    "getAttrByFwdIdentName",
    ()=>getAttrByFwdIdentName,
    "getAttrByReverseIdentName",
    ()=>getAttrByReverseIdentName,
    "getBlobAttrs",
    ()=>getBlobAttrs,
    "getInMap",
    ()=>getInMap,
    "getPrimaryKeyAttr",
    ()=>getPrimaryKeyAttr,
    "getTriples",
    ()=>getTriples,
    "hasEntity",
    ()=>hasEntity,
    "hasTriple",
    ()=>hasTriple,
    "isBlob",
    ()=>isBlob,
    "retractTriple",
    ()=>retractTriple,
    "toJSON",
    ()=>toJSON,
    "transact",
    ()=>transact
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mutative/dist/mutative.esm.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$dates$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/dates.js [app-client] (ecmascript)");
;
;
;
class AttrsStoreClass {
    attrs;
    linkIndex;
    _blobAttrs = null;
    _primaryKeys = null;
    _forwardIdents = null;
    _revIdents = null;
    constructor(attrs, linkIndex){
        this.attrs = attrs;
        this.linkIndex = linkIndex;
    }
    resetAttrIndexes() {
        this._blobAttrs = null;
        this._primaryKeys = null;
        this._forwardIdents = null;
        this._revIdents = null;
    }
    addAttr(attr) {
        this.attrs[attr.id] = attr;
        this.resetAttrIndexes();
    }
    deleteAttr(attrId) {
        delete this.attrs[attrId];
        this.resetAttrIndexes();
    }
    updateAttr(partialAttr) {
        const attr = this.attrs[partialAttr.id];
        if (!attr) return;
        this.attrs[partialAttr.id] = {
            ...attr,
            ...partialAttr
        };
        this.resetAttrIndexes();
    }
    getAttr(id) {
        return this.attrs[id];
    }
    get blobAttrs() {
        if (this._blobAttrs) {
            return this._blobAttrs;
        }
        this._blobAttrs = new Map();
        for (const attr of Object.values(this.attrs)){
            if (isBlob(attr)) {
                const [_, fwdEtype, fwdLabel] = attr['forward-identity'];
                setInMap(this.blobAttrs, [
                    fwdEtype,
                    fwdLabel
                ], attr);
            }
        }
        return this._blobAttrs;
    }
    get primaryKeys() {
        if (this._primaryKeys) {
            return this._primaryKeys;
        }
        this._primaryKeys = new Map();
        for (const attr of Object.values(this.attrs)){
            if (attr['primary?']) {
                const [_, fwdEtype] = attr['forward-identity'];
                setInMap(this._primaryKeys, [
                    fwdEtype
                ], attr);
            }
        }
        return this._primaryKeys;
    }
    get forwardIdents() {
        if (this._forwardIdents) {
            return this._forwardIdents;
        }
        this._forwardIdents = new Map();
        for (const attr of Object.values(this.attrs)){
            const fwdIdent = attr['forward-identity'];
            const [_, fwdEtype, fwdLabel] = fwdIdent;
            setInMap(this._forwardIdents, [
                fwdEtype,
                fwdLabel
            ], attr);
        }
        return this._forwardIdents;
    }
    get revIdents() {
        if (this._revIdents) {
            return this._revIdents;
        }
        this._revIdents = new Map();
        for (const attr of Object.values(this.attrs)){
            const revIdent = attr['reverse-identity'];
            if (revIdent) {
                const [_, revEtype, revLabel] = revIdent;
                setInMap(this._revIdents, [
                    revEtype,
                    revLabel
                ], attr);
            }
        }
        return this._revIdents;
    }
    toJSON() {
        return {
            attrs: this.attrs,
            linkIndex: this.linkIndex
        };
    }
}
function hasEA(attr) {
    return attr['cardinality'] === 'one';
}
function isRef(attr) {
    return attr['value-type'] === 'ref';
}
function isBlob(attr) {
    return attr['value-type'] === 'blob';
}
function getAttr(attrs, attrId) {
    return attrs[attrId];
}
function getInMap(obj, path) {
    return path.reduce((acc, key)=>acc && acc.get(key), obj);
}
function deleteInMap(m, path) {
    if (path.length === 0) throw new Error('path must have at least one element');
    if (path.length === 1) {
        m.delete(path[0]);
        return;
    }
    const [head, ...tail] = path;
    if (!m.has(head)) return;
    deleteInMap(m.get(head), tail);
}
function setInMap(m, path, value) {
    let current = m;
    const lastI = path.length - 1;
    for(let i = 0; i < lastI; i++){
        const part = path[i];
        let nextMap = current.get(part);
        if (nextMap === undefined) {
            nextMap = new Map();
            current.set(part, nextMap);
        }
        current = nextMap;
    }
    if (lastI > -1) {
        current.set(path[lastI], value);
    }
}
function isDateAttr(attr) {
    return attr['checked-data-type'] === 'date';
}
function createTripleIndexes(attrsStore, triples, useDateObjects) {
    const eav = new Map();
    const aev = new Map();
    const vae = new Map();
    for (const triple of triples){
        let [eid, aid, v] = triple;
        const attr = attrsStore.getAttr(aid);
        if (!attr) {
            console.warn('no such attr', aid, eid);
            continue;
        }
        if (attr['checked-data-type'] === 'date' && useDateObjects) {
            v = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$dates$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerceToDate"])(v);
            triple[2] = v;
        }
        if (isRef(attr)) {
            setInMap(vae, [
                v,
                aid,
                eid
            ], triple);
        }
        setInMap(eav, [
            eid,
            aid,
            v
        ], triple);
        setInMap(aev, [
            aid,
            eid,
            v
        ], triple);
    }
    return {
        eav,
        aev,
        vae
    };
}
function createAttrIndexes(attrs) {
    const blobAttrs = new Map();
    const primaryKeys = new Map();
    const forwardIdents = new Map();
    const revIdents = new Map();
    for (const attr of Object.values(attrs)){
        const fwdIdent = attr['forward-identity'];
        const [_, fwdEtype, fwdLabel] = fwdIdent;
        const revIdent = attr['reverse-identity'];
        setInMap(forwardIdents, [
            fwdEtype,
            fwdLabel
        ], attr);
        if (isBlob(attr)) {
            setInMap(blobAttrs, [
                fwdEtype,
                fwdLabel
            ], attr);
        }
        if (attr['primary?']) {
            setInMap(primaryKeys, [
                fwdEtype
            ], attr);
        }
        if (revIdent) {
            const [_, revEtype, revLabel] = revIdent;
            setInMap(revIdents, [
                revEtype,
                revLabel
            ], attr);
        }
    }
    return {
        blobAttrs,
        primaryKeys,
        forwardIdents,
        revIdents
    };
}
function toJSON(store) {
    return {
        triples: allMapValues(store.eav, 3),
        cardinalityInference: store.cardinalityInference,
        useDateObjects: store.useDateObjects,
        version: 1
    };
}
function fromJSON(attrsStore, storeJSON) {
    return createStore(attrsStore, storeJSON.triples, storeJSON.cardinalityInference, storeJSON.useDateObjects);
}
function attrsStoreFromJSON(attrsStoreJSON, storeJSON) {
    if (attrsStoreJSON) {
        return new AttrsStoreClass(attrsStoreJSON.attrs, attrsStoreJSON.linkIndex);
    }
    if (storeJSON && '__type' in storeJSON) {
        return new AttrsStoreClass(storeJSON.attrs, storeJSON.linkIndex);
    }
}
function hasTriple(store, [e, a, v]) {
    return getInMap(store.eav, [
        e,
        a,
        v
    ]) !== undefined;
}
function hasEntity(store, e) {
    return getInMap(store.eav, [
        e
    ]) !== undefined;
}
function createStore(attrsStore, triples, enableCardinalityInference, useDateObjects) {
    const store = createTripleIndexes(attrsStore, triples, useDateObjects);
    store.cardinalityInference = enableCardinalityInference;
    store.useDateObjects = useDateObjects;
    return store;
}
// We may have local triples with lookup refs in them,
// we need to convert those lookup refs to eids to insert them
// into the store. If we can't find the lookup ref locally,
// then we drop the triple and have to wait for the server response
// to see the optimistic updates.
function resolveLookupRefs(store, triple) {
    let eid;
    // Check if `e` is a lookup ref
    if (Array.isArray(triple[0])) {
        const [a, v] = triple[0];
        const eMaps = store.aev.get(a);
        if (!eMaps) {
            // We don't have the attr, so don't try to add the
            // triple to the store
            return null;
        }
        // This would be a lot more efficient with a ave index
        const triples = allMapValues(eMaps, 2);
        eid = triples.find((x)=>x[2] === v)?.[0];
    } else {
        eid = triple[0];
    }
    if (!eid) {
        // We don't know the eid that the ref refers to, so
        // we can't add the triple to the store.
        return null;
    }
    // Check if v is a lookup ref
    const lookupV = triple[2];
    if (Array.isArray(lookupV) && lookupV.length === 2 && store.aev.get(lookupV[0])) {
        const [a, v] = lookupV;
        const eMaps = store.aev.get(a);
        if (!eMaps) {
            // We don't have the attr, so don't try to add the
            // triple to the store
            return null;
        }
        const triples = allMapValues(eMaps, 2);
        const value = triples.find((x)=>x[2] === v)?.[0];
        if (!value) {
            return null;
        }
        const [_e, aid, _v, ...rest] = triple;
        return [
            eid,
            aid,
            value,
            ...rest
        ];
    } else {
        const [_, ...rest] = triple;
        return [
            eid,
            ...rest
        ];
    }
}
function retractTriple(store, attrsStore, rawTriple) {
    const triple = resolveLookupRefs(store, rawTriple);
    if (!triple) {
        return;
    }
    const [eid, aid, v] = triple;
    const attr = attrsStore.getAttr(aid);
    if (!attr) {
        return;
    }
    deleteInMap(store.eav, [
        eid,
        aid,
        v
    ]);
    deleteInMap(store.aev, [
        aid,
        eid,
        v
    ]);
    if (isRef(attr)) {
        deleteInMap(store.vae, [
            v,
            aid,
            eid
        ]);
    }
}
let _seed = 0;
function getCreatedAt(store, attr, triple) {
    const [eid, aid, v] = triple;
    let createdAt;
    const t = getInMap(store.eav, [
        eid,
        aid,
        v
    ]);
    if (t) {
        createdAt = t[3];
    }
    /**
     * (XXX)
     * Two hacks here, for generating a `createdAt`
     *
     * 1. We multiply Date.now() by 10, to make sure that
     *  `createdAt` is always greater than anything the server
     *   could return
     *
     *   We do this because right now we know we _only_ insert
     *   triples as optimistic updates.
     *
     * 2. We increment by `_seed`, to make sure there are no
     *    two triples with the same `createdAt`. This is
     *    done to make tests more predictable.
     *
     * We may need to rethink this. Because we * 10, we can't
     * use this value as an _actual_ `createdAt` timestamp.
     * Eventually we may want too though; For example, we could
     * use `createdAt` for each triple, to infer a `createdAt` and
     * `updatedAt` value for each object.
     */ return createdAt || Date.now() * 10 + _seed++;
}
function addTriple(store, attrsStore, rawTriple) {
    const triple = resolveLookupRefs(store, rawTriple);
    if (!triple) {
        return;
    }
    let [eid, aid, v] = triple;
    const attr = attrsStore.getAttr(aid);
    if (!attr) {
        // (XXX): Due to the way we're handling attrs, it's
        // possible to enter a state where we receive a triple without an attr.
        // See: https://github.com/jsventures/instant-local/pull/132 for details.
        // For now, if we receive a command without an attr, we no-op.
        return;
    }
    if (attr['checked-data-type'] === 'date' && store.useDateObjects) {
        v = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$dates$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerceToDate"])(v);
    }
    const existingTriple = getInMap(store.eav, [
        eid,
        aid,
        v
    ]);
    // Reuse the created_at for a triple if it's already in the store.
    // Prevents updates from temporarily pushing an entity to the top
    // while waiting for the server response.
    const t = existingTriple?.[3] ?? getCreatedAt(store, attr, triple);
    const enhancedTriple = [
        eid,
        aid,
        v,
        t
    ];
    if (hasEA(attr)) {
        setInMap(store.eav, [
            eid,
            aid
        ], new Map([
            [
                v,
                enhancedTriple
            ]
        ]));
        setInMap(store.aev, [
            aid,
            eid
        ], new Map([
            [
                v,
                enhancedTriple
            ]
        ]));
    } else {
        setInMap(store.eav, [
            eid,
            aid,
            v
        ], enhancedTriple);
        setInMap(store.aev, [
            aid,
            eid,
            v
        ], enhancedTriple);
    }
    if (isRef(attr)) {
        setInMap(store.vae, [
            v,
            aid,
            eid
        ], enhancedTriple);
    }
}
function mergeTriple(store, attrsStore, rawTriple) {
    const triple = resolveLookupRefs(store, rawTriple);
    if (!triple) {
        return;
    }
    const [eid, aid, update] = triple;
    const attr = attrsStore.getAttr(aid);
    if (!attr) return;
    if (!isBlob(attr)) throw new Error('merge operation is not supported for links');
    const eavValuesMap = getInMap(store.eav, [
        eid,
        aid
    ]);
    if (!eavValuesMap) return;
    const currentTriple = eavValuesMap.values().next()?.value;
    if (!currentTriple) return;
    const currentValue = currentTriple[2];
    const updatedValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["immutableDeepMerge"])(currentValue, update);
    const enhancedTriple = [
        eid,
        aid,
        updatedValue,
        getCreatedAt(store, attr, currentTriple)
    ];
    setInMap(store.eav, [
        eid,
        aid
    ], new Map([
        [
            updatedValue,
            enhancedTriple
        ]
    ]));
    setInMap(store.aev, [
        aid,
        eid
    ], new Map([
        [
            updatedValue,
            enhancedTriple
        ]
    ]));
}
function deleteEntity(store, attrsStore, args) {
    const [lookup, etype] = args;
    const triple = resolveLookupRefs(store, [
        lookup
    ]);
    if (!triple) {
        return;
    }
    const [id] = triple;
    // delete forward links and attributes + cardinality one links
    const eMap = store.eav.get(id);
    if (eMap) {
        for (const a of eMap.keys()){
            const attr = attrsStore.getAttr(a);
            // delete cascade refs
            if (attr && attr['on-delete-reverse'] === 'cascade') {
                allMapValues(eMap.get(a), 1).forEach(([e, a, v])=>deleteEntity(store, attrsStore, [
                        v,
                        attr['reverse-identity']?.[1]
                    ]));
            }
            if (// Fall back to deleting everything if we've rehydrated tx-steps from
            // the store that didn't set `etype` in deleteEntity
            !etype || // If we don't know about the attr, let's just get rid of it
            !attr || // Make sure it matches the etype
            attr['forward-identity']?.[1] === etype) {
                deleteInMap(store.aev, [
                    a,
                    id
                ]);
                deleteInMap(store.eav, [
                    id,
                    a
                ]);
            }
        }
        // Clear out the eav index for `id` if we deleted all of the attributes
        if (eMap.size === 0) {
            deleteInMap(store.eav, [
                id
            ]);
        }
    }
    // delete reverse links
    const vaeTriples = store.vae.get(id) && allMapValues(store.vae.get(id), 2);
    if (vaeTriples) {
        vaeTriples.forEach((triple)=>{
            const [e, a, v] = triple;
            const attr = attrsStore.getAttr(a);
            if (!etype || !attr || attr['reverse-identity']?.[1] === etype) {
                deleteInMap(store.eav, [
                    e,
                    a,
                    v
                ]);
                deleteInMap(store.aev, [
                    a,
                    e,
                    v
                ]);
                deleteInMap(store.vae, [
                    v,
                    a,
                    e
                ]);
            }
            if (attr && attr['on-delete'] === 'cascade' && attr['reverse-identity']?.[1] === etype) {
                deleteEntity(store, attrsStore, [
                    e,
                    attr['forward-identity']?.[1]
                ]);
            }
        });
    }
    // Clear out vae index for `id` if we deleted all the reverse attributes
    if (store.vae.get(id)?.size === 0) {
        deleteInMap(store.vae, [
            id
        ]);
    }
}
// (XXX): Whenever we change/delete attrs,
// We indiscriminately reset the index map.
// There are lots of opportunities for optimization:
// * We _only_ need to run this indexes change. We could detect that
// * We could batch this reset at the end
// * We could add an ave index for all triples, so removing the
//   right triples is easy and fast.
function resetIndexMap(store, attrsStore, newTriples) {
    const newIndexMap = createTripleIndexes(attrsStore, newTriples, store.useDateObjects);
    Object.keys(newIndexMap).forEach((key)=>{
        store[key] = newIndexMap[key];
    });
}
function addAttr(attrsStore, [attr]) {
    attrsStore.addAttr(attr);
}
function getAllTriples(store) {
    return allMapValues(store.eav, 3);
}
function deleteAttr(store, attrsStore, [id]) {
    if (!attrsStore.getAttr(id)) return;
    const newTriples = getAllTriples(store).filter(([_, aid])=>aid !== id);
    attrsStore.deleteAttr(id);
    resetIndexMap(store, attrsStore, newTriples);
}
function updateAttr(store, attrsStore, [partialAttr]) {
    const attr = attrsStore.getAttr(partialAttr.id);
    if (!attr) return;
    attrsStore.updateAttr(partialAttr);
    resetIndexMap(store, attrsStore, getAllTriples(store));
}
function applyTxStep(store, attrsStore, txStep) {
    const [action, ...args] = txStep;
    switch(action){
        case 'add-triple':
            addTriple(store, attrsStore, args);
            break;
        case 'deep-merge-triple':
            mergeTriple(store, attrsStore, args);
            break;
        case 'retract-triple':
            retractTriple(store, attrsStore, args);
            break;
        case 'delete-entity':
            deleteEntity(store, attrsStore, args);
            break;
        case 'add-attr':
            addAttr(attrsStore, args);
            break;
        case 'delete-attr':
            deleteAttr(store, attrsStore, args);
            break;
        case 'update-attr':
            updateAttr(store, attrsStore, args);
            break;
        case 'restore-attr':
            break;
        case 'rule-params':
            break;
        default:
            throw new Error(`unhandled transaction action: ${action}`);
    }
}
function allMapValues(m, level, res = []) {
    if (!m) {
        return res;
    }
    if (level === 0) {
        return res;
    }
    if (level === 1) {
        for (const v of m.values()){
            res.push(v);
        }
        return res;
    }
    for (const v of m.values()){
        allMapValues(v, level - 1, res);
    }
    return res;
}
function triplesByValue(store, m, v) {
    const res = [];
    if (v?.hasOwnProperty('$not')) {
        for (const candidate of m.keys()){
            if (v.$not !== candidate) {
                res.push(m.get(candidate));
            }
        }
        return res;
    }
    if (v?.hasOwnProperty('$isNull')) {
        const { attrId, isNull, reverse } = v.$isNull;
        if (reverse) {
            for (const candidate of m.keys()){
                const vMap = store.vae.get(candidate);
                const isValNull = !vMap || !vMap.get(attrId);
                if (isNull ? isValNull : !isValNull) {
                    res.push(m.get(candidate));
                }
            }
        } else {
            const aMap = store.aev.get(attrId);
            for (const candidate of m.keys()){
                const isValNull = !aMap || aMap.get(candidate)?.get(null) || !aMap.get(candidate);
                if (isNull ? isValNull : !isValNull) {
                    res.push(m.get(candidate));
                }
            }
        }
        return res;
    }
    if (v?.$comparator) {
        // TODO: A sorted index would be nice here
        return allMapValues(m, 1).filter(v.$op);
    }
    const values = v.in || v.$in || [
        v
    ];
    for (const value of values){
        const triple = m.get(value);
        if (triple) {
            res.push(triple);
        }
    }
    return res;
}
// A poor man's pattern matching
// Returns either eav, ea, ev, av, v, or ''
function whichIdx(e, a, v) {
    let res = '';
    if (e !== undefined) {
        res += 'e';
    }
    if (a !== undefined) {
        res += 'a';
    }
    if (v !== undefined) {
        res += 'v';
    }
    return res;
}
function getTriples(store, [e, a, v]) {
    const idx = whichIdx(e, a, v);
    switch(idx){
        case 'e':
            {
                const eMap = store.eav.get(e);
                return allMapValues(eMap, 2);
            }
        case 'ea':
            {
                const aMap = store.eav.get(e)?.get(a);
                return allMapValues(aMap, 1);
            }
        case 'eav':
            {
                const aMap = store.eav.get(e)?.get(a);
                if (!aMap) {
                    return [];
                }
                return triplesByValue(store, aMap, v);
            }
        case 'ev':
            {
                const eMap = store.eav.get(e);
                if (!eMap) {
                    return [];
                }
                const res = [];
                for (const aMap of eMap.values()){
                    res.push(...triplesByValue(store, aMap, v));
                }
                return res;
            }
        case 'a':
            {
                const aMap = store.aev.get(a);
                return allMapValues(aMap, 2);
            }
        case 'av':
            {
                const aMap = store.aev.get(a);
                if (!aMap) {
                    return [];
                }
                const res = [];
                for (const eMap of aMap.values()){
                    res.push(...triplesByValue(store, eMap, v));
                }
                return res;
            }
        case 'v':
            {
                const res = [];
                for (const eMap of store.eav.values()){
                    for (const aMap of eMap.values()){
                        res.push(...triplesByValue(store, aMap, v));
                    }
                }
                return res;
            }
        default:
            {
                return allMapValues(store.eav, 3);
            }
    }
}
function getAsObject(store, attrs, e) {
    const obj = {};
    if (!attrs) {
        return obj;
    }
    for (const [label, attr] of attrs.entries()){
        const aMap = store.eav.get(e)?.get(attr.id);
        const triples = allMapValues(aMap, 1);
        for (const triple of triples){
            obj[label] = triple[2];
        }
    }
    return obj;
}
function getAttrByFwdIdentName(attrsStore, inputEtype, inputLabel) {
    return attrsStore.forwardIdents.get(inputEtype)?.get(inputLabel);
}
function getAttrByReverseIdentName(attrsStore, inputEtype, inputLabel) {
    return attrsStore.revIdents.get(inputEtype)?.get(inputLabel);
}
function getBlobAttrs(attrsStore, etype) {
    return attrsStore.blobAttrs.get(etype);
}
function getPrimaryKeyAttr(attrsStore, etype) {
    const fromPrimary = attrsStore.primaryKeys.get(etype);
    if (fromPrimary) {
        return fromPrimary;
    }
    return attrsStore.forwardIdents.get(etype)?.get('id');
}
function findTriple(store, attrsStore, rawTriple) {
    const triple = resolveLookupRefs(store, rawTriple);
    if (!triple) {
        return;
    }
    const [eid, aid, v] = triple;
    const attr = attrsStore.getAttr(aid);
    if (!attr) {
        // (XXX): Due to the way we're handling attrs, it's
        // possible to enter a state where we receive a triple without an attr.
        // See: https://github.com/jsventures/instant-local/pull/132 for details.
        // For now, if we receive a command without an attr, we no-op.
        return;
    }
    return getInMap(store.eav, [
        eid,
        aid
    ]);
}
function transact(store, attrsStore, txSteps) {
    const txStepsFiltered = txSteps.filter(([action, eid, attrId, value, opts])=>{
        if (action !== 'add-triple' && action !== 'deep-merge-triple') {
            return true;
        }
        const mode = opts?.mode;
        if (mode !== 'create' && mode !== 'update') {
            return true;
        }
        let exists = false;
        const attr = attrsStore.getAttr(attrId);
        if (attr) {
            const idAttr = getPrimaryKeyAttr(attrsStore, attr['forward-identity'][1]);
            exists = !!findTriple(store, attrsStore, [
                eid,
                idAttr?.id,
                eid
            ]);
        }
        if (mode === 'create' && exists) {
            return false;
        }
        if (mode === 'update' && !exists) {
            return false;
        }
        return true;
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])({
        store,
        attrsStore
    }, (draft)=>{
        txStepsFiltered.forEach((txStep)=>{
            applyTxStep(draft.store, draft.attrsStore, txStep);
        });
    }, {
        mark: (target)=>{
            if (target instanceof AttrsStoreClass) {
                return 'immutable';
            }
        }
    });
} //# sourceMappingURL=store.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/datalog.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "matchPattern",
    ()=>matchPattern,
    "query",
    ()=>query,
    "querySingle",
    ()=>querySingle,
    "queryWhere",
    ()=>queryWhere
]);
// 1. patternMatch
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/store.js [app-client] (ecmascript)");
;
function isVariable(x) {
    return typeof x === 'string' && x.startsWith('?');
}
function matchVariable(variable, triplePart, context) {
    if (context.hasOwnProperty(variable)) {
        const bound = context[variable];
        return matchPart(bound, triplePart, context);
    }
    return {
        ...context,
        [variable]: triplePart
    };
}
function matchExact(patternPart, triplePart, context) {
    return patternPart === triplePart ? context : null;
}
function matcherForPatternPart(patternPart) {
    switch(typeof patternPart){
        case 'string':
            return patternPart.startsWith('?') ? matchVariable : matchExact;
        default:
            return matchExact;
    }
}
const validArgMapProps = [
    'in',
    '$in',
    '$not',
    '$isNull',
    '$comparator'
];
// Checks if an object is an args map
function isArgsMap(patternPart) {
    for (const prop of validArgMapProps){
        if (patternPart.hasOwnProperty(prop)) {
            return true;
        }
    }
    return false;
}
function matchPart(patternPart, triplePart, context) {
    if (!context) return null;
    if (typeof patternPart === 'object') {
        // This is an args map, so we'll have already fitered the triples
        // in `getRelevantTriples`
        if (isArgsMap(patternPart)) {
            return context;
        }
        return null;
    }
    const matcher = matcherForPatternPart(patternPart);
    return matcher(patternPart, triplePart, context);
}
function matchPattern(pattern, triple, context) {
    return pattern.reduce((context, patternPart, idx)=>{
        const triplePart = triple[idx];
        return matchPart(patternPart, triplePart, context);
    }, context);
}
function querySingle(store, pattern, context) {
    return relevantTriples(store, pattern, context).map((triple)=>matchPattern(pattern, triple, context)).filter((x)=>x);
}
// 3. queryWhere
function queryPattern(store, pattern, contexts) {
    if (pattern.or) {
        return pattern.or.patterns.flatMap((patterns)=>{
            return queryWhere(store, patterns, contexts);
        });
    }
    if (pattern.and) {
        return pattern.and.patterns.reduce((contexts, patterns)=>{
            return queryWhere(store, patterns, contexts);
        }, contexts);
    }
    return contexts.flatMap((context)=>querySingle(store, pattern, context));
}
function queryWhere(store, patterns, contexts = [
    {}
]) {
    return patterns.reduce((contexts, pattern)=>{
        return queryPattern(store, pattern, contexts);
    }, contexts);
}
// 4. query
function actualize(context, find) {
    if (Array.isArray(find)) {
        return find.map((findPart)=>actualize(context, findPart));
    }
    return isVariable(find) ? context[find] : find;
}
function query(store, { find, where }) {
    const contexts = queryWhere(store, where);
    return contexts.map((context)=>actualize(context, find));
}
// 5. Index
function relevantTriples(store, pattern, context) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTriples"])(store, actualize(context, pattern));
} //# sourceMappingURL=datalog.js.map
}),
"[project]/node_modules/uuid/dist/esm-browser/native.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const __TURBOPACK__default__export__ = {
    randomUUID
};
}),
"[project]/node_modules/uuid/dist/esm-browser/rng.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>rng
]);
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {
            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
        getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
}
}),
"[project]/node_modules/uuid/dist/esm-browser/regex.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
}),
"[project]/node_modules/uuid/dist/esm-browser/validate.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$regex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/regex.js [app-client] (ecmascript)");
;
function validate(uuid) {
    return typeof uuid === 'string' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$regex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].test(uuid);
}
const __TURBOPACK__default__export__ = validate;
}),
"[project]/node_modules/uuid/dist/esm-browser/stringify.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "unsafeStringify",
    ()=>unsafeStringify
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/validate.js [app-client] (ecmascript)");
;
const byteToHex = [];
for(let i = 0; i < 256; ++i){
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
const __TURBOPACK__default__export__ = stringify;
}),
"[project]/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/native.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$rng$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/rng.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/stringify.js [app-client] (ecmascript)");
;
;
;
function v4(options, buf, offset) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].randomUUID && !buf && !options) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].randomUUID();
    }
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$rng$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    if (rnds.length < 16) {
        throw new Error('Random bytes length must be >= 16');
    }
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80;
    if (buf) {
        offset = offset || 0;
        if (offset < 0 || offset + 16 > buf.length) {
            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
        for(let i = 0; i < 16; ++i){
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unsafeStringify"])(rnds);
}
const __TURBOPACK__default__export__ = v4;
}),
"[project]/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript) <export default as v4>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "v4",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/id.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "uuidCompare",
    ()=>uuidCompare
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript) <export default as v4>");
;
function uuidToByteArray(uuid) {
    const hex = uuid.replace(/-/g, '');
    const bytes = [];
    for(let i = 0; i < hex.length; i += 2){
        bytes.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return bytes;
}
function compareByteArrays(a, b) {
    for(let i = 0; i < a.length; i++){
        if (a[i] < b[i]) return -1;
        if (a[i] > b[i]) return 1;
    }
    return 0;
}
function uuidCompare(uuid_a, uuid_b) {
    return compareByteArrays(uuidToByteArray(uuid_a), uuidToByteArray(uuid_b));
}
function id() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])();
}
const __TURBOPACK__default__export__ = id;
 //# sourceMappingURL=id.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/strings.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "stringCompare",
    ()=>stringCompare
]);
function fallbackCompareStrings(a, b) {
    return a.localeCompare(b);
}
function makeCompareStringsFn() {
    let compareStrings = fallbackCompareStrings;
    if (typeof Intl === 'object' && Intl.hasOwnProperty('Collator')) {
        try {
            const collator = Intl.Collator('en-US');
            compareStrings = collator.compare;
        } catch (_e) {}
    }
    return compareStrings;
}
const stringCompare = makeCompareStringsFn(); //# sourceMappingURL=strings.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/warningToggle.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "setInstantWarningsEnabled",
    ()=>setInstantWarningsEnabled,
    "warningEnabled",
    ()=>warningEnabled
]);
let warningEnabled = true;
const setInstantWarningsEnabled = (enabled)=>{
    warningEnabled = enabled;
}; //# sourceMappingURL=warningToggle.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/instaql.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "compareOrder",
    ()=>compareOrder,
    "default",
    ()=>query
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$datalog$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/datalog.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/id.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$strings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/strings.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/store.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$warningToggle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/warningToggle.js [app-client] (ecmascript)");
;
;
;
;
;
let _seed = 0;
function wildcard(friendlyName) {
    return makeVarImpl(`_${friendlyName}`, _seed++);
}
function makeVarImpl(x, level) {
    return `?${x}-${level}`;
}
// Where
// -----------------
class AttrNotFoundError extends Error {
    constructor(message){
        super(message);
        this.name = 'AttrNotFoundError';
    }
}
function idAttr(attrsStore, ns) {
    const attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPrimaryKeyAttr"](attrsStore, ns);
    if (!attr) {
        throw new AttrNotFoundError(`Could not find id attr for ${ns}`);
    }
    return attr;
}
function defaultWhere(makeVar, attrsStore, etype, level) {
    return [
        eidWhere(makeVar, attrsStore, etype, level)
    ];
}
function eidWhere(makeVar, attrsStore, etype, level) {
    return [
        makeVar(etype, level),
        idAttr(attrsStore, etype).id,
        makeVar(etype, level),
        makeVar('time', level)
    ];
}
function replaceInAttrPat(attrPat, needle, v) {
    return attrPat.map((x)=>x === needle ? v : x);
}
function refAttrPat(makeVar, attrsStore, etype, level, label) {
    const fwdAttr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"](attrsStore, etype, label);
    const revAttr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByReverseIdentName"](attrsStore, etype, label);
    const attr = fwdAttr || revAttr;
    if (!attr) {
        throw new AttrNotFoundError(`Could not find attr for ${[
            etype,
            label
        ]}`);
    }
    if (attr['value-type'] !== 'ref') {
        throw new Error(`Attr ${attr.id} is not a ref`);
    }
    const [_f, fwdEtype] = attr['forward-identity'];
    const [_r, revEtype] = attr['reverse-identity'];
    const nextLevel = level + 1;
    const attrPat = fwdAttr ? [
        makeVar(fwdEtype, level),
        attr.id,
        makeVar(revEtype, nextLevel),
        wildcard('time')
    ] : [
        makeVar(fwdEtype, nextLevel),
        attr.id,
        makeVar(revEtype, level),
        wildcard('time')
    ];
    const nextEtype = fwdAttr ? revEtype : fwdEtype;
    const isForward = Boolean(fwdAttr);
    return [
        nextEtype,
        nextLevel,
        attrPat,
        attr,
        isForward
    ];
}
function makeLikeMatcher(caseSensitive, pattern) {
    if (typeof pattern !== 'string') {
        return function likeMatcher(_value) {
            return false;
        };
    }
    const escapedPattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regexPattern = escapedPattern.replace(/%/g, '.*').replace(/_/g, '.');
    const regex = new RegExp(`^${regexPattern}$`, caseSensitive ? undefined : 'i');
    return function likeMatcher(value) {
        if (typeof value !== 'string') {
            return false;
        }
        return regex.test(value);
    };
}
function parseValue(attr, v) {
    if (typeof v !== 'object' || v.hasOwnProperty('$in') || v.hasOwnProperty('in')) {
        return v;
    }
    const isDate = attr['checked-data-type'] === 'date';
    if (v.hasOwnProperty('$gt')) {
        return {
            $comparator: true,
            $op: isDate ? function gtDate(triple) {
                return new Date(triple[2]) > new Date(v.$gt);
            } : function gt(triple) {
                return triple[2] > v.$gt;
            }
        };
    }
    if (v.hasOwnProperty('$gte')) {
        return {
            $comparator: true,
            $op: isDate ? function gteDate(triple) {
                return new Date(triple[2]) >= new Date(v.$gte);
            } : function gte(triple) {
                return triple[2] >= v.$gte;
            }
        };
    }
    if (v.hasOwnProperty('$lt')) {
        return {
            $comparator: true,
            $op: isDate ? function ltDate(triple) {
                return new Date(triple[2]) < new Date(v.$lt);
            } : function lt(triple) {
                return triple[2] < v.$lt;
            }
        };
    }
    if (v.hasOwnProperty('$lte')) {
        return {
            $comparator: true,
            $op: isDate ? function lteDate(triple) {
                return new Date(triple[2]) <= new Date(v.$lte);
            } : function lte(triple) {
                return triple[2] <= v.$lte;
            }
        };
    }
    if (v.hasOwnProperty('$like')) {
        const matcher = makeLikeMatcher(true, v.$like);
        return {
            $comparator: true,
            $op: function like(triple) {
                return matcher(triple[2]);
            }
        };
    }
    if (v.hasOwnProperty('$ilike')) {
        const matcher = makeLikeMatcher(false, v.$ilike);
        return {
            $comparator: true,
            $op: function ilike(triple) {
                return matcher(triple[2]);
            }
        };
    }
    return v;
}
function valueAttrPat(makeVar, attrsStore, valueEtype, valueLevel, valueLabel, v) {
    const fwdAttr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"](attrsStore, valueEtype, valueLabel);
    const revAttr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByReverseIdentName"](attrsStore, valueEtype, valueLabel);
    const attr = fwdAttr || revAttr;
    if (!attr) {
        throw new AttrNotFoundError(`No attr for etype = ${valueEtype} label = ${valueLabel}`);
    }
    if (v?.hasOwnProperty('$isNull')) {
        const idAttr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"](attrsStore, valueEtype, 'id');
        if (!idAttr) {
            throw new AttrNotFoundError(`No attr for etype = ${valueEtype} label = id`);
        }
        return [
            makeVar(valueEtype, valueLevel),
            idAttr.id,
            {
                $isNull: {
                    attrId: attr.id,
                    isNull: v.$isNull,
                    reverse: !fwdAttr
                }
            },
            wildcard('time')
        ];
    }
    if (fwdAttr) {
        return [
            makeVar(valueEtype, valueLevel),
            attr.id,
            parseValue(attr, v),
            wildcard('time')
        ];
    }
    return [
        v,
        attr.id,
        makeVar(valueEtype, valueLevel),
        wildcard('time')
    ];
}
function refAttrPats(makeVar, attrsStore, etype, level, refsPath) {
    const [lastEtype, lastLevel, attrPats] = refsPath.reduce((acc, label)=>{
        const [etype, level, attrPats] = acc;
        const [nextEtype, nextLevel, attrPat] = refAttrPat(makeVar, attrsStore, etype, level, label);
        return [
            nextEtype,
            nextLevel,
            [
                ...attrPats,
                attrPat
            ]
        ];
    }, [
        etype,
        level,
        []
    ]);
    return [
        lastEtype,
        lastLevel,
        attrPats
    ];
}
function whereCondAttrPats(makeVar, attrsStore, etype, level, path, v) {
    const refsPath = path.slice(0, path.length - 1);
    const valueLabel = path[path.length - 1];
    const [lastEtype, lastLevel, refPats] = refAttrPats(makeVar, attrsStore, etype, level, refsPath);
    const valuePat = valueAttrPat(makeVar, attrsStore, lastEtype, lastLevel, valueLabel, v);
    return refPats.concat([
        valuePat
    ]);
}
function withJoin(where, join) {
    return join ? [
        join
    ].concat(where) : where;
}
function isOrClauses([k, v]) {
    return k === 'or' && Array.isArray(v);
}
function isAndClauses([k, v]) {
    return k === 'and' && Array.isArray(v);
}
// Creates a makeVar that will namespace symbols for or clauses
// to prevent conflicts, except for the base etype
function genMakeVar(baseMakeVar, joinSym, orIdx) {
    return (x, lvl)=>{
        const base = baseMakeVar(x, lvl);
        if (joinSym == base) {
            return base;
        }
        return `${base}-${orIdx}`;
    };
}
function parseWhereClauses(makeVar, clauseType /* 'or' | 'and' */ , attrsStore, etype, level, whereValue) {
    const joinSym = makeVar(etype, level);
    const patterns = whereValue.map((w, i)=>{
        const makeNamespacedVar = genMakeVar(makeVar, joinSym, i);
        return parseWhere(makeNamespacedVar, attrsStore, etype, level, w);
    });
    return {
        [clauseType]: {
            patterns,
            joinSym
        }
    };
}
// Given a path, returns a list of paths leading up to this path:
// growPath([1, 2, 3]) -> [[1], [1, 2], [1, 2, 3]]
function growPath(path) {
    const ret = [];
    for(let i = 1; i <= path.length; i++){
        ret.push(path.slice(0, i));
    }
    return ret;
}
// Returns array of pattern arrays that should be grouped in OR
// to capture any intermediate nulls
function whereCondAttrPatsForNullIsTrue(makeVar, attrsStore, etype, level, path) {
    return growPath(path).map((path)=>whereCondAttrPats(makeVar, attrsStore, etype, level, path, {
            $isNull: true
        }));
}
function parseWhere(makeVar, attrsStore, etype, level, where) {
    return Object.entries(where).flatMap(([k, v])=>{
        if (isOrClauses([
            k,
            v
        ])) {
            return parseWhereClauses(makeVar, 'or', attrsStore, etype, level, v);
        }
        if (isAndClauses([
            k,
            v
        ])) {
            return parseWhereClauses(makeVar, 'and', attrsStore, etype, level, v);
        }
        // Temporary hack until we have support for a uuid index on `id`
        if (k === '$entityIdStartsWith') {
            return [];
        }
        const path = k.split('.');
        // Normalize $ne to $not
        if (v?.hasOwnProperty('$ne')) {
            v = {
                ...v,
                $not: v.$ne
            };
            delete v.$ne;
        }
        if (v?.hasOwnProperty('$not')) {
            // `$not` won't pick up entities that are missing the attr, so we
            // add in a `$isNull` to catch those too.
            const notPats = whereCondAttrPats(makeVar, attrsStore, etype, level, path, v);
            const nilPats = whereCondAttrPatsForNullIsTrue(makeVar, attrsStore, etype, level, path);
            return [
                {
                    or: {
                        patterns: [
                            notPats,
                            ...nilPats
                        ],
                        joinSym: makeVar(etype, level)
                    }
                }
            ];
        }
        if (v?.hasOwnProperty('$isNull') && v.$isNull === true && path.length > 1) {
            // Make sure we're capturing all of the intermediate paths that might be null
            // by checking for null at each step along the path
            return [
                {
                    or: {
                        patterns: whereCondAttrPatsForNullIsTrue(makeVar, attrsStore, etype, level, path),
                        joinSym: makeVar(etype, level)
                    }
                }
            ];
        }
        return whereCondAttrPats(makeVar, attrsStore, etype, level, path, v);
    });
}
function makeWhere(attrsStore, etype, level, where) {
    const makeVar = makeVarImpl;
    if (!where) {
        return defaultWhere(makeVar, attrsStore, etype, level);
    }
    const parsedWhere = parseWhere(makeVar, attrsStore, etype, level, where);
    return parsedWhere.concat(defaultWhere(makeVar, attrsStore, etype, level));
}
// Find
// -----------------
function makeFind(makeVar, etype, level) {
    return [
        makeVar(etype, level),
        makeVar('time', level)
    ];
}
// extendObjects
// -----------------
function makeJoin(makeVar, attrsStore, etype, level, label, eid) {
    const [nextEtype, nextLevel, pat, attr, isForward] = refAttrPat(makeVar, attrsStore, etype, level, label);
    const actualized = replaceInAttrPat(pat, makeVar(etype, level), eid);
    return [
        nextEtype,
        nextLevel,
        actualized,
        attr,
        isForward
    ];
}
function extendObjects(makeVar, store, attrsStore, { etype, level, form }, objects) {
    const childQueries = Object.keys(form).filter((c)=>c !== '$');
    if (!childQueries.length) {
        return Object.values(objects);
    }
    return Object.entries(objects).map(function extendChildren([eid, parent]) {
        const childResults = childQueries.map(function getChildResult(label) {
            const isSingular = Boolean(store.cardinalityInference && attrsStore.linkIndex?.[etype]?.[label]?.isSingular);
            try {
                const [nextEtype, nextLevel, join] = makeJoin(makeVar, attrsStore, etype, level, label, eid);
                const childrenArray = queryOne(store, attrsStore, {
                    etype: nextEtype,
                    level: nextLevel,
                    form: form[label],
                    join
                });
                const childOrChildren = isSingular ? childrenArray[0] : childrenArray;
                return {
                    [label]: childOrChildren
                };
            } catch (e) {
                if (e instanceof AttrNotFoundError) {
                    return {
                        [label]: isSingular ? undefined : []
                    };
                }
                throw e;
            }
        });
        return childResults.reduce(function reduceChildren(parent, child) {
            return {
                ...parent,
                ...child
            };
        }, parent);
    });
}
// resolveObjects
// -----------------
function shouldIgnoreAttr(attrs, id) {
    const attr = attrs[id];
    return attr['value-type'] === 'ref' && attr['forward-identity'][2] !== 'id';
}
// Compares values where we already know that the two values are distinct
// and not null.
// Takes into account the data type.
function compareDisparateValues(a, b, dataType) {
    if (dataType === 'string') {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$strings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringCompare"])(a, b);
    }
    if (a > b) {
        return 1;
    }
    return -1;
}
function compareOrder(id_a, v_a, id_b, v_b, dataType) {
    if (v_a === v_b || v_a == null && v_b == null) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uuidCompare"])(id_a, id_b);
    }
    if (v_b == null) {
        return 1;
    }
    if (v_a == null) {
        return -1;
    }
    return compareDisparateValues(v_a, v_b, dataType);
}
function compareOrderTriples([id_a, v_a], [id_b, v_b], dataType) {
    return compareOrder(id_a, v_a, id_b, v_b, dataType);
}
function comparableDate(x) {
    if (x == null) {
        return x;
    }
    return new Date(x).getTime();
}
function isBefore(startCursor, orderAttr, direction, idVec) {
    const [c_e, _c_a, c_v, c_t] = startCursor;
    const compareVal = direction === 'desc' ? 1 : -1;
    if (orderAttr['forward-identity']?.[2] === 'id') {
        return compareOrderTriples(idVec, [
            c_e,
            c_t
        ], null) === compareVal;
    }
    const [e, v] = idVec;
    const dataType = orderAttr['checked-data-type'];
    const v_new = dataType === 'date' ? comparableDate(v) : v;
    const c_v_new = dataType === 'date' ? comparableDate(c_v) : c_v;
    return compareOrderTriples([
        e,
        v_new
    ], [
        c_e,
        c_v_new
    ], dataType) === compareVal;
}
function orderAttrFromCursor(attrsStore, cursor) {
    const cursorAttrId = cursor[1];
    return attrsStore.getAttr(cursorAttrId);
}
function orderAttrFromOrder(attrsStore, etype, order) {
    const label = Object.keys(order)[0];
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"](attrsStore, etype, label);
}
function getOrderAttr(attrsStore, etype, cursor, order) {
    if (cursor) {
        return orderAttrFromCursor(attrsStore, cursor);
    }
    if (order) {
        return orderAttrFromOrder(attrsStore, etype, order);
    }
}
function objectAttrs(attrsStore, etype, dq) {
    if (!Array.isArray(dq.fields)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlobAttrs"](attrsStore, etype);
    }
    const attrs = new Map();
    for (const field of dq.fields){
        const attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"](attrsStore, etype, field);
        const label = attr?.['forward-identity']?.[2];
        if (label && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isBlob"](attr)) {
            attrs.set(label, attr);
        }
    }
    // Ensure we add the id field to avoid empty objects
    if (!attrs.has('id')) {
        const attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"](attrsStore, etype, 'id');
        const label = attr?.['forward-identity']?.[2];
        if (label) {
            attrs.set(label, attr);
        }
    }
    return attrs;
}
function runDataloadAndReturnObjects(store, attrsStore, { etype, pageInfo, dq, form }) {
    const order = form?.$?.order;
    const isLeadingQuery = isLeading(form);
    const direction = determineDirection(form);
    let idVecs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$datalog$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["query"])(store, dq);
    const startCursor = pageInfo?.['start-cursor'];
    const orderAttr = getOrderAttr(attrsStore, etype, startCursor, order);
    if (orderAttr && orderAttr?.['forward-identity']?.[2] !== 'id') {
        const isDate = orderAttr['checked-data-type'] === 'date';
        const a = orderAttr.id;
        idVecs = idVecs.map(([id])=>{
            // order attr is required to be cardinality one, so there will
            // be at most one value here
            let v = store.eav.get(id)?.get(a)?.values()?.next()?.value?.[2];
            if (isDate) {
                v = comparableDate(v);
            }
            return [
                id,
                v
            ];
        });
    }
    idVecs.sort(direction === 'asc' ? function compareIdVecs(a, b) {
        return compareOrderTriples(a, b, orderAttr?.['checked-data-type']);
    } : function compareIdVecs(a, b) {
        return compareOrderTriples(b, a, orderAttr?.['checked-data-type']);
    });
    let objects = {};
    const attrs = objectAttrs(attrsStore, etype, dq);
    for (const idVec of idVecs){
        const [id] = idVec;
        if (objects[id]) {
            continue;
        }
        if (!isLeadingQuery && startCursor && orderAttr && isBefore(startCursor, orderAttr, direction, idVec)) {
            continue;
        }
        const obj = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAsObject"](store, attrs, id);
        if (obj) {
            objects[id] = obj;
        }
    }
    return objects;
}
function determineDirection(form) {
    const orderOpts = form.$?.order;
    if (!orderOpts) {
        return 'asc';
    }
    return orderOpts[Object.keys(orderOpts)[0]] || 'asc';
}
/**
 * A "leading" query has no `offset`, `before`, or `after`
 *
 * It is at the 'beginning' of the order
 */ function isLeading(form) {
    const offset = form.$?.offset;
    const before = form.$?.before;
    const after = form.$?.after;
    return !offset && !before && !after;
}
/**
 * Given a query like:
 *
 * {
 *   users: {
 *     $: { where: { name: "Joe" } },
 *   },
 * };
 *
 * `resolveObjects`, turns where clause: `{ name: "Joe" }`
 * into a datalog query. We then run the datalog query,
 * and reduce all the triples into objects.
 */ function resolveObjects(store, attrsStore, { etype, level, form, join, pageInfo }) {
    // Wait for server to tell us where we start if we don't start from the beginning
    if (!isLeading(form) && (!pageInfo || !pageInfo['start-cursor'])) {
        return [];
    }
    const where = withJoin(makeWhere(attrsStore, etype, level, form.$?.where), join);
    const find = makeFind(makeVarImpl, etype, level);
    const fields = form.$?.fields;
    const objs = runDataloadAndReturnObjects(store, attrsStore, {
        etype,
        pageInfo,
        form,
        dq: {
            where,
            find,
            fields
        }
    });
    const limit = form.$?.limit || form.$?.first || form.$?.last;
    if (limit != null) {
        if (level > 0 && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$warningToggle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warningEnabled"]) {
            console.warn('WARNING: Limits in child queries are only run client-side. Data returned from the server will not have a limit.');
        }
        const entries = Object.entries(objs);
        if (entries.length <= limit) {
            return objs;
        }
        return Object.fromEntries(entries.slice(0, limit));
    }
    return objs;
}
/**
 * It's possible that we query
 * for an attribute that doesn't exist yet.
 *
 * { users: { $: { where: { nonExistentProperty: "foo" } } } }
 *
 * This swallows the missing attr error and returns
 * an empty result instead
 */ function guardedResolveObjects(store, attrsStore, opts) {
    try {
        return resolveObjects(store, attrsStore, opts);
    } catch (e) {
        if (e instanceof AttrNotFoundError) {
            return {};
        }
        throw e;
    }
}
/**
 * Given a query like:
 *
 * {
 *   users: {
 *     $: { where: { name: "Joe" } },
 *     posts: {},
 *   },
 * };
 *
 * `guardResolveObjects` will return the relevant `users` objects
 * `extendObjects` will then extend each `user` object with relevant `posts`.
 */ function queryOne(store, attrsStore, opts) {
    const objects = guardedResolveObjects(store, attrsStore, opts);
    return extendObjects(makeVarImpl, store, attrsStore, opts, objects);
}
function formatPageInfo(pageInfo) {
    const res = {};
    for (const [k, v] of Object.entries(pageInfo)){
        res[k] = {
            startCursor: v['start-cursor'],
            endCursor: v['end-cursor'],
            hasNextPage: v['has-next-page?'],
            hasPreviousPage: v['has-previous-page?']
        };
    }
    return res;
}
function query({ store, attrsStore, pageInfo, aggregate }, q) {
    const data = Object.keys(q).reduce(function reduceResult(res, k) {
        if (aggregate?.[k] || '$$ruleParams' === k) {
            // Aggregate doesn't return any join rows and has no children,
            // so don't bother querying further
            return res;
        }
        res[k] = queryOne(store, attrsStore, {
            etype: k,
            form: q[k],
            level: 0,
            pageInfo: pageInfo?.[k]
        });
        return res;
    }, {});
    const result = {
        data
    };
    if (pageInfo) {
        result.pageInfo = formatPageInfo(pageInfo);
    }
    if (aggregate) {
        result.aggregate = aggregate;
    }
    return result;
} //# sourceMappingURL=instaql.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/instatx.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getOps",
    ()=>getOps,
    "isLookup",
    ()=>isLookup,
    "lookup",
    ()=>lookup,
    "parseLookup",
    ()=>parseLookup,
    "tx",
    ()=>tx,
    "txInit",
    ()=>txInit
]);
function getAllTransactionChunkKeys() {
    const v = 1;
    const _dummy = {
        __etype: v,
        __ops: v,
        create: v,
        update: v,
        link: v,
        unlink: v,
        delete: v,
        merge: v,
        ruleParams: v
    };
    return new Set(Object.keys(_dummy));
}
const allTransactionChunkKeys = getAllTransactionChunkKeys();
function transactionChunk(etype, id, prevOps) {
    const target = {
        __etype: etype,
        __ops: prevOps
    };
    return new Proxy(target, {
        get: (_target, cmd)=>{
            if (cmd === '__ops') return prevOps;
            if (cmd === '__etype') return etype;
            if (!allTransactionChunkKeys.has(cmd)) {
                return undefined;
            }
            return (args, opts)=>{
                return transactionChunk(etype, id, [
                    ...prevOps,
                    opts ? [
                        cmd,
                        etype,
                        id,
                        args,
                        opts
                    ] : [
                        cmd,
                        etype,
                        id,
                        args
                    ]
                ]);
            };
        }
    });
}
function lookup(attribute, value) {
    return `lookup__${attribute}__${JSON.stringify(value)}`;
}
function isLookup(k) {
    return k.startsWith('lookup__');
}
function parseLookup(k) {
    const [_, attribute, ...vJSON] = k.split('__');
    return [
        attribute,
        JSON.parse(vJSON.join('__'))
    ];
}
function etypeChunk(etype) {
    return new Proxy({
        __etype: etype
    }, {
        get (_target, cmd) {
            if (cmd === 'lookup') {
                return (attrName, value)=>transactionChunk(etype, parseLookup(lookup(attrName, value)), []);
            }
            if (cmd === '__etype') return etype;
            const id = cmd;
            if (isLookup(id)) {
                return transactionChunk(etype, parseLookup(id), []);
            }
            return transactionChunk(etype, id, []);
        }
    });
}
function txInit() {
    return new Proxy({}, {
        get (_target, ns) {
            return etypeChunk(ns);
        }
    });
}
const tx = txInit();
function getOps(x) {
    return x.__ops;
} //# sourceMappingURL=instatx.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/instaml.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "rewriteStep",
    ()=>rewriteStep,
    "transform",
    ()=>transform
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/store.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/instatx.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$dates$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/dates.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/id.js [app-client] (ecmascript)");
;
;
;
;
;
function rewriteStep(attrMapping, txStep) {
    const { attrIdMap, refSwapAttrIds } = attrMapping;
    const rewritten = [];
    for (const part of txStep){
        const newValue = attrIdMap[part];
        if (newValue) {
            // Rewrites attr id
            rewritten.push(newValue);
        } else if (Array.isArray(part) && part.length == 2 && attrIdMap[part[0]]) {
            // Rewrites attr id in lookups
            const [aid, value] = part;
            rewritten.push([
                attrIdMap[aid],
                value
            ]);
        } else {
            rewritten.push(part);
        }
    }
    const [action] = txStep;
    if ((action === 'add-triple' || action === 'retract-triple') && refSwapAttrIds.has(txStep[2])) {
        // Reverse links if the optimistic link attr is backwards
        const tmp = rewritten[1];
        rewritten[1] = rewritten[3];
        rewritten[3] = tmp;
    }
    return rewritten;
}
function explodeLookupRef(eid) {
    if (Array.isArray(eid)) {
        return eid;
    }
    const entries = Object.entries(eid);
    if (entries.length !== 1) {
        throw new Error('lookup must be an object with a single unique attr and value.');
    }
    return entries[0];
}
function isRefLookupIdent(attrs, etype, identName) {
    return identName.indexOf('.') !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
    // before assuming it's a ref lookup.
    !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"])(attrs, etype, identName);
}
function extractRefLookupFwdName(identName) {
    const [fwdName, idIdent, ...rest] = identName.split('.');
    if (rest.length > 0 || idIdent !== 'id') {
        throw new Error(`${identName} is not a valid lookup attribute.`);
    }
    return fwdName;
}
function lookupIdentToAttr(attrs, etype, identName) {
    if (!isRefLookupIdent(attrs, etype, identName)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"])(attrs, etype, identName);
    }
    const fwdName = extractRefLookupFwdName(identName);
    const refAttr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"])(attrs, etype, fwdName) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByReverseIdentName"])(attrs, etype, fwdName);
    if (refAttr && refAttr['value-type'] !== 'ref') {
        throw new Error(`${identName} does not reference a valid link attribute.`);
    }
    return refAttr;
}
// Returns [attr, value] for the eid if the eid is a lookup.
// If it's a regular eid, returns null
function lookupPairOfEid(eid) {
    if (typeof eid === 'string' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLookup"])(eid)) {
        return null;
    }
    return typeof eid === 'string' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLookup"])(eid) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseLookup"])(eid) : explodeLookupRef(eid);
}
function extractLookup(attrs, etype, eid) {
    const lookupPair = lookupPairOfEid(eid);
    if (lookupPair === null) {
        return eid;
    }
    const [identName, value] = lookupPair;
    const attr = lookupIdentToAttr(attrs, etype, identName);
    if (!attr || !attr['unique?']) {
        throw new Error(`${identName} is not a unique attribute.`);
    }
    return [
        attr.id,
        value
    ];
}
function withIdAttrForLookup(attrs, etype, eidA, txSteps) {
    const lookup = extractLookup(attrs, etype, eidA);
    if (!Array.isArray(lookup)) {
        return txSteps;
    }
    const idTuple = [
        'add-triple',
        lookup,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"])(attrs, etype, 'id')?.id,
        lookup
    ];
    return [
        idTuple
    ].concat(txSteps);
}
function expandLink({ attrsStore }, [etype, eidA, obj]) {
    const addTriples = Object.entries(obj).flatMap(([label, eidOrEids])=>{
        const eids = Array.isArray(eidOrEids) ? eidOrEids : [
            eidOrEids
        ];
        const fwdAttr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"])(attrsStore, etype, label);
        const revAttr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByReverseIdentName"])(attrsStore, etype, label);
        return eids.map((eidB)=>{
            const txStep = fwdAttr ? [
                'add-triple',
                extractLookup(attrsStore, etype, eidA),
                fwdAttr.id,
                // Uses `!` because if we get here, we should have created the attr if it doesn't
                // already exist
                extractLookup(attrsStore, fwdAttr['reverse-identity'][1], eidB)
            ] : [
                'add-triple',
                // Uses `!` because if we get here, we should have created the attr if it doesn't
                // already exist
                extractLookup(attrsStore, revAttr['forward-identity'][1], eidB),
                revAttr?.id,
                extractLookup(attrsStore, etype, eidA)
            ];
            return txStep;
        });
    });
    return withIdAttrForLookup(attrsStore, etype, eidA, addTriples);
}
function expandUnlink({ attrsStore }, [etype, eidA, obj]) {
    const retractTriples = Object.entries(obj).flatMap(([label, eidOrEids])=>{
        const eids = Array.isArray(eidOrEids) ? eidOrEids : [
            eidOrEids
        ];
        const fwdAttr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"])(attrsStore, etype, label);
        const revAttr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByReverseIdentName"])(attrsStore, etype, label);
        return eids.map((eidB)=>{
            const txStep = fwdAttr ? [
                'retract-triple',
                extractLookup(attrsStore, etype, eidA),
                fwdAttr.id,
                // Uses `!` because if we get here, we should have created the attr if it doesn't
                // already exist
                extractLookup(attrsStore, fwdAttr['reverse-identity'][1], eidB)
            ] : [
                'retract-triple',
                // Uses `!` because if we get here, we should have created the attr if it doesn't
                // already exist
                extractLookup(attrsStore, revAttr['forward-identity'][1], eidB),
                revAttr.id,
                extractLookup(attrsStore, etype, eidA)
            ];
            return txStep;
        });
    });
    return withIdAttrForLookup(attrsStore, etype, eidA, retractTriples);
}
function checkEntityExists(stores, attrsStore, etype, eid) {
    if (Array.isArray(eid)) {
        // lookup ref
        const [entity_a, entity_v] = eid;
        for (const store of stores || []){
            const ev = store?.aev.get(entity_a);
            if (ev) {
                // This would be a lot more efficient with a ave index
                for (const [_e, _a, v] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allMapValues"])(ev, 2)){
                    if (v === entity_v) {
                        return true;
                    }
                }
            }
        }
    } else {
        // eid
        for (const store of stores || []){
            const av = store?.eav.get(eid);
            if (av) {
                for (const attr_id of av.keys()){
                    if (attrsStore.getAttr(attr_id)?.['forward-identity'][1] == etype) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
function convertOpts({ stores, attrsStore }, [etype, eid, obj_, opts]) {
    return opts?.upsert === false ? {
        mode: 'update'
    } : opts?.upsert === true ? null : checkEntityExists(stores, attrsStore, etype, eid) ? {
        mode: 'update'
    } : null; // auto mode chooses between update and upsert, not update and create, just in case
}
function expandCreate(ctx, step) {
    const { attrsStore } = ctx;
    const [etype, eid, obj_, opts] = step;
    const obj = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["immutableRemoveUndefined"])(obj_);
    const lookup = extractLookup(attrsStore, etype, eid);
    // id first so that we don't clobber updates on the lookup field
    const attrTuples = [
        [
            'id',
            lookup
        ]
    ].concat(Object.entries(obj)).map(([identName, value])=>{
        // Uses `!` because we should have optimistically created the attr if it doesn't exist
        const attr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"])(attrsStore, etype, identName);
        if (attr['checked-data-type'] === 'date' && ctx.useDateObjects) {
            value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$dates$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerceToDate"])(value);
        }
        return [
            'add-triple',
            lookup,
            attr.id,
            value,
            {
                mode: 'create'
            }
        ];
    });
    return attrTuples;
}
function expandUpdate(ctx, step) {
    const { attrsStore } = ctx;
    const [etype, eid, obj_, opts] = step;
    const obj = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["immutableRemoveUndefined"])(obj_);
    const lookup = extractLookup(attrsStore, etype, eid);
    const serverOpts = convertOpts(ctx, [
        etype,
        lookup,
        obj_,
        opts
    ]);
    // id first so that we don't clobber updates on the lookup field
    const attrTuples = [
        [
            'id',
            lookup
        ]
    ].concat(Object.entries(obj)).map(([identName, value])=>{
        const attr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"])(attrsStore, etype, identName);
        if (attr['checked-data-type'] === 'date' && ctx.useDateObjects) {
            value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$dates$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerceToDate"])(value);
        }
        return [
            'add-triple',
            lookup,
            attr.id,
            value,
            ...serverOpts ? [
                serverOpts
            ] : []
        ];
    });
    return attrTuples;
}
function expandDelete({ attrsStore }, [etype, eid]) {
    const lookup = extractLookup(attrsStore, etype, eid);
    return [
        [
            'delete-entity',
            lookup,
            etype
        ]
    ];
}
function expandDeepMerge(ctx, step) {
    const { attrsStore } = ctx;
    const [etype, eid, obj_, opts] = step;
    const obj = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["immutableRemoveUndefined"])(obj_);
    const lookup = extractLookup(attrsStore, etype, eid);
    const serverOpts = convertOpts(ctx, [
        etype,
        lookup,
        obj_,
        opts
    ]);
    const attrTuples = Object.entries(obj).map(([identName, value])=>{
        const attr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"])(attrsStore, etype, identName);
        return [
            'deep-merge-triple',
            lookup,
            attr.id,
            value,
            ...serverOpts ? [
                serverOpts
            ] : []
        ];
    });
    const idTuple = [
        'add-triple',
        lookup,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"])(attrsStore, etype, 'id').id,
        lookup,
        ...serverOpts ? [
            serverOpts
        ] : []
    ];
    // id first so that we don't clobber updates on the lookup field
    return [
        idTuple
    ].concat(attrTuples);
}
function expandRuleParams({ attrsStore }, [etype, eid, ruleParams]) {
    const lookup = extractLookup(attrsStore, etype, eid);
    return [
        [
            'rule-params',
            lookup,
            etype,
            ruleParams
        ]
    ];
}
function removeIdFromArgs(step) {
    const [op, etype, eid, obj, opts] = step;
    if (!obj) {
        return step;
    }
    const newObj = {
        ...obj
    };
    delete newObj.id;
    return [
        op,
        etype,
        eid,
        newObj,
        ...opts ? [
            opts
        ] : []
    ];
}
function toTxSteps(ctx, step) {
    const [action, ...args] = removeIdFromArgs(step);
    switch(action){
        case 'merge':
            return expandDeepMerge(ctx, args);
        case 'create':
            return expandCreate(ctx, args);
        case 'update':
            return expandUpdate(ctx, args);
        case 'link':
            return expandLink(ctx, args);
        case 'unlink':
            return expandUnlink(ctx, args);
        case 'delete':
            return expandDelete(ctx, args);
        case 'ruleParams':
            return expandRuleParams(ctx, args);
        default:
            throw new Error(`unsupported action ${action}`);
    }
}
// ---------
// transform
function checkedDataTypeOfValueType(valueType) {
    switch(valueType){
        case 'string':
        case 'date':
        case 'boolean':
        case 'number':
            return valueType;
        default:
            return undefined;
    }
}
function objectPropsFromSchema(schema, etype, label) {
    const attr = schema.entities[etype]?.attrs?.[label];
    if (label === 'id') return null;
    if (!attr) {
        throw new Error(`${etype}.${label} does not exist in your schema`);
    }
    const { unique, indexed } = attr?.config;
    const checkedDataType = checkedDataTypeOfValueType(attr?.valueType);
    return {
        'index?': indexed,
        'unique?': unique,
        'checked-data-type': checkedDataType
    };
}
function createObjectAttr(schema, etype, label, props) {
    const schemaObjectProps = schema ? objectPropsFromSchema(schema, etype, label) : null;
    const attrId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    const fwdIdentId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    const fwdIdent = [
        fwdIdentId,
        etype,
        label
    ];
    return {
        id: attrId,
        'forward-identity': fwdIdent,
        'value-type': 'blob',
        cardinality: 'one',
        'unique?': false,
        'index?': false,
        isUnsynced: true,
        ...schemaObjectProps || {},
        ...props || {}
    };
}
function findSchemaLink(schema, etype, label) {
    const links = Object.values(schema.links);
    const found = links.find((x)=>{
        return x.forward.on === etype && x.forward.label === label || x.reverse.on === etype && x.reverse.label === label;
    });
    return found;
}
function refPropsFromSchema(schema, etype, label) {
    const found = findSchemaLink(schema, etype, label);
    if (!found) {
        throw new Error(`Couldn't find the link ${etype}.${label} in your schema`);
    }
    const { forward, reverse } = found;
    return {
        'forward-identity': [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(),
            forward.on,
            forward.label
        ],
        'reverse-identity': [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(),
            reverse.on,
            reverse.label
        ],
        cardinality: forward.has === 'one' ? 'one' : 'many',
        'unique?': reverse.has === 'one',
        'on-delete': forward.onDelete,
        'on-delete-reverse': reverse.onDelete
    };
}
function createRefAttr(schema, etype, label, props) {
    const schemaRefProps = schema ? refPropsFromSchema(schema, etype, label) : null;
    const attrId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    const fwdIdent = [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(),
        etype,
        label
    ];
    const revIdent = [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(),
        label,
        etype
    ];
    return {
        id: attrId,
        // @ts-ignore: ts thinks it's any[]
        'forward-identity': fwdIdent,
        // @ts-ignore: ts thinks it's any[]
        'reverse-identity': revIdent,
        'value-type': 'ref',
        // @ts-ignore: ts thinks it's type string
        cardinality: 'many',
        'unique?': false,
        'index?': false,
        isUnsynced: true,
        ...schemaRefProps || {},
        ...props || {}
    };
}
// Actions that have an object, e.g. not delete
const OBJ_ACTIONS = new Set([
    'create',
    'update',
    'merge',
    'link',
    'unlink'
]);
const REF_ACTIONS = new Set([
    'link',
    'unlink'
]);
const UPDATE_ACTIONS = new Set([
    'create',
    'update',
    'merge'
]);
const SUPPORTS_LOOKUP_ACTIONS = new Set([
    'link',
    'unlink',
    'create',
    'update',
    'merge',
    'delete',
    'ruleParams'
]);
const lookupProps = {
    'unique?': true,
    'index?': true
};
const refLookupProps = {
    ...lookupProps,
    cardinality: 'one'
};
function lookupPairsOfOp(op) {
    const res = [];
    const [action, etype, eid, obj] = op;
    if (!SUPPORTS_LOOKUP_ACTIONS.has(action)) {
        return res;
    }
    const eidLookupPair = lookupPairOfEid(eid);
    if (eidLookupPair) {
        res.push({
            etype: etype,
            lookupPair: eidLookupPair
        });
    }
    if (action === 'link') {
        for (const [label, eidOrEids] of Object.entries(obj)){
            const eids = Array.isArray(eidOrEids) ? eidOrEids : [
                eidOrEids
            ];
            for (const linkEid of eids){
                const linkEidLookupPair = lookupPairOfEid(linkEid);
                if (linkEidLookupPair) {
                    res.push({
                        etype: etype,
                        lookupPair: linkEidLookupPair,
                        linkLabel: label
                    });
                }
            }
        }
    }
    return res;
}
function createMissingAttrs({ attrsStore, schema }, ops) {
    const addedIds = new Set();
    const localAttrs = [];
    const addOps = [];
    function attrByFwdIdent(etype, label) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"])(attrsStore, etype, label) || localAttrs.find((x)=>x['forward-identity'][1] === etype && x['forward-identity'][2] === label);
    }
    function attrByRevIdent(etype, label) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByReverseIdentName"])(attrsStore, etype, label) || localAttrs.find((x)=>x['reverse-identity']?.[1] === etype && x['reverse-identity']?.[2] === label);
    }
    function addAttr(attr) {
        localAttrs.push(attr);
        addOps.push([
            'add-attr',
            attr
        ]);
        addedIds.add(attr.id);
    }
    function addUnsynced(attr) {
        if (attr && 'isUnsynced' in attr && attr.isUnsynced && !addedIds.has(attr.id)) {
            localAttrs.push(attr);
            addOps.push([
                'add-attr',
                attr
            ]);
            addedIds.add(attr.id);
        }
    }
    function isRefLookupIdentLocal(etype, identName) {
        return identName.indexOf('.') !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
        // before assuming it's a ref lookup.
        !attrByFwdIdent(etype, identName);
    }
    // Adds attrs needed for a ref lookup
    function addForRef(etype, label) {
        const fwdAttr = attrByFwdIdent(etype, label);
        const revAttr = attrByRevIdent(etype, label);
        addUnsynced(fwdAttr);
        addUnsynced(revAttr);
        if (!fwdAttr && !revAttr) {
            addAttr(createRefAttr(schema, etype, label, refLookupProps));
        }
    }
    // Create attrs for lookups if we need to
    // Do these first because otherwise we might add a non-unique attr
    // before we get to it
    for (const op of ops){
        for (const { etype, lookupPair, linkLabel } of lookupPairsOfOp(op)){
            const identName = lookupPair[0];
            // We got a link eid that's a lookup, linkLabel is the label of the ident,
            // e.g. `posts` in `link({posts: postIds})`
            if (linkLabel) {
                // Add our ref attr, e.g. users.posts
                addForRef(etype, linkLabel);
                // Figure out the link etype so we can make sure we have the attrs
                // for the link lookup
                const fwdAttr = attrByFwdIdent(etype, linkLabel);
                const revAttr = attrByRevIdent(etype, linkLabel);
                addUnsynced(fwdAttr);
                addUnsynced(revAttr);
                const linkEtype = fwdAttr?.['reverse-identity']?.[1] || revAttr?.['forward-identity']?.[1] || linkLabel;
                if (isRefLookupIdentLocal(linkEtype, identName)) {
                    addForRef(linkEtype, extractRefLookupFwdName(identName));
                } else {
                    const attr = attrByFwdIdent(linkEtype, identName);
                    if (!attr) {
                        addAttr(createObjectAttr(schema, linkEtype, identName, lookupProps));
                    }
                    addUnsynced(attr);
                }
            } else if (isRefLookupIdentLocal(etype, identName)) {
                addForRef(etype, extractRefLookupFwdName(identName));
            } else {
                const attr = attrByFwdIdent(etype, identName);
                if (!attr) {
                    addAttr(createObjectAttr(schema, etype, identName, lookupProps));
                }
                addUnsynced(attr);
            }
        }
    }
    // Create object and ref attrs
    for (const op of ops){
        const [action, etype, eid, obj] = op;
        if (OBJ_ACTIONS.has(action)) {
            const idAttr = attrByFwdIdent(etype, 'id');
            addUnsynced(idAttr);
            if (!idAttr) {
                addAttr(createObjectAttr(schema, etype, 'id', {
                    'unique?': true
                }));
            }
            for (const label of Object.keys(obj)){
                const fwdAttr = attrByFwdIdent(etype, label);
                addUnsynced(fwdAttr);
                if (UPDATE_ACTIONS.has(action)) {
                    if (!fwdAttr) {
                        addAttr(createObjectAttr(schema, etype, label, label === 'id' ? {
                            'unique?': true
                        } : null));
                    }
                }
                if (REF_ACTIONS.has(action)) {
                    const revAttr = attrByRevIdent(etype, label);
                    if (!fwdAttr && !revAttr) {
                        addAttr(createRefAttr(schema, etype, label));
                    }
                    addUnsynced(revAttr);
                }
            }
        }
    }
    if (localAttrs.length) {
        const nextAttrs = {
            ...attrsStore.attrs
        };
        for (const attr of localAttrs){
            nextAttrs[attr.id] = attr;
        }
        return [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AttrsStoreClass"](nextAttrs, attrsStore.linkIndex),
            addOps
        ];
    }
    return [
        attrsStore,
        addOps
    ];
}
function transform(ctx, inputChunks) {
    const chunks = Array.isArray(inputChunks) ? inputChunks : [
        inputChunks
    ];
    const ops = chunks.flatMap((tx)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getOps"])(tx));
    const [newAttrs, addAttrTxSteps] = createMissingAttrs(ctx, ops);
    const newCtx = {
        ...ctx,
        attrsStore: newAttrs
    };
    const txSteps = ops.flatMap((op)=>toTxSteps(newCtx, op));
    return [
        ...addAttrTxSteps,
        ...txSteps
    ];
} //# sourceMappingURL=instaml.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/PersistedObject.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "META_KEY",
    ()=>META_KEY,
    "PersistedObject",
    ()=>PersistedObject,
    "StoreInterface",
    ()=>StoreInterface
]);
// PersistedObjects save data outside of memory.
//
// When we load a persisted object, it's possible we call `set`
// before we finish loading. To address we handle set in two ways:
//
// 1. Before load
// We simply update currentValue in memory
//
// 2. After load
// We update currentValue in memory and in storage
//
// Each PersistedObject provides it's own `onMerge`
// function to handle the merge of data from storage and memory
// on load
// Uses `requestIdleCallback` if available, otherwise calls the
// callback immediately
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mutative/dist/mutative.esm.mjs [app-client] (ecmascript)");
;
function safeIdleCallback(cb, timeout) {
    if (typeof requestIdleCallback === 'undefined') {
        cb();
    } else {
        requestIdleCallback(cb, {
            timeout
        });
    }
}
const META_KEY = '__meta';
class StoreInterface {
    constructor(appId, storeName){}
}
class PersistedObject {
    currentValue;
    _subs = [];
    _persister;
    _merge;
    serialize;
    parse;
    _saveThrottleMs;
    _idleCallbackMaxWaitMs;
    _nextSave = null;
    _nextGc = null;
    _pendingSaveKeys = new Set();
    _loadedKeys = new Set();
    _loadingKeys;
    _objectSize;
    _log;
    onKeyLoaded;
    _version = 0;
    _meta = {
        isLoading: true,
        onLoadCbs: [],
        value: null,
        error: null,
        attempts: 0
    };
    _gcOpts;
    constructor(opts){
        this._persister = opts.persister;
        this._merge = opts.merge;
        this.serialize = opts.serialize;
        this.parse = opts.parse;
        this._objectSize = opts.objectSize;
        this._log = opts.logger;
        this._saveThrottleMs = opts.saveThrottleMs ?? 100;
        this._idleCallbackMaxWaitMs = opts.idleCallbackMaxWaitMs ?? 1000;
        this._gcOpts = opts.gc;
        this.currentValue = {};
        this._loadedKeys = new Set();
        this._loadingKeys = {};
        this._initMeta();
        if (opts.preloadEntryCount) {
            this._preloadEntries(opts.preloadEntryCount);
        }
    }
    async _initMeta() {
        if (this._meta.loadingPromise) {
            await this._meta.loadingPromise;
        }
        try {
            const p = this._persister.getItem(META_KEY);
            this._meta.loadingPromise = p;
            const v = await p;
            this._meta.isLoading = false;
            this._meta.error = null;
            this._meta.loadingPromise = null;
            this._meta.attempts = 0;
            const existingObjects = this._meta.value?.objects ?? {};
            const value = v ?? {};
            const objects = value.objects ?? {};
            // Merge the values from storage with in-memory values
            this._meta.value = {
                ...value,
                objects: {
                    ...existingObjects,
                    ...objects
                }
            };
        } catch (e) {
            this._meta.error = e;
            this._meta.attempts++;
            this._meta.loadingPromise = null;
        }
    }
    async _getMeta() {
        if (this._meta.value) {
            return this._meta.value;
        }
        if (this._meta.loadingPromise) {
            await this._meta.loadingPromise;
            return this._meta.value;
        }
        this._initMeta();
        await this._meta.loadingPromise;
        return this._meta.value;
    }
    async _refreshMeta() {
        await this._initMeta();
        return this._meta.value;
    }
    async _preloadEntries(n) {
        const meta = await this.waitForMetaToLoad();
        if (!meta) return;
        const entries = Object.entries(meta.objects);
        entries.sort(([_k_a, a_meta], [_k_b, b_meta])=>{
            return b_meta.updatedAt - a_meta.updatedAt;
        });
        for (const [k] of entries.slice(0, n)){
            this._loadKey(k);
        }
    }
    async _getFromStorage(key) {
        try {
            const data = await this._persister.getItem(key);
            if (!data) {
                return data;
            }
            const parsed = this.parse(key, data);
            return parsed;
        } catch (e) {
            console.error(`Unable to read from storage for key=${key}`, e);
            return null;
        }
    }
    async waitForKeyToLoad(k) {
        if (this._loadedKeys.has(k)) {
            return this.currentValue[k];
        }
        await (this._loadingKeys[k] || this._loadKey(k));
        return this.currentValue[k];
    }
    // Used for tests
    async waitForMetaToLoad() {
        return this._getMeta();
    }
    // Unloads the key so that it can be garbage collected, but does not
    // delete it. Removes the key from currentValue.
    unloadKey(k) {
        this._loadedKeys.delete(k);
        delete this._loadingKeys[k];
        delete this.currentValue[k];
    }
    async _loadKey(k) {
        if (this._loadedKeys.has(k) || k in this._loadingKeys) return;
        const p = this._getFromStorage(k);
        this._loadingKeys[k] = p;
        const value = await p;
        delete this._loadingKeys[k];
        this._loadedKeys.add(k);
        if (value) {
            const merged = this._merge(k, value, this.currentValue[k]);
            if (merged) {
                this.currentValue[k] = merged;
            }
        }
        this.onKeyLoaded && this.onKeyLoaded(k);
    }
    // Returns a promise with a number so that we can wait for flush
    // to finish in the tests. The number is the number of operations
    // it performed, but it's mostly there so that typescript will warn
    // us if we forget to retun the promise from the function.
    _writeToStorage(opts) {
        const promises = [];
        const skipGc = opts?.skipGc;
        if (this._meta.isLoading) {
            // Wait for meta to load and try again, give it a delay so that
            // we don't spend too much time retrying
            const p = new Promise((resolve, reject)=>{
                setTimeout(()=>this._enqueuePersist(opts ? {
                        ...opts,
                        attempts: (opts.attempts || 0) + 1
                    } : {
                        attempts: 1
                    }).then(resolve).catch(reject), 10 + (opts?.attempts ?? 0) * 1000);
            });
            promises.push(p);
            return Promise.all(promises).then((vs)=>vs.reduce((acc, x)=>acc + x, 0));
        }
        const metaValue = this._meta.value;
        if (!metaValue) {
            // If it's not loading and we don't have the data, then there
            // must be an error and we're not going to be able to save until
            // the error is resolved elsewhere.
            return Promise.resolve(0);
        }
        const keysToDelete = [];
        const keysToUpdate = [];
        for (const k of this._pendingSaveKeys){
            if (!(k in this.currentValue)) {
                keysToDelete.push(k);
                delete metaValue.objects[k];
            } else {
                keysToUpdate.push(k);
            }
        }
        for (const k of keysToDelete){
            const p = this._persister.removeItem(k);
            promises.push(p.then(()=>1));
            this._loadedKeys.delete(k);
            this._pendingSaveKeys.delete(k);
        }
        const keysToLoad = [];
        const kvPairs = [
            [
                META_KEY,
                metaValue
            ]
        ];
        const metaObjects = metaValue.objects ?? {};
        metaValue.objects = metaObjects;
        for (const k of keysToUpdate){
            if (this._loadedKeys.has(k)) {
                const serializedV = this.serialize(k, this.currentValue[k]);
                kvPairs.push([
                    k,
                    serializedV
                ]);
                const size = this._objectSize(serializedV);
                const m = metaObjects[k] ?? {
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    size
                };
                m.updatedAt = Date.now();
                m.size = size;
                metaObjects[k] = m;
                this._pendingSaveKeys.delete(k);
            } else {
                keysToLoad.push(k);
            }
        }
        const p = this._persister.multiSet(kvPairs);
        promises.push(p.then(()=>1));
        // For the keys that haven't loaded, load the key then try
        // persisting again. We don't want to do any async work here
        // or else we might end up saving older copies of the data to
        // the store.
        for (const k of keysToLoad){
            const p = this._loadKey(k).then(()=>this._enqueuePersist(opts));
            promises.push(p);
        }
        if (!skipGc) {
            this.gc();
        }
        return Promise.all(promises).then((vs)=>{
            return vs.reduce((acc, x)=>acc + x, 0);
        });
    }
    async flush() {
        if (!this._nextSave) {
            return;
        }
        clearTimeout(this._nextSave);
        this._nextSave = null;
        const p = this._writeToStorage();
        return p;
    }
    async _gc() {
        if (!this._gcOpts) {
            return;
        }
        const keys = new Set(await this._persister.getAllKeys());
        keys.delete(META_KEY);
        // Keys we can't delete
        const sacredKeys = new Set(Object.keys(this.currentValue));
        for (const k of Object.keys(this._loadingKeys)){
            sacredKeys.add(k);
        }
        for (const k of this._loadedKeys){
            sacredKeys.add(k);
        }
        // Refresh meta from the store so that we're less likely to
        // clobber data from other tabs
        const meta = await this._refreshMeta();
        if (!meta) {
            this._log.info('Could not gc because we were not able to load meta');
            return;
        }
        const promises = [];
        const deets = {
            gcOpts: this._gcOpts,
            keys,
            sacredKeys,
            removed: [],
            metaRemoved: [],
            removedMissingCount: 0,
            removedOldCount: 0,
            removedThresholdCount: 0,
            removedSizeCount: 0
        };
        // First, remove all keys we don't know about
        for (const key of keys){
            if (sacredKeys.has(key) || key in meta.objects) {
                continue;
            }
            this._log.info('Lost track of key in meta', key);
            promises.push(this._persister.removeItem(key));
            deets.removed.push(key);
            deets.removedMissingCount++;
        }
        // Remove anything over the max age
        const now = Date.now();
        for (const [k, m] of Object.entries(meta.objects)){
            if (!sacredKeys.has(k) && m.updatedAt < now - this._gcOpts.maxAgeMs) {
                promises.push(this._persister.removeItem(k));
                delete meta.objects[k];
                deets.removed.push(k);
                deets.removedOldCount++;
            }
        }
        // Keep queries under max queries
        const maxEntries = Object.entries(meta.objects);
        maxEntries.sort(([_k_a, a_meta], [_k_b, b_meta])=>{
            return a_meta.updatedAt - b_meta.updatedAt;
        });
        const deletableMaxEntries = maxEntries.filter(([x])=>!sacredKeys.has(x));
        if (maxEntries.length > this._gcOpts.maxEntries) {
            for (const [k] of deletableMaxEntries.slice(0, maxEntries.length - this._gcOpts.maxEntries)){
                promises.push(this._persister.removeItem(k));
                delete meta.objects[k];
                deets.removed.push(k);
                deets.removedThresholdCount++;
            }
        }
        // Remove oldest entries until we are under max size
        const delEntries = Object.entries(meta.objects);
        delEntries.sort(([_k_a, a_meta], [_k_b, b_meta])=>{
            return a_meta.updatedAt - b_meta.updatedAt;
        });
        const deletableDelEntries = delEntries.filter(([x])=>!sacredKeys.has(x));
        let currentSize = delEntries.reduce((acc, [_k, m])=>{
            return acc + m.size;
        }, 0);
        while(currentSize > 0 && currentSize > this._gcOpts.maxSize && deletableDelEntries.length){
            const [[k, m]] = deletableDelEntries.splice(0, 1);
            currentSize -= m.size;
            promises.push(this._persister.removeItem(k));
            delete meta.objects[k];
            deets.removed.push(k);
            deets.removedSizeCount++;
        }
        // Update meta to remove keys that are no longer in the store
        for (const k of Object.keys(meta.objects)){
            if (!keys.has(k) && !sacredKeys.has(k)) {
                delete meta.objects[k];
            }
        }
        if (deets.removed.length || deets.metaRemoved.length) {
            // Trigger a flush of the meta
            promises.push(this._enqueuePersist({
                skipGc: true
            }));
        }
        this._log.info('Completed GC', deets);
        await Promise.all(promises);
        return deets;
    }
    // Schedules a GC to run in one minute (unless it is already scheduled)
    gc() {
        if (this._nextGc) {
            return;
        }
        this._nextGc = setTimeout(()=>{
            safeIdleCallback(()=>{
                this._nextGc = null;
                this._gc();
            }, 30 * 1000);
        }, // 1 minute + some jitter to keep multiple tabs from running at same time
        1000 * 60 + Math.random() * 500);
    }
    _enqueuePersist(opts) {
        return new Promise((resolve, reject)=>{
            if (this._nextSave) {
                resolve(0);
                return;
            }
            this._nextSave = setTimeout(()=>{
                safeIdleCallback(()=>{
                    this._nextSave = null;
                    this._writeToStorage(opts).then(resolve).catch(reject);
                }, this._idleCallbackMaxWaitMs);
            }, this._saveThrottleMs);
        });
    }
    version() {
        return this._version;
    }
    // Takes a function that updates the store in place.
    // Uses `mutative` to get a list of keys that were changed
    // so that we know which entries we need to persist to the store.
    updateInPlace(f) {
        this._version++;
        const [state, patches] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])(this.currentValue, f, {
            enablePatches: true
        });
        for (const patch of patches){
            const k = patch.path[0];
            if (k && typeof k === 'string') {
                this._pendingSaveKeys.add(k);
                if (!this._loadedKeys.has(k)) {
                    this._loadKey(k);
                }
            }
        }
        this.currentValue = state;
        this._enqueuePersist();
        for (const cb of this._subs){
            cb(this.currentValue);
        }
        return state;
    }
    subscribe(cb) {
        this._subs.push(cb);
        cb(this.currentValue);
        return ()=>{
            this._subs = this._subs.filter((x)=>x !== cb);
        };
    }
} //# sourceMappingURL=PersistedObject.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/IndexedDBStorage.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>IndexedDBStorage
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/PersistedObject.js [app-client] (ecmascript)");
;
// Any time these are updates to the data format or new stores are added,
// the version must be updated.
// onupgradeneeded will be called, which is where you can
// move objects from one idb to another.
// We create a new IDB for each version change instead of
// using their built-in versioning because they have no ability
// to roll back and if multiple tabs are active, then you'll just
// be stuck.
const version = 6;
const storeNames = [
    'kv',
    'querySubs',
    'syncSubs'
];
const _exhaustiveCheck = null;
function logErrorCb(source) {
    return function logError(event) {
        console.error('Error in IndexedDB event', {
            source,
            event
        });
    };
}
async function existingDb(name) {
    return new Promise((resolve)=>{
        const request = indexedDB.open(name);
        request.onerror = (_event)=>{
            resolve(null);
        };
        request.onsuccess = (event)=>{
            const target = event.target;
            const db = target.result;
            resolve(db);
        };
        request.onupgradeneeded = (event)=>{
            const target = event.target;
            target.transaction?.abort();
            resolve(null);
        };
    });
}
async function upgradeQuerySubs5To6(hash, value, querySubStore) {
    const subs = // Backwards compatibility for older versions where we JSON.stringified before storing
    typeof value === 'string' ? JSON.parse(value) : value;
    if (!subs) {
        return;
    }
    const putReqs = new Set();
    return new Promise((resolve, reject)=>{
        const objects = {};
        for (const [hash, v] of Object.entries(subs)){
            const value = typeof v === 'string' ? JSON.parse(v) : v;
            if (value.lastAccessed) {
                const objectMeta = {
                    createdAt: value.lastAccessed,
                    updatedAt: value.lastAccessed,
                    size: value.result?.store?.triples?.length ?? 0
                };
                objects[hash] = objectMeta;
            }
            const putReq = querySubStore.put(value, hash);
            putReqs.add(putReq);
        }
        const meta = {
            objects
        };
        const metaPutReq = querySubStore.put(meta, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["META_KEY"]);
        putReqs.add(metaPutReq);
        for (const r of putReqs){
            r.onsuccess = ()=>{
                putReqs.delete(r);
                if (putReqs.size === 0) {
                    resolve();
                }
            };
            r.onerror = (event)=>{
                logErrorCb(`Move ${hash} to querySubs store failed`);
                reject(event);
            };
        }
    });
}
async function moveKvEntry5To6(k, value, kvStore) {
    const request = kvStore.put(value, k);
    return new Promise((resolve, reject)=>{
        request.onsuccess = ()=>resolve();
        request.onerror = (event)=>reject(event);
    });
}
async function upgrade5To6(appId, v6Db) {
    const v5db = await existingDb(`instant_${appId}_5`);
    if (!v5db) {
        return;
    }
    const data = await new Promise((resolve, reject)=>{
        const v5Tx = v5db.transaction([
            'kv'
        ], 'readonly');
        const objectStore = v5Tx.objectStore('kv');
        const cursorReq = objectStore.openCursor();
        cursorReq.onerror = (event)=>{
            reject(event);
        };
        const data = [];
        cursorReq.onsuccess = ()=>{
            const cursor = cursorReq.result;
            if (cursor) {
                const key = cursor.key;
                const value = cursor.value;
                data.push([
                    key,
                    value
                ]);
                cursor.continue();
            } else {
                resolve(data);
            }
        };
        cursorReq.onerror = (event)=>{
            reject(event);
        };
    });
    const v6Tx = v6Db.transaction([
        'kv',
        'querySubs'
    ], 'readwrite');
    const kvStore = v6Tx.objectStore('kv');
    const querySubStore = v6Tx.objectStore('querySubs');
    const promises = [];
    const kvMeta = {
        objects: {}
    };
    for (const [key, value] of data){
        switch(key){
            case 'querySubs':
                {
                    const p = upgradeQuerySubs5To6(key, value, querySubStore);
                    promises.push(p);
                    break;
                }
            default:
                {
                    const p = moveKvEntry5To6(key, value, kvStore);
                    promises.push(p);
                    const objectMeta = {
                        createdAt: Date.now(),
                        updatedAt: Date.now(),
                        size: 0
                    };
                    kvMeta.objects[key] = objectMeta;
                    break;
                }
        }
    }
    const p = moveKvEntry5To6(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["META_KEY"], kvMeta, kvStore);
    promises.push(p);
    await Promise.all(promises);
    await new Promise((resolve, reject)=>{
        v6Tx.oncomplete = (e)=>resolve(e);
        v6Tx.onerror = (e)=>reject(e);
        v6Tx.onabort = (e)=>reject(e);
    });
}
// We create many IndexedDBStorage instances that talk to the same
// underlying db, but we only get one `onupgradeneeded` event. This holds
// the upgrade promises so that we wait until upgrade finishes before
// we start writing.
const upgradePromises = new Map();
class IndexedDBStorage extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StoreInterface"] {
    dbName;
    _storeName;
    _appId;
    _prefix;
    _dbPromise;
    constructor(appId, storeName){
        super(appId, storeName);
        this.dbName = `instant_${appId}_${version}`;
        this._storeName = storeName;
        this._appId = appId;
        this._dbPromise = this._init();
    }
    _init() {
        return new Promise((resolve, reject)=>{
            let requiresUpgrade = false;
            const request = indexedDB.open(this.dbName, 1);
            request.onerror = (event)=>{
                reject(event);
            };
            request.onsuccess = (event)=>{
                const target = event.target;
                const db = target.result;
                if (!requiresUpgrade) {
                    const p = upgradePromises.get(this.dbName);
                    if (!p) {
                        resolve(db);
                    } else {
                        p.then(()=>resolve(db)).catch(()=>resolve(db));
                    }
                } else {
                    const p = upgrade5To6(this._appId, db).catch((e)=>{
                        logErrorCb('Error upgrading store from version 5 to 6.')(e);
                    });
                    upgradePromises.set(this.dbName, p);
                    p.then(()=>resolve(db)).catch(()=>resolve(db));
                }
            };
            request.onupgradeneeded = (event)=>{
                requiresUpgrade = true;
                this._upgradeStore(event);
            };
        });
    }
    _upgradeStore(event) {
        const target = event.target;
        const db = target.result;
        for (const storeName of storeNames){
            if (!db.objectStoreNames.contains(storeName)) {
                db.createObjectStore(storeName);
            }
        }
    }
    async getItem(k) {
        const db = await this._dbPromise;
        return new Promise((resolve, reject)=>{
            const transaction = db.transaction([
                this._storeName
            ], 'readonly');
            const objectStore = transaction.objectStore(this._storeName);
            const request = objectStore.get(k);
            request.onerror = (event)=>{
                reject(event);
            };
            request.onsuccess = (_event)=>{
                if (request.result) {
                    resolve(request.result);
                } else {
                    resolve(null);
                }
            };
        });
    }
    async setItem(k, v) {
        const db = await this._dbPromise;
        return new Promise((resolve, reject)=>{
            const transaction = db.transaction([
                this._storeName
            ], 'readwrite');
            const objectStore = transaction.objectStore(this._storeName);
            const request = objectStore.put(v, k);
            request.onerror = (event)=>{
                reject(event);
            };
            request.onsuccess = (_event)=>{
                resolve();
            };
        });
    }
    // Performs all writes in a transaction so that all succeed or none succeed.
    async multiSet(keyValuePairs) {
        const db = await this._dbPromise;
        return new Promise((resolve, reject)=>{
            const transaction = db.transaction([
                this._storeName
            ], 'readwrite');
            const objectStore = transaction.objectStore(this._storeName);
            const requests = new Set();
            for (const [k, v] of keyValuePairs){
                const request = objectStore.put(v, k);
                requests.add(request);
            }
            for (const request of requests){
                request.onerror = (event)=>{
                    transaction.abort();
                    reject(event);
                };
                request.onsuccess = (_event)=>{
                    requests.delete(request);
                    // Last request to finish resolves the transaction
                    if (requests.size === 0) {
                        resolve();
                    }
                };
            }
        });
    }
    async removeItem(k) {
        const db = await this._dbPromise;
        return new Promise((resolve, reject)=>{
            const transaction = db.transaction([
                this._storeName
            ], 'readwrite');
            const objectStore = transaction.objectStore(this._storeName);
            const request = objectStore.delete(k);
            request.onerror = (event)=>{
                reject(event);
            };
            request.onsuccess = (_event)=>{
                resolve();
            };
        });
    }
    async getAllKeys() {
        const db = await this._dbPromise;
        return new Promise((resolve, reject)=>{
            const transaction = db.transaction([
                this._storeName
            ], 'readonly');
            const objectStore = transaction.objectStore(this._storeName);
            const request = objectStore.getAllKeys();
            request.onerror = (event)=>{
                reject(event);
            };
            request.onsuccess = (_event)=>{
                resolve(request.result.filter((x)=>typeof x === 'string'));
            };
        });
    }
} //# sourceMappingURL=IndexedDBStorage.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/WindowNetworkListener.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>WindowNetworkListener
]);
class WindowNetworkListener {
    static async getIsOnline() {
        return navigator.onLine;
    }
    static listen(f) {
        const onOnline = ()=>{
            f(true);
        };
        const onOffline = ()=>{
            f(false);
        };
        addEventListener('online', onOnline);
        addEventListener('offline', onOffline);
        return ()=>{
            removeEventListener('online', onOnline);
            removeEventListener('offline', onOffline);
        };
    }
} //# sourceMappingURL=WindowNetworkListener.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/InstantError.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InstantError",
    ()=>InstantError
]);
class InstantError extends Error {
    hint;
    constructor(message, hint){
        super(message);
        this.hint = hint;
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
        }
        // Maintain proper stack trace for where our error was thrown
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, InstantError);
        }
        this.name = 'InstantError';
    }
    get [Symbol.toStringTag]() {
        return 'InstantError';
    }
} //# sourceMappingURL=InstantError.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/fetch.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InstantAPIError",
    ()=>InstantAPIError,
    "jsonFetch",
    ()=>jsonFetch
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/InstantError.js [app-client] (ecmascript)");
;
class InstantAPIError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantError"] {
    body;
    status;
    constructor(error){
        // Create a descriptive message based on the error
        const message = error.body?.message || `API Error (${error.status})`;
        super(message, error.body.hint);
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
        }
        // Maintain proper stack trace for where our error was thrown
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, InstantAPIError);
        }
        this.name = 'InstantAPIError';
        this.status = error.status;
        this.body = error.body;
    }
    get [Symbol.toStringTag]() {
        return 'InstantAPIError';
    }
}
async function jsonFetch(input, init) {
    const res = await fetch(input, init);
    const json = await res.json();
    return res.status === 200 ? Promise.resolve(json) : Promise.reject(new InstantAPIError({
        status: res.status,
        body: json
    }));
} //# sourceMappingURL=fetch.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/authAPI.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "exchangeCodeForToken",
    ()=>exchangeCodeForToken,
    "sendMagicCode",
    ()=>sendMagicCode,
    "signInAsGuest",
    ()=>signInAsGuest,
    "signInWithIdToken",
    ()=>signInWithIdToken,
    "signOut",
    ()=>signOut,
    "verifyMagicCode",
    ()=>verifyMagicCode,
    "verifyRefreshToken",
    ()=>verifyRefreshToken
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/fetch.js [app-client] (ecmascript)");
;
function sendMagicCode({ apiURI, appId, email }) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/runtime/auth/send_magic_code`, {
        method: 'POST',
        headers: {
            'content-type': 'application/json'
        },
        body: JSON.stringify({
            'app-id': appId,
            email
        })
    });
}
async function verifyMagicCode({ apiURI, appId, email, code, refreshToken }) {
    const res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/runtime/auth/verify_magic_code`, {
        method: 'POST',
        headers: {
            'content-type': 'application/json'
        },
        body: JSON.stringify({
            'app-id': appId,
            email,
            code,
            ...refreshToken ? {
                'refresh-token': refreshToken
            } : {}
        })
    });
    return res;
}
async function verifyRefreshToken({ apiURI, appId, refreshToken }) {
    const res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/runtime/auth/verify_refresh_token`, {
        method: 'POST',
        headers: {
            'content-type': 'application/json'
        },
        body: JSON.stringify({
            'app-id': appId,
            'refresh-token': refreshToken
        })
    });
    return res;
}
async function signInAsGuest({ apiURI, appId }) {
    const res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/runtime/auth/sign_in_guest`, {
        method: 'POST',
        headers: {
            'content-type': 'application/json'
        },
        body: JSON.stringify({
            'app-id': appId
        })
    });
    return res;
}
async function exchangeCodeForToken({ apiURI, appId, code, codeVerifier, refreshToken }) {
    const res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/runtime/oauth/token`, {
        method: 'POST',
        headers: {
            'content-type': 'application/json'
        },
        body: JSON.stringify({
            app_id: appId,
            code: code,
            code_verifier: codeVerifier,
            refresh_token: refreshToken
        })
    });
    return res;
}
async function signInWithIdToken({ apiURI, appId, nonce, idToken, clientName, refreshToken }) {
    const res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/runtime/oauth/id_token`, {
        method: 'POST',
        headers: {
            'content-type': 'application/json'
        },
        body: JSON.stringify({
            app_id: appId,
            nonce,
            id_token: idToken,
            client_name: clientName,
            refresh_token: refreshToken
        })
    });
    return res;
}
async function signOut({ apiURI, appId, refreshToken }) {
    const res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/runtime/signout`, {
        method: 'POST',
        headers: {
            'content-type': 'application/json'
        },
        body: JSON.stringify({
            app_id: appId,
            refresh_token: refreshToken
        })
    });
    return res;
} //# sourceMappingURL=authAPI.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/StorageAPI.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "deleteFile",
    ()=>deleteFile,
    "getDownloadUrl",
    ()=>getDownloadUrl,
    "getSignedUploadUrl",
    ()=>getSignedUploadUrl,
    "upload",
    ()=>upload,
    "uploadFile",
    ()=>uploadFile
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/fetch.js [app-client] (ecmascript)");
;
async function uploadFile({ apiURI, appId, path, file, refreshToken, contentType, contentDisposition }) {
    const headers = {
        app_id: appId,
        path,
        authorization: `Bearer ${refreshToken}`,
        'content-type': contentType || file.type
    };
    if (contentDisposition) {
        headers['content-disposition'] = contentDisposition;
    }
    const data = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/storage/upload`, {
        method: 'PUT',
        headers,
        body: file
    });
    return data;
}
async function deleteFile({ apiURI, appId, path, refreshToken }) {
    const { data } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/storage/files?app_id=${appId}&filename=${encodeURIComponent(path)}`, {
        method: 'DELETE',
        headers: {
            'content-type': 'application/json',
            authorization: `Bearer ${refreshToken}`
        }
    });
    return data;
}
async function getSignedUploadUrl({ apiURI, appId, fileName, refreshToken, metadata = {} }) {
    const { data } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/storage/signed-upload-url`, {
        method: 'POST',
        headers: {
            'content-type': 'application/json',
            authorization: `Bearer ${refreshToken}`
        },
        body: JSON.stringify({
            app_id: appId,
            filename: fileName
        })
    });
    return data;
}
async function upload(presignedUrl, file) {
    const response = await fetch(presignedUrl, {
        method: 'PUT',
        body: file,
        headers: {
            'Content-Type': file.type
        }
    });
    return response.ok;
}
async function getDownloadUrl({ apiURI, appId, path, refreshToken }) {
    const { data } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonFetch"])(`${apiURI}/storage/signed-download-url?app_id=${appId}&filename=${encodeURIComponent(path)}`, {
        method: 'GET',
        headers: {
            'content-type': 'application/json',
            authorization: `Bearer ${refreshToken}`
        }
    });
    return data;
} //# sourceMappingURL=StorageAPI.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/flags.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "devBackend",
    ()=>devBackend,
    "devtoolLocalDashboard",
    ()=>devtoolLocalDashboard,
    "instantLogs",
    ()=>instantLogs
]);
let devBackend = false;
let instantLogs = false;
let devtoolLocalDashboard = false;
if (typeof window !== 'undefined' && typeof window.localStorage !== 'undefined') {
    devBackend = !!window.localStorage.getItem('devBackend');
    instantLogs = !!window.localStorage.getItem('__instantLogging');
    devtoolLocalDashboard = !!window.localStorage.getItem('__devtoolLocalDash');
}
;
 //# sourceMappingURL=flags.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/pick.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "pick",
    ()=>pick
]);
function pick(obj, keys) {
    if (!keys) return obj;
    const ret = {};
    keys.forEach((key)=>{
        ret[key] = obj[key];
    });
    return ret;
} //# sourceMappingURL=pick.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/presence.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildPresenceSlice",
    ()=>buildPresenceSlice,
    "hasPresenceResponseChanged",
    ()=>hasPresenceResponseChanged
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$pick$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/pick.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/object.js [app-client] (ecmascript)");
;
;
function buildPresenceSlice(data, opts, userPeerId) {
    const slice = {
        peers: {}
    };
    const includeUser = opts && 'user' in opts ? opts.user : true;
    if (includeUser) {
        const user = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$pick$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pick"])(data.user ?? {}, opts?.keys);
        slice.user = {
            ...user,
            peerId: userPeerId
        };
    }
    for (const id of Object.keys(data.peers ?? {})){
        const shouldIncludeAllPeers = opts?.peers === undefined;
        const isPeerIncluded = Array.isArray(opts?.peers) && opts?.peers.includes(id);
        if (shouldIncludeAllPeers || isPeerIncluded) {
            const peer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$pick$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pick"])(data.peers[id], opts?.keys);
            slice.peers[id] = {
                ...peer,
                peerId: id
            };
        }
    }
    return slice;
}
function hasPresenceResponseChanged(a, b) {
    if (a.isLoading !== b.isLoading) return true;
    if (a.error !== b.error) return true;
    if (a.user || b.user) {
        if (!a.user || !b.user) return true;
        const same = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["areObjectsShallowEqual"])(a.user, b.user);
        if (!same) return true;
    }
    const sameKeys = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["areObjectKeysEqual"])(a.peers, b.peers);
    if (!sameKeys) return true;
    for (const id of Object.keys(a.peers)){
        const same = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["areObjectsShallowEqual"])(a.peers[id], b.peers[id]);
        if (!same) return true;
    }
    return false;
} //# sourceMappingURL=presence.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/Deferred.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Deferred",
    ()=>Deferred
]);
class Deferred {
    promise;
    _resolve;
    _reject;
    constructor(){
        this.promise = new Promise((resolve, reject)=>{
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    resolve(value) {
        this._resolve(value);
    }
    reject(reason) {
        this._reject(reason);
    }
} //# sourceMappingURL=Deferred.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/model/instaqlResult.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "extractTriples",
    ()=>extractTriples
]);
function _extractTriplesHelper(idNodes, acc = []) {
    idNodes.forEach((idNode)=>{
        const { data } = idNode;
        const { 'datalog-result': datalogResult } = data;
        const { 'join-rows': joinRows } = datalogResult;
        for (const rows of joinRows){
            for (const triple of rows){
                acc.push(triple);
            }
        }
        _extractTriplesHelper(idNode['child-nodes'], acc);
    });
}
function extractTriples(idNodes) {
    const triples = [];
    _extractTriplesHelper(idNodes, triples);
    return triples;
} //# sourceMappingURL=instaqlResult.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/linkIndex.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createLinkIndex",
    ()=>createLinkIndex
]);
function createLinkIndex(schema) {
    return Object.values(schema.links).reduce((linkIndex, link)=>{
        linkIndex[link.forward.on] ??= {};
        linkIndex[link.forward.on][link.forward.label] = {
            isForward: true,
            isSingular: link.forward.has === 'one',
            link
        };
        linkIndex[link.reverse.on] ??= {};
        linkIndex[link.reverse.on][link.reverse.label] = {
            isForward: false,
            isSingular: link.reverse.has === 'one',
            link
        };
        return linkIndex;
    }, {});
} //# sourceMappingURL=linkIndex.js.map
}),
"[project]/node_modules/@instantdb/version/dist/esm/version.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "version",
    ()=>version
]);
// This is the shared version for all of the js packages
// Update the version here and merge your code to main to
// publish a new version of all of the packages to npm.
const version = 'v0.22.142';
;
 //# sourceMappingURL=version.js.map
}),
"[project]/node_modules/@instantdb/version/dist/esm/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$version$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/version/dist/esm/version.js [app-client] (ecmascript)");
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/version.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$version$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/version/dist/esm/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$version$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/version/dist/esm/version.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$version$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"];
 //# sourceMappingURL=version.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/log.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>createLogger
]);
function createLogger(isEnabled, getStats) {
    return {
        info: isEnabled ? (...args)=>console.info(...args, getStats()) : ()=>{},
        debug: isEnabled ? (...args)=>console.debug(...args, getStats()) : ()=>{},
        error: isEnabled ? (...args)=>console.error(...args, getStats()) : ()=>{}
    };
} //# sourceMappingURL=log.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/schemaTypes.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DataAttrDef",
    ()=>DataAttrDef,
    "EntityDef",
    ()=>EntityDef,
    "InstantGraph",
    ()=>InstantGraph,
    "InstantSchemaDef",
    ()=>InstantSchemaDef,
    "InstantUnknownSchemaDef",
    ()=>InstantUnknownSchemaDef,
    "LinkAttrDef",
    ()=>LinkAttrDef
]);
class DataAttrDef {
    valueType;
    required;
    isIndexed;
    config;
    metadata = {};
    constructor(valueType, required, isIndexed, config = {
        indexed: false,
        unique: false
    }){
        this.valueType = valueType;
        this.required = required;
        this.isIndexed = isIndexed;
        this.config = config;
    }
    /**
     * @deprecated Only use this temporarily for attributes that you want
     * to treat as required in frontend code but canâ€™t yet mark as required
     * and enforced for backend
     */ clientRequired() {
        return new DataAttrDef(this.valueType, false, this.isIndexed, this.config);
    }
    optional() {
        return new DataAttrDef(this.valueType, false, this.isIndexed, this.config);
    }
    unique() {
        return new DataAttrDef(this.valueType, this.required, this.isIndexed, {
            ...this.config,
            unique: true
        });
    }
    indexed() {
        return new DataAttrDef(this.valueType, this.required, true, {
            ...this.config,
            indexed: true
        });
    }
}
class LinkAttrDef {
    cardinality;
    entityName;
    constructor(cardinality, entityName){
        this.cardinality = cardinality;
        this.entityName = entityName;
    }
}
class EntityDef {
    attrs;
    links;
    constructor(attrs, links){
        this.attrs = attrs;
        this.links = links;
    }
    asType() {
        return new EntityDef(this.attrs, this.links);
    }
}
class InstantSchemaDef {
    entities;
    links;
    rooms;
    constructor(entities, links, rooms){
        this.entities = entities;
        this.links = links;
        this.rooms = rooms;
    }
    /**
     * @deprecated
     * `withRoomSchema` is deprecated. Define your schema in `rooms` directly:
     *
     * @example
     * // Before:
     * const schema = i.schema({
     *   // ...
     * }).withRoomSchema<RoomSchema>()
     *
     * // After
     * const schema = i.schema({
     *  rooms: {
     *    // ...
     *  }
     * })
     *
     * @see https://instantdb.com/docs/presence-and-topics#typesafety
     */ withRoomSchema() {
        return new InstantSchemaDef(this.entities, this.links, {});
    }
}
class InstantGraph {
    entities;
    links;
    constructor(entities, links){
        this.entities = entities;
        this.links = links;
    }
    withRoomSchema() {
        return new InstantGraph(this.entities, this.links);
    }
}
class InstantUnknownSchemaDef extends InstantSchemaDef {
} //# sourceMappingURL=schemaTypes.js.map
}),
"[project]/node_modules/uuid/dist/esm-browser/validate.js [app-client] (ecmascript) <export default as validate>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "validate",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/validate.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@instantdb/core/dist/esm/queryValidation.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "QueryValidationError",
    ()=>QueryValidationError,
    "validateQuery",
    ()=>validateQuery
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/schemaTypes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__validate$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/validate.js [app-client] (ecmascript) <export default as validate>");
;
;
class QueryValidationError extends Error {
    constructor(message, path){
        const fullMessage = path ? `At path '${path}': ${message}` : message;
        super(fullMessage);
        this.name = 'QueryValidationError';
    }
}
const dollarSignKeys = [
    'where',
    'order',
    'limit',
    'last',
    'first',
    'offset',
    'after',
    'before',
    'fields',
    'aggregate'
];
const getAttrType = (attrDef)=>{
    return attrDef.valueType || 'unknown';
};
const isValidValueForType = (value, expectedType, isAnyType = false)=>{
    if (isAnyType) return true;
    if (value === null || value === undefined) return true;
    switch(expectedType){
        case 'string':
            return typeof value === 'string';
        case 'number':
            return typeof value === 'number' && !isNaN(value);
        case 'boolean':
            return typeof value === 'boolean';
        case 'date':
            return value instanceof Date || typeof value === 'string' || typeof value === 'number';
        default:
            return true;
    }
};
const validateOperator = (op, opValue, expectedType, attrName, entityName, attrDef, path)=>{
    const isAnyType = attrDef.valueType === 'json';
    const assertValidValue = (op, expectedType, opValue)=>{
        if (!isValidValueForType(opValue, expectedType, isAnyType)) {
            throw new QueryValidationError(`Invalid value for operator '${op}' on attribute '${attrName}' in entity '${entityName}'. Expected ${expectedType}, but received: ${typeof opValue}`, path);
        }
    };
    switch(op){
        case 'in':
        case '$in':
            if (!Array.isArray(opValue)) {
                throw new QueryValidationError(`Operator '${op}' for attribute '${attrName}' in entity '${entityName}' must be an array, but received: ${typeof opValue}`, path);
            }
            for (const item of opValue){
                assertValidValue(op, expectedType, item);
            }
            break;
        case '$not':
        case '$ne':
        case '$gt':
        case '$lt':
        case '$gte':
        case '$lte':
            assertValidValue(op, expectedType, opValue);
            break;
        case '$like':
        case '$ilike':
            assertValidValue(op, 'string', opValue);
            if (op === '$ilike') {
                if (!attrDef.isIndexed) {
                    throw new QueryValidationError(`Operator '${op}' can only be used with indexed attributes, but '${attrName}' in entity '${entityName}' is not indexed`, path);
                }
            }
            break;
        case '$isNull':
            assertValidValue(op, 'boolean', opValue);
            break;
        default:
            throw new QueryValidationError(`Unknown operator '${op}' for attribute '${attrName}' in entity '${entityName}'`, path);
    }
};
const validateWhereClauseValue = (value, attrName, attrDef, entityName, path)=>{
    const expectedType = getAttrType(attrDef);
    const isAnyType = attrDef.valueType === 'json';
    const isComplexObject = typeof value === 'object' && value !== null && !Array.isArray(value);
    if (isComplexObject) {
        // For any type, allow complex objects without treating them as operators
        if (isAnyType) {
            return; // Any type accepts any value, including complex objects
        }
        const operators = value;
        for (const [op, opValue] of Object.entries(operators)){
            validateOperator(op, opValue, expectedType, attrName, entityName, attrDef, `${path}.${op}`);
        }
    } else {
        if (!isValidValueForType(value, expectedType, isAnyType)) {
            throw new QueryValidationError(`Invalid value for attribute '${attrName}' in entity '${entityName}'. Expected ${expectedType}, but received: ${typeof value}`, path);
        }
    }
};
const validateDotNotationAttribute = (dotPath, value, startEntityName, schema, path)=>{
    const pathParts = dotPath.split('.');
    if (pathParts.length < 2) {
        throw new QueryValidationError(`Invalid dot notation path '${dotPath}'. Must contain at least one dot.`, path);
    }
    let currentEntityName = startEntityName;
    // Traverse all path parts except the last one (which should be an attribute)
    for(let i = 0; i < pathParts.length - 1; i++){
        const linkName = pathParts[i];
        const currentEntity = schema.entities[currentEntityName];
        if (!currentEntity) {
            throw new QueryValidationError(`Entity '${currentEntityName}' does not exist in schema while traversing dot notation path '${dotPath}'.`, path);
        }
        const link = currentEntity.links[linkName];
        if (!link) {
            const availableLinks = Object.keys(currentEntity.links);
            throw new QueryValidationError(`Link '${linkName}' does not exist on entity '${currentEntityName}' in dot notation path '${dotPath}'. Available links: ${availableLinks.length > 0 ? availableLinks.join(', ') : 'none'}`, path);
        }
        currentEntityName = link.entityName;
    }
    // Validate the final attribute
    const finalAttrName = pathParts[pathParts.length - 1];
    const finalEntity = schema.entities[currentEntityName];
    if (!finalEntity) {
        throw new QueryValidationError(`Target entity '${currentEntityName}' does not exist in schema for dot notation path '${dotPath}'.`, path);
    }
    // Handle 'id' field specially - every entity has an id field
    if (finalAttrName === 'id') {
        if (typeof value == 'string' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__validate$3e$__["validate"])(value)) {
            throw new QueryValidationError(`Invalid value for id field in entity '${currentEntityName}'. Expected a UUID, but received: ${value}`, path);
        }
        validateWhereClauseValue(value, dotPath, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('string', false, true), startEntityName, path);
        return;
    }
    const attrDef = finalEntity.attrs[finalAttrName];
    if (Object.keys(finalEntity.links).includes(finalAttrName)) {
        if (typeof value === 'string' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__validate$3e$__["validate"])(value)) {
            throw new QueryValidationError(`Invalid value for link '${finalAttrName}' in entity '${currentEntityName}'. Expected a UUID, but received: ${value}`, path);
        }
        validateWhereClauseValue(value, dotPath, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('string', false, true), startEntityName, path);
        return;
    }
    if (!attrDef) {
        const availableAttrs = Object.keys(finalEntity.attrs);
        throw new QueryValidationError(`Attribute '${finalAttrName}' does not exist on entity '${currentEntityName}' in dot notation path '${dotPath}'. Available attributes: ${availableAttrs.length > 0 ? availableAttrs.join(', ') + ', id' : 'id'}`, path);
    }
    // Validate the value against the attribute type
    validateWhereClauseValue(value, dotPath, attrDef, startEntityName, path);
};
const validateWhereClause = (whereClause, entityName, schema, path)=>{
    for (const [key, value] of Object.entries(whereClause)){
        if (key === 'or' || key === 'and') {
            if (Array.isArray(value)) {
                for (const clause of value){
                    if (typeof clause === 'object' && clause !== null) {
                        validateWhereClause(clause, entityName, schema, `${path}.${key}[${clause}]`);
                    }
                }
            }
            continue;
        }
        if (key === 'id') {
            validateWhereClauseValue(value, 'id', new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('string', false, true), entityName, `${path}.id`);
            continue;
        }
        if (key.includes('.')) {
            validateDotNotationAttribute(key, value, entityName, schema, `${path}.${key}`);
            continue;
        }
        const entityDef = schema.entities[entityName];
        if (!entityDef) continue;
        const attrDef = entityDef.attrs[key];
        const linkDef = entityDef.links[key];
        if (!attrDef && !linkDef) {
            const availableAttrs = Object.keys(entityDef.attrs);
            const availableLinks = Object.keys(entityDef.links);
            throw new QueryValidationError(`Attribute or link '${key}' does not exist on entity '${entityName}'. Available attributes: ${availableAttrs.length > 0 ? availableAttrs.join(', ') : 'none'}. Available links: ${availableLinks.length > 0 ? availableLinks.join(', ') : 'none'}`, `${path}.${key}`);
        }
        if (attrDef) {
            validateWhereClauseValue(value, key, attrDef, entityName, `${path}.${key}`);
        } else if (linkDef) {
            // For links, we expect the value to be a string (ID of the linked entity)
            // Create a synthetic string attribute definition for validation
            if (typeof value === 'string' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__validate$3e$__["validate"])(value)) {
                throw new QueryValidationError(`Invalid value for link '${key}' in entity '${entityName}'. Expected a UUID, but received: ${value}`, `${path}.${key}`);
            }
            const syntheticAttrDef = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('string', false, true);
            validateWhereClauseValue(value, key, syntheticAttrDef, entityName, `${path}.${key}`);
        }
    }
};
const validateDollarObject = (dollarObj, entityName, schema, path, depth = 0)=>{
    for (const key of Object.keys(dollarObj)){
        if (!dollarSignKeys.includes(key)) {
            throw new QueryValidationError(`Invalid query parameter '${key}' in $ object. Valid parameters are: ${dollarSignKeys.join(', ')}. Found: ${key}`, path);
        }
    }
    // Validate that pagination parameters are only used at top-level
    const paginationParams = [
        // 'limit', // only supported client side
        'offset',
        'before',
        'after',
        'first',
        'last'
    ];
    for (const param of paginationParams){
        if (dollarObj[param] !== undefined && depth > 0) {
            throw new QueryValidationError(`'${param}' can only be used on top-level namespaces. It cannot be used in nested queries.`, path);
        }
    }
    if (dollarObj.where && schema) {
        if (typeof dollarObj.where !== 'object' || dollarObj.where === null) {
            throw new QueryValidationError(`'where' clause must be an object in entity '${entityName}', but received: ${typeof dollarObj.where}`, path ? `${path}.where` : undefined);
        }
        validateWhereClause(dollarObj.where, entityName, schema, path ? `${path}.where` : 'where');
    }
};
const validateEntityInQuery = (queryPart, entityName, schema, path, depth = 0)=>{
    if (!queryPart || typeof queryPart !== 'object') {
        throw new QueryValidationError(`Query part for entity '${entityName}' must be an object, but received: ${typeof queryPart}`, path);
    }
    for (const key of Object.keys(queryPart)){
        if (key !== '$') {
            // Validate link exists
            if (schema && !(key in schema.entities[entityName].links)) {
                const availableLinks = Object.keys(schema.entities[entityName].links);
                throw new QueryValidationError(`Link '${key}' does not exist on entity '${entityName}'. Available links: ${availableLinks.length > 0 ? availableLinks.join(', ') : 'none'}`, `${path}.${key}`);
            }
            // Recursively validate nested query
            const nestedQuery = queryPart[key];
            if (typeof nestedQuery === 'object' && nestedQuery !== null) {
                const linkedEntityName = schema?.entities[entityName].links[key]?.entityName;
                if (linkedEntityName) {
                    validateEntityInQuery(nestedQuery, linkedEntityName, schema, `${path}.${key}`, depth + 1);
                }
            }
        } else {
            // Validate $ object
            const dollarObj = queryPart[key];
            if (typeof dollarObj !== 'object' || dollarObj === null) {
                throw new QueryValidationError(`Query parameter '$' must be an object in entity '${entityName}', but received: ${typeof dollarObj}`, `${path}.$`);
            }
            validateDollarObject(dollarObj, entityName, schema, `${path}.$`, depth);
        }
    }
};
const validateQuery = (q, schema)=>{
    if (typeof q !== 'object' || q === null) {
        throw new QueryValidationError(`Query must be an object, but received: ${typeof q}${q === null ? ' (null)' : ''}`);
    }
    if (Array.isArray(q)) {
        throw new QueryValidationError(`Query must be an object, but received: ${typeof q}`);
    }
    const queryObj = q;
    for (const topLevelKey of Object.keys(queryObj)){
        if (Array.isArray(q[topLevelKey])) {
            throw new QueryValidationError(`Query keys must be strings, but found key of type: ${typeof topLevelKey}`, topLevelKey);
        }
        if (typeof topLevelKey !== 'string') {
            throw new QueryValidationError(`Query keys must be strings, but found key of type: ${typeof topLevelKey}`, topLevelKey);
        }
        if (topLevelKey === '$$ruleParams') {
            continue;
        }
        // Check if the key is top level entity
        if (schema) {
            if (!schema.entities[topLevelKey]) {
                const availableEntities = Object.keys(schema.entities);
                throw new QueryValidationError(`Entity '${topLevelKey}' does not exist in schema. Available entities: ${availableEntities.length > 0 ? availableEntities.join(', ') : 'none'}`, topLevelKey);
            }
        }
        validateEntityInQuery(queryObj[topLevelKey], topLevelKey, schema, topLevelKey, 0);
    }
}; //# sourceMappingURL=queryValidation.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/transactionValidation.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TransactionValidationError",
    ()=>TransactionValidationError,
    "isValidEntityId",
    ()=>isValidEntityId,
    "validateTransactions",
    ()=>validateTransactions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/instatx.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__validate$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/validate.js [app-client] (ecmascript) <export default as validate>");
;
;
const isValidEntityId = (value)=>{
    if (typeof value !== 'string') {
        return false;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLookup"])(value)) {
        return true;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__validate$3e$__["validate"])(value);
};
class TransactionValidationError extends Error {
    constructor(message){
        super(message);
        this.name = 'TransactionValidationError';
    }
}
const formatAvailableOptions = (items)=>items.length > 0 ? items.join(', ') : 'none';
const createEntityNotFoundError = (entityName, availableEntities)=>new TransactionValidationError(`Entity '${entityName}' does not exist in schema. Available entities: ${formatAvailableOptions(availableEntities)}`);
const TYPE_VALIDATORS = {
    string: (value)=>typeof value === 'string',
    number: (value)=>typeof value === 'number' && !isNaN(value),
    boolean: (value)=>typeof value === 'boolean',
    date: (value)=>value instanceof Date || typeof value === 'string' || typeof value === 'number',
    json: ()=>true
};
const isValidValueForAttr = (value, attrDef)=>{
    if (value === null || value === undefined) return true;
    return TYPE_VALIDATORS[attrDef.valueType]?.(value) ?? false;
};
const validateEntityExists = (entityName, schema)=>{
    const entityDef = schema.entities[entityName];
    if (!entityDef) {
        throw createEntityNotFoundError(entityName, Object.keys(schema.entities));
    }
    return entityDef;
};
const validateDataOperation = (entityName, data, schema)=>{
    const entityDef = validateEntityExists(entityName, schema);
    if (typeof data !== 'object' || data === null) {
        throw new TransactionValidationError(`Arguments for data operation on entity '${entityName}' must be an object, but received: ${typeof data}`);
    }
    for (const [attrName, value] of Object.entries(data)){
        if (attrName === 'id') continue; // id is handled specially
        const attrDef = entityDef.attrs[attrName];
        if (attrDef) {
            if (!isValidValueForAttr(value, attrDef)) {
                throw new TransactionValidationError(`Invalid value for attribute '${attrName}' in entity '${entityName}'. Expected ${attrDef.valueType}, but received: ${typeof value}`);
            }
        }
    }
};
const validateLinkOperation = (entityName, links, schema)=>{
    const entityDef = validateEntityExists(entityName, schema);
    if (typeof links !== 'object' || links === null) {
        throw new TransactionValidationError(`Arguments for link operation on entity '${entityName}' must be an object, but received: ${typeof links}`);
    }
    for (const [linkName, linkValue] of Object.entries(links)){
        const link = entityDef.links[linkName];
        if (!link) {
            const availableLinks = Object.keys(entityDef.links);
            throw new TransactionValidationError(`Link '${linkName}' does not exist on entity '${entityName}'. Available links: ${formatAvailableOptions(availableLinks)}`);
        }
        // Validate UUID format for link values
        if (linkValue !== null && linkValue !== undefined) {
            if (Array.isArray(linkValue)) {
                // Handle array of UUIDs
                for (const linkReference of linkValue){
                    if (!isValidEntityId(linkReference)) {
                        throw new TransactionValidationError(`Invalid entity ID in link '${linkName}' for entity '${entityName}'. Expected a UUID or a lookup, but received: ${linkReference}`);
                    }
                }
            } else {
                // Handle single UUID
                if (!isValidEntityId(linkValue)) {
                    throw new TransactionValidationError(`Invalid UUID in link '${linkName}' for entity '${entityName}'. Expected a UUID, but received: ${linkValue}`);
                }
            }
        }
    }
};
const VALIDATION_STRATEGIES = {
    create: validateDataOperation,
    update: validateDataOperation,
    merge: validateDataOperation,
    link: validateLinkOperation,
    unlink: validateLinkOperation,
    delete: ()=>{}
};
const validateOp = (op, schema)=>{
    if (!schema) return;
    const [action, entityName, _id, args] = op;
    // _id should be a uuid
    if (!Array.isArray(_id)) {
        const isUuid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__validate$3e$__["validate"])(_id);
        if (!isUuid) {
            throw new TransactionValidationError(`Invalid id for entity '${entityName}'. Expected a UUID, but received: ${_id}`);
        }
    }
    if (typeof entityName !== 'string') {
        throw new TransactionValidationError(`Entity name must be a string, but received: ${typeof entityName}`);
    }
    const validator = VALIDATION_STRATEGIES[action];
    if (validator && args !== undefined) {
        validator(entityName, args, schema);
    }
};
const validateTransactions = (inputChunks, schema)=>{
    const chunks = Array.isArray(inputChunks) ? inputChunks : [
        inputChunks
    ];
    for (const txStep of chunks){
        if (!txStep || typeof txStep !== 'object') {
            throw new TransactionValidationError(`Transaction chunk must be an object, but received: ${typeof txStep}`);
        }
        if (!Array.isArray(txStep.__ops)) {
            throw new TransactionValidationError(`Transaction chunk must have __ops array, but received: ${typeof txStep.__ops}`);
        }
        for (const op of txStep.__ops){
            if (!Array.isArray(op)) {
                throw new TransactionValidationError(`Transaction operation must be an array, but received: ${typeof op}`);
            }
            validateOp(op, schema);
        }
    }
}; //# sourceMappingURL=transactionValidation.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/Connection.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SSEConnection",
    ()=>SSEConnection,
    "WSConnection",
    ()=>WSConnection
]);
let _connId = 0;
class WSConnection {
    type = 'ws';
    conn;
    id;
    onopen;
    onmessage;
    onclose;
    onerror;
    constructor(url){
        this.id = `${this.type}_${_connId++}`;
        this.conn = new WebSocket(url);
        this.conn.onopen = (_e)=>{
            if (this.onopen) {
                this.onopen({
                    target: this
                });
            }
        };
        this.conn.onmessage = (e)=>{
            if (this.onmessage) {
                this.onmessage({
                    target: this,
                    message: JSON.parse(e.data.toString())
                });
            }
        };
        this.conn.onclose = (_e)=>{
            if (this.onclose) {
                this.onclose({
                    target: this
                });
            }
        };
        this.conn.onerror = (_e)=>{
            if (this.onerror) {
                this.onerror({
                    target: this
                });
            }
        };
    }
    close() {
        this.conn.close();
    }
    isOpen() {
        return this.conn.readyState === (WebSocket.OPEN ?? 1);
    }
    isConnecting() {
        return this.conn.readyState === (WebSocket.CONNECTING ?? 0);
    }
    send(msg) {
        return this.conn.send(JSON.stringify(msg));
    }
}
class SSEConnection {
    type = 'sse';
    initParams = null;
    sendQueue = [];
    sendPromise;
    closeFired = false;
    sseInitTimeout = undefined;
    ES;
    messageUrl;
    conn;
    url;
    id;
    onopen;
    onmessage;
    onclose;
    onerror;
    constructor(ES, url, messageUrl){
        this.id = `${this.type}_${_connId++}`;
        this.url = url;
        this.messageUrl = messageUrl || this.url;
        this.ES = ES;
        this.conn = new ES(url);
        // Close the connection if we didn't get an init within 10 seconds
        this.sseInitTimeout = setTimeout(()=>{
            if (!this.initParams) {
                this.handleError();
            }
        }, 10000);
        this.conn.onmessage = (e)=>{
            const message = JSON.parse(e.data);
            if (Array.isArray(message)) {
                for (const msg of message){
                    this.handleMessage(msg);
                }
            } else {
                this.handleMessage(message);
            }
        };
        this.conn.onerror = (e)=>{
            this.handleError();
        };
    }
    handleMessage(msg) {
        if (msg.op === 'sse-init') {
            this.initParams = {
                machineId: msg['machine-id'],
                sessionId: msg['session-id'],
                sseToken: msg['sse-token']
            };
            if (this.onopen) {
                this.onopen({
                    target: this
                });
            }
            clearTimeout(this.sseInitTimeout);
            return;
        }
        if (this.onmessage) {
            this.onmessage({
                target: this,
                message: msg
            });
        }
    }
    // Runs the onerror and closes the connection
    handleError() {
        try {
            if (this.onerror) {
                this.onerror({
                    target: this
                });
            }
        } finally{
            this.handleClose();
        }
    }
    handleClose() {
        this.conn.close();
        if (this.onclose && !this.closeFired) {
            this.closeFired = true;
            this.onclose({
                target: this
            });
        }
    }
    async postMessages(messages) {
        // TODO(dww): Create a connection with chunked encoding so we can
        //            send multiple messages over one request
        try {
            const resp = await fetch(this.messageUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    machine_id: this.initParams?.machineId,
                    session_id: this.initParams?.sessionId,
                    sse_token: this.initParams?.sseToken,
                    messages
                })
            });
            if (!resp.ok) {
                this.handleError();
            }
        } catch (e) {
            this.handleError();
        }
    }
    async flushQueue() {
        if (this.sendPromise || !this.sendQueue.length) return;
        const messages = this.sendQueue;
        this.sendQueue = [];
        const sendPromise = this.postMessages(messages);
        this.sendPromise = sendPromise;
        sendPromise.then(()=>{
            this.sendPromise = null;
            this.flushQueue();
        });
    }
    send(msg) {
        if (!this.isOpen() || !this.initParams) {
            if (this.isConnecting()) {
                throw new Error(`Failed to execute 'send' on 'EventSource': Still in CONNECTING state.`);
            }
            if (this.conn.readyState === this.ES.CLOSED) {
                throw new Error(`EventSource is already in CLOSING or CLOSED state.`);
            }
            throw new Error(`EventSource is in invalid state.`);
        }
        this.sendQueue.push(msg);
        this.flushQueue();
    }
    isOpen() {
        return this.conn.readyState === this.ES.OPEN && this.initParams !== null;
    }
    isConnecting() {
        return this.conn.readyState === this.ES.CONNECTING || this.conn.readyState === this.ES.OPEN && this.initParams === null;
    }
    close() {
        this.handleClose();
    }
} //# sourceMappingURL=Connection.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/SyncTable.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CallbackEventType",
    ()=>CallbackEventType,
    "SyncTable",
    ()=>SyncTable
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/PersistedObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/store.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/weakHash.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/id.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instaql$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/instaql.js [app-client] (ecmascript)");
;
;
;
;
;
// Modifies the data in place because it comes directly from storage
function syncSubFromStorage(sub, useDateObjects) {
    const values = sub.values;
    if (values) {
        const attrsStore = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attrsStoreFromJSON"](values.attrsStore, null);
        if (attrsStore) {
            for (const e of values.entities || []){
                e.store.useDateObjects = useDateObjects;
                e.store = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromJSON"](attrsStore, e.store);
            }
            values.attrsStore = attrsStore;
        }
    }
    return sub;
}
function syncSubToStorage(_k, sub) {
    if (sub.values) {
        const entities = [];
        for (const e of sub.values?.entities){
            const store = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toJSON"](e.store);
            entities.push({
                ...e,
                store
            });
        }
        return {
            ...sub,
            values: {
                attrsStore: sub.values.attrsStore.toJSON(),
                entities
            }
        };
    } else {
        return sub;
    }
}
function onMergeSub(_key, storageSub, inMemorySub) {
    const storageTxId = storageSub?.state?.txId;
    const memoryTxId = inMemorySub?.state?.txId;
    if (storageTxId && (!memoryTxId || storageTxId > memoryTxId)) {
        return storageSub;
    }
    if (memoryTxId && (!storageTxId || memoryTxId > storageTxId)) {
        return inMemorySub;
    }
    return storageSub || inMemorySub;
}
function queryEntity(sub, store, attrsStore) {
    const res = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instaql$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
        store,
        attrsStore,
        pageInfo: null,
        aggregate: null
    }, sub.query);
    return res.data[sub.table][0];
}
function getServerCreatedAt(sub, store, attrsStore, entityId) {
    const aid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"](attrsStore, sub.table, 'id')?.id;
    if (!aid) {
        return -1;
    }
    const t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getInMap"](store.eav, [
        entityId,
        aid,
        entityId
    ]);
    if (!t) {
        return -1;
    }
    return t[3];
}
function applyChangesToStore(store, attrsStore, changes) {
    for (const { action, triple } of changes){
        switch(action){
            case 'added':
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addTriple"](store, attrsStore, triple);
                break;
            case 'removed':
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["retractTriple"](store, attrsStore, triple);
                break;
        }
    }
}
function changedFieldsOfChanges(store, attrsStore, changes) {
    // This will be more complicated when we include links, we can either add a
    // changedLinks field or we can have something like 'bookshelves.title`
    const changedFields = {};
    for (const { action, triple } of changes){
        const [e, a, v] = triple;
        const field = attrsStore.getAttr(a)?.['forward-identity']?.[2];
        if (!field) continue;
        const fields = changedFields[e] ?? {};
        changedFields[e] = fields;
        const oldNew = fields[field] ?? {};
        switch(action){
            case 'added':
                oldNew.newValue = v;
                break;
            case 'removed':
                // Only take the first thing that was removed, in case we modified things in the middle
                if (oldNew.oldValue === undefined) {
                    oldNew.oldValue = v;
                }
                break;
        }
        fields[field] = oldNew;
    }
    for (const [_eid, fields] of Object.entries(changedFields)){
        for (const [k, { oldValue, newValue }] of Object.entries(fields)){
            if (oldValue === newValue) {
                delete fields[k];
            }
        }
    }
    return changedFields;
}
function subData(sub, entities) {
    return {
        [sub.table]: entities.map((e)=>e.entity)
    };
}
// Updates the sub order field type if it hasn't been set
// and returns the type. We have to wait until the attrs
// are loaded before we can determine the type.
function orderFieldTypeMutative(sub, getAttrs) {
    if (sub.orderFieldType) {
        return sub.orderFieldType;
    }
    const orderFieldType = sub.orderField === 'serverCreatedAt' ? 'number' : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"](getAttrs(), sub.table, sub.orderField)?.['checked-data-type'];
    sub.orderFieldType = orderFieldType;
    return orderFieldType;
}
function sortEntitiesInPlace(sub, orderFieldType, entities) {
    const dataType = orderFieldType;
    if (sub.orderField === 'serverCreatedAt') {
        entities.sort(sub.orderDirection === 'asc' ? function compareEntities(a, b) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instaql$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compareOrder"])(a.entity.id, a.serverCreatedAt, b.entity.id, b.serverCreatedAt, dataType);
        } : function compareEntities(b, a) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instaql$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compareOrder"])(a.entity.id, a.serverCreatedAt, b.entity.id, b.serverCreatedAt, dataType);
        });
        return;
    }
    const field = sub.orderField;
    entities.sort(sub.orderDirection === 'asc' ? function compareEntities(a, b) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instaql$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compareOrder"])(a.entity.id, a.entity[field], b.entity.id, b.entity[field], dataType);
    } : function compareEntities(b, a) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instaql$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compareOrder"])(a.entity.id, a.entity[field], b.entity.id, b.entity[field], dataType);
    });
}
var CallbackEventType;
(function(CallbackEventType) {
    CallbackEventType["InitialSyncBatch"] = "InitialSyncBatch";
    CallbackEventType["InitialSyncComplete"] = "InitialSyncComplete";
    CallbackEventType["LoadFromStorage"] = "LoadFromStorage";
    CallbackEventType["SyncTransaction"] = "SyncTransaction";
    CallbackEventType["Error"] = "Error";
})(CallbackEventType || (CallbackEventType = {}));
class SyncTable {
    trySend;
    subs;
    // Using any for the SyncCallback because we'd need Reactor to be typed
    callbacks = {};
    config;
    idToHash = {};
    log;
    createStore;
    getAttrs;
    constructor(trySend, storage, config, log, createStore, getAttrs){
        this.trySend = trySend;
        this.config = config;
        this.log = log;
        this.createStore = createStore;
        this.getAttrs = getAttrs;
        this.subs = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PersistedObject"]({
            persister: storage,
            merge: onMergeSub,
            serialize: syncSubToStorage,
            parse: (_key, x)=>syncSubFromStorage(x, this.config.useDateObjects),
            objectSize: (sub)=>sub.values?.entities.length || 0,
            logger: log,
            gc: {
                maxAgeMs: 1000 * 60 * 60 * 24 * 7 * 52,
                maxEntries: 1000,
                // Size of each sub is the number of entity
                maxSize: 1_000_000
            }
        });
    }
    beforeUnload() {
        this.subs.flush();
    }
    subscribe(q, cb) {
        const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
        this.callbacks[hash] = this.callbacks[hash] || [];
        this.callbacks[hash].push(cb);
        this.initSubscription(q, hash, cb);
        return (opts)=>{
            this.unsubscribe(hash, cb, opts?.keepSubscription);
        };
    }
    unsubscribe(hash, cb, keepSubscription) {
        const cbs = (this.callbacks[hash] || []).filter((x)=>x !== cb);
        this.callbacks[hash] = cbs;
        if (!cbs.length) {
            delete this.callbacks[hash];
            const sub = this.subs.currentValue[hash];
            if (sub?.state) {
                this.clearSubscriptionData(sub.state.subscriptionId, !!keepSubscription);
            }
            if (!keepSubscription) {
                this.subs.updateInPlace((prev)=>{
                    delete prev[hash];
                });
            }
        }
    }
    sendStart(query) {
        this.trySend((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
            op: 'start-sync',
            q: query
        });
    }
    sendResync(sub, state, txId) {
        // Make sure we can find the hash from the subscriptionId
        this.idToHash[state.subscriptionId] = sub.hash;
        this.trySend(state.subscriptionId, {
            op: 'resync-table',
            'subscription-id': state.subscriptionId,
            'tx-id': txId,
            token: state.token
        });
    }
    sendRemove(state, keepSubscription) {
        this.trySend((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
            op: 'remove-sync',
            'subscription-id': state.subscriptionId,
            'keep-subscription': keepSubscription
        });
    }
    async initSubscription(query, hash, cb) {
        // Wait for storage to load so that we know if we already have an existing subscription
        await this.subs.waitForKeyToLoad(hash);
        const existingSub = this.subs.currentValue[hash];
        if (existingSub && existingSub.state && existingSub.state.txId) {
            this.sendResync(existingSub, existingSub.state, existingSub.state.txId);
            if (existingSub.values?.entities && cb) {
                cb({
                    type: CallbackEventType.LoadFromStorage,
                    data: subData(existingSub, existingSub.values?.entities)
                });
            }
            return;
        }
        const table = Object.keys(query)[0];
        const orderBy = query[table]?.$?.order || {
            serverCreatedAt: 'asc'
        };
        const [orderField, orderDirection] = Object.entries(orderBy)[0];
        this.subs.updateInPlace((prev)=>{
            prev[hash] = {
                query,
                hash: hash,
                table,
                orderDirection,
                orderField,
                createdAt: Date.now(),
                updatedAt: Date.now()
            };
        });
        this.sendStart(query);
    }
    async flushPending() {
        for (const hash of Object.keys(this.callbacks)){
            await this.subs.waitForKeyToLoad(hash);
            const sub = this.subs.currentValue[hash];
            if (sub) {
                await this.initSubscription(sub.query, sub.hash);
            } else {
                this.log.error('Missing sub for hash in flushPending', hash);
            }
        }
    }
    onStartSyncOk(msg) {
        const subscriptionId = msg['subscription-id'];
        const q = msg.q;
        const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
        this.idToHash[subscriptionId] = hash;
        this.subs.updateInPlace((prev)=>{
            const sub = prev[hash];
            if (!sub) {
                this.log.error('Missing sub for hash', hash, 'subscription-id', subscriptionId, 'query', q);
                return prev;
            }
            sub.state = {
                subscriptionId: subscriptionId,
                token: msg.token
            };
        });
    }
    notifyCbs(hash, event) {
        for (const cb of this.callbacks[hash] || []){
            cb(event);
        }
    }
    onSyncLoadBatch(msg) {
        const subscriptionId = msg['subscription-id'];
        const joinRows = msg['join-rows'];
        const hash = this.idToHash[subscriptionId];
        if (!hash) {
            this.log.error('Missing hash for subscription', msg);
            return;
        }
        const batch = [];
        const sub = this.subs.currentValue[hash];
        if (!sub) {
            this.log.error('Missing sub for hash', hash, msg);
            return;
        }
        const values = sub.values ?? {
            entities: [],
            attrsStore: this.getAttrs()
        };
        sub.values = values;
        const entities = values.entities;
        for (const entRows of joinRows){
            const store = this.createStore(entRows);
            const entity = queryEntity(sub, store, values.attrsStore);
            entities.push({
                store,
                entity,
                serverCreatedAt: getServerCreatedAt(sub, store, values.attrsStore, entity.id)
            });
            batch.push(entity);
        }
        this.subs.updateInPlace((prev)=>{
            prev[hash] = sub;
            // Make sure we write a field or mutative won't
            // see the change because sub === prev[hash]
            prev[hash].updatedAt = Date.now();
        });
        if (sub.values) {
            this.notifyCbs(hash, {
                type: CallbackEventType.InitialSyncBatch,
                data: subData(sub, sub.values.entities),
                batch
            });
        }
    }
    onSyncInitFinish(msg) {
        const subscriptionId = msg['subscription-id'];
        const hash = this.idToHash[subscriptionId];
        if (!hash) {
            this.log.error('Missing hash for subscription', msg);
            return;
        }
        this.subs.updateInPlace((prev)=>{
            const sub = prev[hash];
            if (!sub) {
                this.log.error('Missing sub for hash', hash, msg);
                return;
            }
            const state = sub.state;
            if (!state) {
                this.log.error('Sub never set init, missing result', sub, msg);
                return prev;
            }
            state.txId = msg['tx-id'];
            sub.updatedAt = Date.now();
        });
        const sub = this.subs.currentValue[hash];
        if (sub) {
            this.notifyCbs(hash, {
                type: CallbackEventType.InitialSyncComplete,
                data: subData(sub, sub.values?.entities || [])
            });
        }
    }
    onSyncUpdateTriples(msg) {
        const subscriptionId = msg['subscription-id'];
        const hash = this.idToHash[subscriptionId];
        if (!hash) {
            this.log.error('Missing hash for subscription', msg);
            return;
        }
        const sub = this.subs.currentValue[hash];
        if (!sub) {
            this.log.error('Missing sub for hash', hash, msg);
            return;
        }
        const state = sub.state;
        if (!state) {
            this.log.error('Missing state for sub', sub, msg);
            return;
        }
        for (const tx of msg.txes){
            if (state.txId && state.txId >= tx['tx-id']) {
                continue;
            }
            state.txId = tx['tx-id'];
            const idxesToDelete = [];
            // Note: this won't work as well when links are involved
            const byEid = {};
            for (const change of tx.changes){
                const eidChanges = byEid[change.triple[0]] ?? [];
                byEid[change.triple[0]] = eidChanges;
                eidChanges.push(change);
            }
            const values = sub.values ?? {
                entities: [],
                attrsStore: this.getAttrs()
            };
            const entities = values.entities;
            sub.values = values;
            const updated = [];
            // Update the existing stores, if we already know about this entity
            eidLoop: for (const [eid, changes] of Object.entries(byEid)){
                for(let i = 0; i < entities.length; i++){
                    const ent = entities[i];
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasEntity"](ent.store, eid)) {
                        applyChangesToStore(ent.store, values.attrsStore, changes);
                        const entity = queryEntity(sub, ent.store, values.attrsStore);
                        const changedFields = changedFieldsOfChanges(ent.store, values.attrsStore, changes)[eid];
                        if (entity) {
                            updated.push({
                                oldEntity: ent.entity,
                                newEntity: entity,
                                changedFields: changedFields || {}
                            });
                            ent.entity = entity;
                        } else {
                            idxesToDelete.push(i);
                        }
                        delete byEid[eid];
                        continue eidLoop;
                    }
                }
            }
            const added = [];
            // If we have anything left in byEid, then this must be a new entity we don't know about
            for (const [_eid, changes] of Object.entries(byEid)){
                const store = this.createStore([]);
                applyChangesToStore(store, values.attrsStore, changes);
                const entity = queryEntity(sub, store, values.attrsStore);
                if (!entity) {
                    this.log.error('No entity found after applying change', {
                        sub,
                        changes,
                        store
                    });
                    continue;
                }
                entities.push({
                    store,
                    entity,
                    serverCreatedAt: getServerCreatedAt(sub, store, values.attrsStore, entity.id)
                });
                added.push(entity);
            }
            const removed = [];
            for (const idx of idxesToDelete.sort().reverse()){
                removed.push(entities[idx].entity);
                entities.splice(idx, 1);
            }
            const orderFieldType = orderFieldTypeMutative(sub, this.getAttrs);
            sortEntitiesInPlace(sub, orderFieldType, entities);
            this.notifyCbs(hash, {
                type: CallbackEventType.SyncTransaction,
                data: subData(sub, sub.values?.entities),
                added,
                removed,
                updated
            });
        }
        this.subs.updateInPlace((prev)=>{
            prev[hash] = sub;
            // Make sure we write a field or mutative won't
            // see the change because sub === prev[hash]
            prev[hash].updatedAt = Date.now();
        });
    }
    clearSubscriptionData(subscriptionId, keepSubscription) {
        const hash = this.idToHash[subscriptionId];
        if (hash) {
            delete this.idToHash[subscriptionId];
            const sub = this.subs.currentValue[hash];
            if (sub.state) {
                this.sendRemove(sub.state, keepSubscription);
            }
            if (keepSubscription) {
                this.subs.unloadKey(hash);
            } else {
                this.subs.updateInPlace((prev)=>{
                    delete prev[hash];
                });
            }
            if (sub) {
                return sub;
            }
        }
    }
    onStartSyncError(msg) {
        const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(msg['original-event']['q']);
        const error = {
            message: msg.message || 'Uh-oh, something went wrong. Ping Joe & Stopa.',
            status: msg.status,
            type: msg.type,
            hint: msg.hint
        };
        const k = Object.keys(msg['original-event']['q'])[0];
        this.notifyCbs(hash, {
            type: CallbackEventType.Error,
            data: {
                [k]: []
            },
            error
        });
    }
    onResyncError(msg) {
        // Clear the subscription and start from scrath on any resync error
        // This can happen if the auth changed and we need to refetch with the
        // new auth or if the subscription is too far behind.
        const subscriptionId = msg['original-event']['subscription-id'];
        const removedSub = this.clearSubscriptionData(subscriptionId, false);
        if (removedSub) {
            this.initSubscription(removedSub.query, removedSub.hash);
        }
    }
} //# sourceMappingURL=SyncTable.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/Stream.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InstantStream",
    ()=>InstantStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/id.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$Reactor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/Reactor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/InstantError.js [app-client] (ecmascript)");
;
;
;
function createWriteStream({ WStream, opts, startStream, appendStream, registerStream }) {
    const clientId = opts.clientId;
    let streamId_ = null;
    let controller_ = null;
    const reconnectToken = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
    let isDone = false;
    let closed = false;
    const closeCbs = [];
    const streamIdCbs = [];
    const completeCbs = [];
    let disconnected = false;
    // Chunks that we haven't been notified are flushed to disk
    let bufferOffset = 0;
    let bufferByteSize = 0;
    const buffer = [];
    const encoder = new TextEncoder();
    function markClosed() {
        closed = true;
        for (const cb of closeCbs){
            cb();
        }
    }
    function addCloseCb(cb) {
        closeCbs.push(cb);
        return ()=>{
            const i = closeCbs.indexOf(cb);
            if (i !== -1) {
                closeCbs.splice(i, 1);
            }
        };
    }
    function addCompleteCb(cb) {
        completeCbs.push(cb);
        return ()=>{
            const i = completeCbs.indexOf(cb);
            if (i !== -1) {
                completeCbs.splice(i, 1);
            }
        };
    }
    if (opts.waitUntil) {
        opts.waitUntil(new Promise((resolve)=>{
            completeCbs.push(resolve);
        }));
    }
    function runCompleteCbs() {
        for (const cb of completeCbs){
            try {
                // cb could be provided by the user in the waitUntil,
                // so protect against errors.
                cb();
            } catch (_e) {}
        }
    }
    function addStreamIdCb(cb) {
        streamIdCbs.push(cb);
        return ()=>{
            const i = streamIdCbs.indexOf(cb);
            if (i !== -1) {
                streamIdCbs.splice(i, 1);
            }
        };
    }
    function setStreamId(streamId) {
        streamId_ = streamId;
        for (const cb of streamIdCbs){
            cb(streamId_);
        }
    }
    function onDisconnect() {
        disconnected = true;
    }
    // Clears data from our buffer after it has been flushed to a file
    function discardFlushed(offset) {
        let chunkOffset = bufferOffset;
        let segmentsToDrop = 0;
        let droppedSegmentsByteLen = 0;
        for (const { byteLen } of buffer){
            const nextChunkOffset = chunkOffset + byteLen;
            if (nextChunkOffset > offset) {
                break;
            }
            chunkOffset = nextChunkOffset;
            segmentsToDrop++;
            droppedSegmentsByteLen += byteLen;
        }
        if (segmentsToDrop > 0) {
            bufferOffset += droppedSegmentsByteLen;
            bufferByteSize -= droppedSegmentsByteLen;
            buffer.splice(0, segmentsToDrop);
        }
    }
    function error(controller, e) {
        markClosed();
        controller.error(e);
        runCompleteCbs();
    }
    async function onConnectionReconnect() {
        const result = await startStream({
            clientId,
            reconnectToken,
            ruleParams: opts.ruleParams
        });
        switch(result.type){
            case 'ok':
                {
                    const { streamId, offset } = result;
                    streamId_ = streamId;
                    discardFlushed(offset);
                    if (buffer.length) {
                        appendStream({
                            streamId: streamId,
                            chunks: buffer.map((b)=>b.chunk),
                            offset: bufferOffset
                        });
                    }
                    disconnected = false;
                    break;
                }
            case 'disconnect':
                {
                    onDisconnect();
                    break;
                }
            case 'error':
                {
                    if (controller_) {
                        error(controller_, result.error);
                    }
                    break;
                }
        }
    }
    // When the append fails, we'll just try to reconnect and start again
    function onAppendFailed() {
        onDisconnect();
        onConnectionReconnect();
    }
    function onFlush({ offset, done }) {
        discardFlushed(offset);
        if (done) {
            isDone = true;
            runCompleteCbs();
        }
    }
    function ensureSetup(controller) {
        if (isDone) {
            error(controller, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantError"]('Stream has been closed.'));
            return null;
        }
        if (!streamId_) {
            error(controller, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantError"]('Stream has not been initialized.'));
            return null;
        }
        return streamId_;
    }
    async function start(controller) {
        controller_ = controller;
        let tryAgain = true;
        let attempts = 0;
        while(tryAgain){
            // rate-limit after the first few failed connects
            let nextAttempt = Date.now() + Math.min(15000, 500 * (attempts - 1));
            tryAgain = false;
            const result = await startStream({
                clientId: opts.clientId,
                reconnectToken,
                ruleParams: opts.ruleParams
            });
            switch(result.type){
                case 'ok':
                    {
                        const { streamId, offset } = result;
                        if (offset !== 0) {
                            const e = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantError"]('Write stream is corrupted');
                            error(controller, e);
                            return;
                        }
                        setStreamId(streamId);
                        registerStream(streamId, {
                            onDisconnect,
                            onFlush,
                            onConnectionReconnect,
                            onAppendFailed
                        });
                        disconnected = false;
                        return;
                    }
                case 'disconnect':
                    {
                        tryAgain = true;
                        onDisconnect();
                        attempts++;
                        await new Promise((resolve)=>{
                            // Try again immediately for the first two attempts, then back off
                            setTimeout(resolve, nextAttempt - Date.now());
                        });
                        break;
                    }
                case 'error':
                    {
                        error(controller, result.error);
                        return;
                    }
            }
        }
    }
    class WStreamEnhanced extends WStream {
        constructor(sink, strategy){
            super(sink, strategy);
        }
        async streamId() {
            if (streamId_) {
                return streamId_;
            }
            return new Promise((resolve, reject)=>{
                const cleanupFns = [];
                const cleanup = ()=>{
                    for (const f of cleanupFns){
                        f();
                    }
                };
                const resolveCb = (streamId)=>{
                    resolve(streamId);
                    cleanup();
                };
                const rejectCb = ()=>{
                    reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantError"]('Stream is closed.'));
                    cleanup();
                };
                cleanupFns.push(addStreamIdCb(resolveCb));
                cleanupFns.push(addCloseCb(rejectCb));
            });
        }
    }
    const stream = new WStreamEnhanced({
        // TODO(dww): accept a storage so that write streams can survive across
        //            browser restarts
        async start (controller) {
            try {
                await start(controller);
            } catch (e) {
                error(controller, e);
            }
        },
        write (chunk, controller) {
            const streamId = ensureSetup(controller);
            if (streamId) {
                const byteLen = encoder.encode(chunk).length;
                buffer.push({
                    chunk,
                    byteLen
                });
                const offset = bufferOffset + bufferByteSize;
                bufferByteSize += byteLen;
                if (!disconnected) {
                    appendStream({
                        streamId,
                        chunks: [
                            chunk
                        ],
                        offset
                    });
                }
            }
        },
        close () {
            if (streamId_) {
                appendStream({
                    streamId: streamId_,
                    chunks: [],
                    offset: bufferOffset + bufferByteSize,
                    isDone: true
                });
            } else {
                runCompleteCbs();
            }
            markClosed();
        },
        abort (reason) {
            if (streamId_) {
                appendStream({
                    streamId: streamId_,
                    chunks: [],
                    offset: bufferOffset + bufferByteSize,
                    isDone: true,
                    abortReason: reason
                });
            } else {
                runCompleteCbs();
            }
            markClosed();
        }
    });
    return {
        stream,
        addCompleteCb,
        closed () {
            return closed;
        }
    };
}
class StreamIterator {
    items = [];
    resolvers = [];
    isClosed = false;
    constructor(){}
    push(item) {
        if (this.isClosed) return;
        const resolve = this.resolvers.shift();
        if (resolve) {
            resolve({
                value: item,
                done: false
            });
        } else {
            this.items.push(item);
        }
    }
    close() {
        this.isClosed = true;
        while(this.resolvers.length > 0){
            const resolve = this.resolvers.shift();
            resolve({
                value: undefined,
                done: true
            });
        }
    }
    async *[Symbol.asyncIterator]() {
        while(true){
            if (this.items.length > 0) {
                yield this.items.shift();
            } else if (this.isClosed) {
                return;
            } else {
                const { value, done } = await new Promise((resolve)=>{
                    this.resolvers.push(resolve);
                });
                if (done || !value) {
                    return;
                }
                yield value;
            }
        }
    }
}
function createReadStream({ RStream, opts, startStream, cancelStream }) {
    let seenOffset = opts.byteOffset || 0;
    let canceled = false;
    const decoder = new TextDecoder('utf-8');
    const encoder = new TextEncoder();
    let eventId;
    let closed = false;
    const closeCbs = [];
    function markClosed() {
        closed = true;
        for (const cb of closeCbs){
            cb();
        }
    }
    function addCloseCb(cb) {
        closeCbs.push(cb);
        return ()=>{
            const i = closeCbs.indexOf(cb);
            if (i !== -1) {
                closeCbs.splice(i, 1);
            }
        };
    }
    function error(controller, e) {
        controller.error(e);
        markClosed();
    }
    let fetchFailures = 0;
    async function runStartStream(opts, controller) {
        eventId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
        const streamOpts = {
            ...opts || {},
            eventId
        };
        for await (const item of startStream(streamOpts)){
            if (canceled) {
                return;
            }
            if (item.type === 'reconnect') {
                return {
                    retry: true
                };
            }
            if (item.type === 'error') {
                error(controller, item.error);
                return;
            }
            if (item.offset > seenOffset) {
                error(controller, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantError"]('Stream is corrupted.'));
                canceled = true;
                return;
            }
            let discardLen = seenOffset - item.offset;
            if (item.files && item.files.length) {
                const fetchAbort = new AbortController();
                let nextFetch = fetch(item.files[0].url, {
                    signal: fetchAbort.signal
                });
                for(let i = 0; i < item.files.length; i++){
                    const nextFile = item.files[i + 1];
                    const thisFetch = nextFetch;
                    const res = await thisFetch;
                    if (nextFile) {
                        nextFetch = fetch(nextFile.url, {
                            signal: fetchAbort.signal
                        });
                    }
                    if (!res.ok) {
                        fetchFailures++;
                        if (fetchFailures > 10) {
                            error(controller, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantError"]('Unable to process stream.'));
                            return;
                        }
                        return {
                            retry: true
                        };
                    }
                    if (res.body) {
                        for await (const bodyChunk of res.body){
                            if (canceled) {
                                fetchAbort.abort();
                                return;
                            }
                            let chunk = bodyChunk;
                            if (discardLen > 0) {
                                chunk = bodyChunk.subarray(discardLen);
                                discardLen -= bodyChunk.length - chunk.length;
                            }
                            if (!chunk.length) {
                                continue;
                            }
                            seenOffset += chunk.length;
                            const s = decoder.decode(chunk);
                            controller.enqueue(s);
                        }
                    } else {
                        // RN doesn't support request.body
                        const bodyChunk = await res.arrayBuffer();
                        let chunk = bodyChunk;
                        if (canceled) {
                            fetchAbort.abort();
                            return;
                        }
                        if (discardLen > 0) {
                            chunk = new Uint8Array(bodyChunk).subarray(discardLen);
                            discardLen -= bodyChunk.byteLength - chunk.length;
                        }
                        if (!chunk.byteLength) {
                            continue;
                        }
                        seenOffset += chunk.byteLength;
                        const s = decoder.decode(chunk);
                        controller.enqueue(s);
                    }
                }
            }
            fetchFailures = 0;
            if (item.content) {
                let content = item.content;
                let encoded = encoder.encode(item.content);
                if (discardLen > 0) {
                    const remaining = encoded.subarray(discardLen);
                    discardLen -= encoded.length - remaining.length;
                    if (!remaining.length) {
                        continue;
                    }
                    encoded = remaining;
                    content = decoder.decode(remaining);
                }
                seenOffset += encoded.length;
                controller.enqueue(content);
            }
        }
    }
    async function start(controller) {
        let retry = true;
        let attempts = 0;
        while(retry){
            retry = false;
            let nextAttempt = Date.now() + Math.min(15000, 500 * (attempts - 1));
            const res = await runStartStream({
                ...opts,
                offset: seenOffset
            }, controller);
            if (res?.retry) {
                retry = true;
                attempts++;
                if (nextAttempt < Date.now() - 300000) {
                    // reset attempts if we last tried 5 minutes ago
                    attempts = 0;
                }
                await new Promise((resolve)=>{
                    setTimeout(resolve, nextAttempt - Date.now());
                });
            }
        }
        if (!canceled && !closed) {
            controller.close();
            markClosed();
        }
    }
    const stream = new RStream({
        start (controller) {
            start(controller);
        },
        cancel (_reason) {
            canceled = true;
            if (eventId) {
                cancelStream({
                    eventId
                });
            }
            markClosed();
        }
    });
    return {
        stream,
        addCloseCb,
        closed () {
            return closed;
        }
    };
}
class InstantStream {
    trySend;
    WStream;
    RStream;
    writeStreams = {};
    startWriteStreamCbs = {};
    readStreamIterators = {};
    log;
    activeStreams = new Set();
    constructor({ WStream, RStream, trySend, log }){
        this.WStream = WStream;
        this.RStream = RStream;
        this.trySend = trySend;
        this.log = log;
    }
    createWriteStream(opts) {
        const { stream, addCompleteCb } = createWriteStream({
            WStream: this.WStream,
            startStream: this.startWriteStream.bind(this),
            appendStream: this.appendStream.bind(this),
            registerStream: this.registerWriteStream.bind(this),
            opts
        });
        this.activeStreams.add(stream);
        addCompleteCb(()=>{
            this.activeStreams.delete(stream);
        });
        return stream;
    }
    createReadStream(opts) {
        const { stream, addCloseCb } = createReadStream({
            RStream: this.RStream,
            opts,
            startStream: this.startReadStream.bind(this),
            cancelStream: this.cancelReadStream.bind(this)
        });
        this.activeStreams.add(stream);
        addCloseCb(()=>{
            this.activeStreams.delete(stream);
        });
        return stream;
    }
    startWriteStream(opts) {
        const eventId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
        let resolve = null;
        const promise = new Promise((r)=>{
            resolve = r;
        });
        this.startWriteStreamCbs[eventId] = resolve;
        const msg = {
            op: 'start-stream',
            'client-id': opts.clientId,
            'reconnect-token': opts.reconnectToken
        };
        if (opts.ruleParams) {
            msg['rule-params'] = opts.ruleParams;
        }
        this.trySend(eventId, msg);
        return promise;
    }
    registerWriteStream(streamId, cbs) {
        this.writeStreams[streamId] = cbs;
    }
    appendStream({ streamId, chunks, isDone, offset, abortReason }) {
        const msg = {
            op: 'append-stream',
            'stream-id': streamId,
            chunks,
            offset,
            done: !!isDone
        };
        if (abortReason) {
            msg['abort-reason'] = abortReason;
        }
        this.trySend((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), msg);
    }
    onAppendFailed(msg) {
        const cbs = this.writeStreams[msg['stream-id']];
        if (cbs) {
            cbs.onAppendFailed();
        }
    }
    onStartStreamOk(msg) {
        const cb = this.startWriteStreamCbs[msg['client-event-id']];
        if (!cb) {
            this.log.info('No stream for start-stream-ok', msg);
            return;
        }
        cb({
            type: 'ok',
            streamId: msg['stream-id'],
            offset: msg.offset
        });
        delete this.startWriteStreamCbs[msg['client-event-id']];
    }
    onStreamFlushed(msg) {
        const streamId = msg['stream-id'];
        const cbs = this.writeStreams[streamId];
        if (!cbs) {
            this.log.info('No stream cbs for stream-flushed', msg);
            return;
        }
        cbs.onFlush({
            offset: msg.offset,
            done: msg.done
        });
        if (msg.done) {
            delete this.writeStreams[streamId];
        }
    }
    startReadStream({ eventId, clientId, streamId, offset, ruleParams }) {
        const msg = {
            op: 'subscribe-stream'
        };
        if (!streamId && !clientId) {
            throw new Error('Must provide one of streamId or clientId to subscribe to the stream.');
        }
        if (streamId) {
            msg['stream-id'] = streamId;
        }
        if (clientId) {
            msg['client-id'] = clientId;
        }
        if (offset) {
            msg['offset'] = offset;
        }
        if (ruleParams) {
            msg['rule-params'] = ruleParams;
        }
        const iterator = new StreamIterator();
        this.readStreamIterators[eventId] = iterator;
        this.trySend(eventId, msg);
        return iterator;
    }
    cancelReadStream({ eventId }) {
        const msg = {
            op: 'unsubscribe-stream',
            'subscribe-event-id': eventId
        };
        this.trySend((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), msg);
        delete this.readStreamIterators[eventId];
    }
    onStreamAppend(msg) {
        const eventId = msg['client-event-id'];
        const iterator = this.readStreamIterators[eventId];
        if (!iterator) {
            this.log.info('No iterator for read stream', msg);
            return;
        }
        if (msg.error) {
            if (msg.retry) {
                iterator.push({
                    type: 'reconnect'
                });
            } else {
                iterator.push({
                    type: 'error',
                    error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantError"](msg.error)
                });
            }
            iterator.close();
            delete this.readStreamIterators[eventId];
            return;
        }
        if (msg.files?.length || msg.content) {
            iterator.push({
                type: 'append',
                offset: msg.offset,
                files: msg.files,
                content: msg.content
            });
        }
        if (msg.done) {
            iterator.close();
            delete this.readStreamIterators[eventId];
        }
    }
    onConnectionStatusChange(status) {
        // Tell the writers to retry:
        for (const cb of Object.values(this.startWriteStreamCbs)){
            cb({
                type: 'disconnect'
            });
        }
        this.startWriteStreamCbs = {};
        if (status !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$Reactor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["STATUS"].AUTHENTICATED) {
            // Notify the writers that they've been disconnected
            for (const { onDisconnect } of Object.values(this.writeStreams)){
                onDisconnect();
            }
        } else {
            // Notify the writers that they need to reconnect
            for (const { onConnectionReconnect } of Object.values(this.writeStreams)){
                onConnectionReconnect();
            }
            // Notify the readers that they need to reconnect
            for (const iterator of Object.values(this.readStreamIterators)){
                iterator.push({
                    type: 'reconnect'
                });
                iterator.close();
            }
            this.readStreamIterators = {};
        }
    }
    onRecieveError(msg) {
        const ev = msg['original-event'];
        switch(ev.op){
            case 'append-stream':
                {
                    const streamId = ev['stream-id'];
                    const cbs = this.writeStreams[streamId];
                    cbs?.onAppendFailed();
                    break;
                }
            case 'start-stream':
                {
                    const eventId = msg['client-event-id'];
                    const cb = this.startWriteStreamCbs[eventId];
                    if (cb) {
                        cb({
                            type: 'error',
                            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantError"](msg.message || 'Unknown error', msg.hint)
                        });
                        delete this.startWriteStreamCbs[eventId];
                    }
                    break;
                }
            case 'subscribe-stream':
                {
                    const eventId = msg['client-event-id'];
                    const iterator = this.readStreamIterators[eventId];
                    if (iterator) {
                        iterator.push({
                            type: 'error',
                            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantError"](msg.message || 'Unknown error', msg.hint)
                        });
                        iterator.close();
                        delete this.readStreamIterators[eventId];
                    }
                    break;
                }
            case 'unsubscribe-stream':
                {
                    break;
                }
        }
    }
    hasActiveStreams() {
        return this.activeStreams.size > 0;
    }
} //# sourceMappingURL=Stream.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/Reactor.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "STATUS",
    ()=>STATUS,
    "default",
    ()=>Reactor
]);
// @ts-check
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/weakHash.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instaql$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/instaql.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instaml$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/instaml.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/store.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/id.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$IndexedDBStorage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/IndexedDBStorage.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$WindowNetworkListener$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/WindowNetworkListener.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/authAPI.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$StorageAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/StorageAPI.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$flags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/flags.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$presence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/presence.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$Deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/Deferred.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/PersistedObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$model$2f$instaqlResult$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/model/instaqlResult.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/object.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$linkIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/linkIndex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/version.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mutative/dist/mutative.esm.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/log.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$queryValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/queryValidation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$transactionValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/transactionValidation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/InstantError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/fetch.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__validate$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/validate.js [app-client] (ecmascript) <export default as validate>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$Connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/Connection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$SyncTable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/SyncTable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$Stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/Stream.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const STATUS = {
    CONNECTING: 'connecting',
    OPENED: 'opened',
    AUTHENTICATED: 'authenticated',
    CLOSED: 'closed',
    ERRORED: 'errored'
};
const QUERY_ONCE_TIMEOUT = 30_000;
const PENDING_TX_CLEANUP_TIMEOUT = 30_000;
const PENDING_MUTATION_CLEANUP_THRESHOLD = 200;
const ONE_MIN_MS = 1_000 * 60;
const defaultConfig = {
    apiURI: 'https://api.instantdb.com',
    websocketURI: 'wss://api.instantdb.com/runtime/session'
};
// Param that the backend adds if this is an oauth redirect
const OAUTH_REDIRECT_PARAM = '_instant_oauth_redirect';
const currentUserKey = `currentUser`;
/**
 * @param {Object} config
 * @param {TransportType} config.transportType
 * @param {string} config.appId
 * @param {string} config.apiURI
 * @param {string} config.wsURI
 * @param {EventSourceConstructor} config.EventSourceImpl
 * @returns {WSConnection | SSEConnection}
 */ function createTransport({ transportType, appId, apiURI, wsURI, EventSourceImpl }) {
    if (!EventSourceImpl) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$Connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WSConnection"](`${wsURI}?app_id=${appId}`);
    }
    switch(transportType){
        case 'ws':
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$Connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WSConnection"](`${wsURI}?app_id=${appId}`);
        case 'sse':
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$Connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SSEConnection"](EventSourceImpl, `${apiURI}/runtime/sse?app_id=${appId}`);
        default:
            throw new Error('Unknown transport type ' + transportType);
    }
}
function isClient() {
    const hasWindow = typeof window !== 'undefined';
    // this checks if we are running in a chrome extension
    // @ts-expect-error
    const isChrome = typeof chrome !== 'undefined';
    return hasWindow || isChrome;
}
const ignoreLogging = {
    'set-presence': true,
    'set-presence-ok': true,
    'refresh-presence': true,
    'patch-presence': true
};
/**
 * @param {QuerySubInStorage} x
 * @param {boolean | null} useDateObjects
 * @returns {QuerySub}
 */ function querySubFromStorage(x, useDateObjects) {
    const v = typeof x === 'string' ? JSON.parse(x) : x;
    if (v?.result?.store) {
        const attrsStore = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attrsStoreFromJSON"](v.result.attrsStore, v.result.store);
        if (attrsStore) {
            const storeJSON = v.result.store;
            v.result.store = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromJSON"](attrsStore, {
                ...storeJSON,
                useDateObjects: useDateObjects
            });
            v.result.attrsStore = attrsStore;
        }
    }
    return v;
}
/**
 *
 * @param {string} _key
 * @param {QuerySub} sub
 * @returns QuerySubInStorage
 */ function querySubToStorage(_key, sub) {
    const { result, ...rest } = sub;
    const jsonSub = rest;
    if (result) {
        /** @type {import('./reactorTypes.ts').QuerySubResultInStorage} */ const jsonResult = {
            ...result,
            store: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toJSON"](result.store),
            attrsStore: result.attrsStore.toJSON()
        };
        jsonSub.result = jsonResult;
    }
    return jsonSub;
}
function kvFromStorage(key, x) {
    switch(key){
        case 'pendingMutations':
            return new Map(typeof x === 'string' ? JSON.parse(x) : x);
        default:
            return x;
    }
}
function kvToStorage(key, x) {
    switch(key){
        case 'pendingMutations':
            return [
                ...x.entries()
            ];
        default:
            return x;
    }
}
function onMergeQuerySub(_k, storageSub, inMemorySub) {
    const storageResult = storageSub?.result;
    const memoryResult = inMemorySub?.result;
    if (storageResult && !memoryResult && inMemorySub) {
        inMemorySub.result = storageResult;
    }
    return inMemorySub || storageSub;
}
function sortedMutationEntries(entries) {
    return [
        ...entries
    ].sort((a, b)=>{
        const [ka, muta] = a;
        const [kb, mutb] = b;
        const a_order = muta.order || 0;
        const b_order = mutb.order || 0;
        if (a_order == b_order) {
            return ka < kb ? -1 : ka > kb ? 1 : 0;
        }
        return a_order - b_order;
    });
}
class Reactor {
    /** @type {s.AttrsStore | undefined} */ attrs;
    _isOnline = true;
    _isShutdown = false;
    status = STATUS.CONNECTING;
    /** @type {PersistedObject<string, QuerySub, QuerySubInStorage>} */ querySubs;
    /** @type {PersistedObject} */ kv;
    /** @type {SyncTable} */ _syncTable;
    /** @type {InstantStream} */ _instantStream;
    /** @type {Record<string, Array<{ q: any, cb: (data: any) => any }>>} */ queryCbs = {};
    /** @type {Record<string, Array<{ q: any, eventId: string, dfd: Deferred }>>} */ queryOnceDfds = {};
    authCbs = [];
    attrsCbs = [];
    mutationErrorCbs = [];
    connectionStatusCbs = [];
    config;
    mutationDeferredStore = new Map();
    _reconnectTimeoutId = null;
    _reconnectTimeoutMs = 0;
    /** @type {Connection} */ _transport;
    /** @type {TransportType} */ _transportType = 'ws';
    /** @type {EventSourceConstructor} */ _EventSource;
    /** @type {boolean | null} */ _wsOk = null;
    _localIdPromises = {};
    _errorMessage = null;
    /** @type {Promise<null | {error: {message: string}}> | null}**/ _oauthCallbackResponse = null;
    /** @type {null | import('./utils/linkIndex.ts').LinkIndex}} */ _linkIndex = null;
    /** @type BroadcastChannel | undefined */ _broadcastChannel;
    /** @type {Record<string, {roomType: string; isConnected: boolean; error: any}>} */ _rooms = {};
    /** @type {Record<string, boolean>} */ _roomsPendingLeave = {};
    _presence = {};
    _broadcastQueue = [];
    _broadcastSubs = {};
    /** @type {{isLoading: boolean; error: any | undefined, user: any | undefined}} */ _currentUserCached = {
        isLoading: true,
        error: undefined,
        user: undefined
    };
    _beforeUnloadCbs = [];
    _dataForQueryCache = {};
    /** @type {Logger} */ _log;
    _pendingTxCleanupTimeout;
    _pendingMutationCleanupThreshold;
    _inFlightMutationEventIds = new Set();
    constructor(config, Storage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$IndexedDBStorage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], NetworkListener = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$WindowNetworkListener$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], versions, EventSourceConstructor){
        this._EventSource = EventSourceConstructor;
        this.config = {
            ...defaultConfig,
            ...config
        };
        this.queryCacheLimit = this.config.queryCacheLimit ?? 10;
        this._pendingTxCleanupTimeout = this.config.pendingTxCleanupTimeout ?? PENDING_TX_CLEANUP_TIMEOUT;
        this._pendingMutationCleanupThreshold = this.config.pendingMutationCleanupThreshold ?? PENDING_MUTATION_CLEANUP_THRESHOLD;
        this._log = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$log$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(config.verbose || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$flags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["devBackend"] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$flags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["instantLogs"], ()=>this._reactorStats());
        this.versions = {
            ...versions || {},
            '@instantdb/core': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
        };
        if (this.config.schema) {
            this._linkIndex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$linkIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLinkIndex"])(this.config.schema);
        }
        // This is to protect us against running
        // server-side.
        if (!isClient()) {
            return;
        }
        if (!config.appId) {
            throw new Error('Instant must be initialized with an appId.');
        }
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$validate$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__validate$3e$__["validate"])(config.appId)) {
            throw new Error(`Instant must be initialized with a valid appId. \`${config.appId}\` is not a valid uuid.`);
        }
        if (typeof BroadcastChannel === 'function') {
            this._broadcastChannel = new BroadcastChannel('@instantdb');
            this._broadcastChannel.addEventListener('message', async (e)=>{
                try {
                    if (e.data?.type === 'auth') {
                        const res = await this.getCurrentUser();
                        await this.updateUser(res.user).catch((error)=>{
                            this._log.error('[error] update user', error);
                        });
                    }
                } catch (e) {
                    this._log.error('[error] handle broadcast channel', e);
                }
            });
        }
        this._initStorage(Storage);
        this._syncTable = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$SyncTable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SyncTable"](this._trySendAuthed.bind(this), new Storage(this.config.appId, 'syncSubs'), {
            useDateObjects: this.config.useDateObjects
        }, this._log, (triples)=>{
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStore"](this.ensureAttrs(), triples, this.config.enableCardinalityInference, this.config.useDateObjects);
        }, ()=>this.ensureAttrs());
        this._instantStream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$Stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantStream"]({
            WStream: this.config.WritableStream || WritableStream,
            RStream: this.config.ReadableStream || ReadableStream,
            trySend: this._trySendAuthed.bind(this),
            log: this._log
        });
        this._oauthCallbackResponse = this._oauthLoginInit();
        // kick off a request to cache it
        this.getCurrentUser().then((userInfo)=>{
            this.syncUserToEndpoint(userInfo.user);
        });
        setInterval(async ()=>{
            const currentUser = await this.getCurrentUser();
            this.syncUserToEndpoint(currentUser.user);
        }, ONE_MIN_MS);
        NetworkListener.getIsOnline().then((isOnline)=>{
            this._isOnline = isOnline;
            this._startSocket();
            NetworkListener.listen((isOnline)=>{
                // We do this because react native's NetInfo
                // fires multiple online events.
                // We only want to handle one state change
                if (isOnline === this._isOnline) {
                    return;
                }
                this._log.info('[network] online =', isOnline);
                this._isOnline = isOnline;
                if (this._isOnline) {
                    this._startSocket();
                } else {
                    this._log.info('Changing status from', this.status, 'to', STATUS.CLOSED);
                    this._setStatus(STATUS.CLOSED);
                }
            });
        });
        if (typeof addEventListener !== 'undefined') {
            this._beforeUnload = this._beforeUnload.bind(this);
            addEventListener('beforeunload', this._beforeUnload);
        }
    }
    ensureAttrs() {
        if (!this.attrs) {
            throw new Error('attrs have not loaded.');
        }
        return this.attrs;
    }
    updateSchema(schema) {
        this.config = {
            ...this.config,
            schema: schema,
            cardinalityInference: Boolean(schema)
        };
        this._linkIndex = schema ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$linkIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLinkIndex"])(this.config.schema) : null;
    }
    _reactorStats() {
        return {
            inFlightMutationCount: this._inFlightMutationEventIds.size,
            storedMutationCount: this._pendingMutations().size,
            transportType: this._transportType
        };
    }
    _onQuerySubLoaded(hash) {
        this.kv.waitForKeyToLoad('pendingMutations').then(()=>this.notifyOne(hash));
    }
    _initStorage(Storage) {
        this.querySubs = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PersistedObject"]({
            persister: new Storage(this.config.appId, 'querySubs'),
            merge: onMergeQuerySub,
            serialize: querySubToStorage,
            parse: (_key, x)=>querySubFromStorage(x, this.config.useDateObjects),
            // objectSize
            objectSize: (x)=>x?.result?.store?.triples?.length ?? 0,
            logger: this._log,
            preloadEntryCount: 10,
            gc: {
                maxAgeMs: 1000 * 60 * 60 * 24 * 7 * 52,
                maxEntries: 1000,
                // Size of each query is the number of triples
                maxSize: 1_000_000
            }
        });
        this.querySubs.onKeyLoaded = (k)=>this._onQuerySubLoaded(k);
        this.kv = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PersistedObject"]({
            persister: new Storage(this.config.appId, 'kv'),
            merge: this._onMergeKv,
            serialize: kvToStorage,
            parse: kvFromStorage,
            objectSize: ()=>0,
            logger: this._log,
            saveThrottleMs: 100,
            idleCallbackMaxWaitMs: 100,
            // Don't GC the kv store
            gc: null
        });
        this.kv.onKeyLoaded = (k)=>{
            if (k === 'pendingMutations') {
                this.notifyAll();
            }
        };
        // Trigger immediate load for pendingMutations and currentUser
        this.kv.waitForKeyToLoad('pendingMutations');
        this.kv.waitForKeyToLoad(currentUserKey);
        this._beforeUnloadCbs.push(()=>{
            this.kv.flush();
            this.querySubs.flush();
        });
    }
    _beforeUnload() {
        for (const cb of this._beforeUnloadCbs){
            cb();
        }
        this._syncTable.beforeUnload();
    }
    /**
     * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status
     * @param {string} eventId
     * @param {{message?: string, type?: string, status?: number, hint?: unknown}} [errorMsg]
     */ _finishTransaction(status, eventId, errorMsg) {
        const dfd = this.mutationDeferredStore.get(eventId);
        this.mutationDeferredStore.delete(eventId);
        const ok = status !== 'error' && status !== 'timeout';
        if (!dfd && !ok) {
            // console.erroring here, as there are no listeners to let know
            console.error('Mutation failed', {
                status,
                eventId,
                ...errorMsg
            });
        }
        if (!dfd) {
            return;
        }
        if (ok) {
            dfd.resolve({
                status,
                eventId
            });
        } else {
            // Check if error comes from server or client
            if (errorMsg?.type) {
                const { status, ...body } = errorMsg;
                dfd.reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantAPIError"]({
                    // @ts-expect-error body.type is not constant typed
                    body,
                    status: status ?? 0
                }));
            } else {
                dfd.reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantError"](errorMsg?.message || 'Unknown error', errorMsg?.hint));
            }
        }
    }
    _setStatus(status, err) {
        this.status = status;
        this._errorMessage = err;
        this.notifyConnectionStatusSubs(status);
        this._instantStream.onConnectionStatusChange(status);
    }
    _onMergeKv = (key, storageV, inMemoryV)=>{
        switch(key){
            case 'pendingMutations':
                {
                    const storageEntries = storageV?.entries() ?? [];
                    const inMemoryEntries = inMemoryV?.entries() ?? [];
                    const muts = new Map([
                        ...storageEntries,
                        ...inMemoryEntries
                    ]);
                    const rewrittenStorageMuts = storageV ? this._rewriteMutationsSorted(this.attrs, storageV) : [];
                    rewrittenStorageMuts.forEach(([k, mut])=>{
                        if (!inMemoryV?.pendingMutations?.has(k) && !mut['tx-id']) {
                            this._sendMutation(k, mut);
                        }
                    });
                    return muts;
                }
            default:
                return inMemoryV || storageV;
        }
    };
    _flushEnqueuedRoomData(roomId) {
        const enqueuedUserPresence = this._presence[roomId]?.result?.user;
        const enqueuedBroadcasts = this._broadcastQueue[roomId];
        this._broadcastQueue[roomId] = [];
        if (enqueuedUserPresence) {
            this._trySetPresence(roomId, enqueuedUserPresence);
        }
        if (enqueuedBroadcasts) {
            for (const item of enqueuedBroadcasts){
                const { topic, roomType, data } = item;
                this._tryBroadcast(roomId, roomType, topic, data);
            }
        }
    }
    /**
     * Does the same thing as add-query-ok
     * but called as a result of receiving query info from ssr
     * @param {any} q
     * @param {{ triples: any; pageInfo: any; }} result
     * @param {boolean} enableCardinalityInference
     */ _addQueryData(q, result, enableCardinalityInference) {
        if (!this.attrs) {
            throw new Error('Attrs in reactor have not been set');
        }
        const queryHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
        const attrsStore = this.ensureAttrs();
        const store = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStore"](this.attrs, result.triples, enableCardinalityInference, this.config.useDateObjects);
        this.querySubs.updateInPlace((prev)=>{
            prev[queryHash] = {
                result: {
                    store,
                    attrsStore,
                    pageInfo: result.pageInfo,
                    processedTxId: undefined,
                    isExternal: true
                },
                q
            };
        });
        this._cleanupPendingMutationsQueries();
        this.notifyOne(queryHash);
        this.notifyOneQueryOnce(queryHash);
        this._cleanupPendingMutationsTimeout();
    }
    _handleReceive(connId, msg) {
        // opt-out, enabled by default if schema
        const enableCardinalityInference = Boolean(this.config.schema) && ('cardinalityInference' in this.config ? Boolean(this.config.cardinalityInference) : true);
        if (!ignoreLogging[msg.op]) {
            this._log.info('[receive]', connId, msg.op, msg);
        }
        switch(msg.op){
            case 'init-ok':
                {
                    this._setStatus(STATUS.AUTHENTICATED);
                    this._reconnectTimeoutMs = 0;
                    this._setAttrs(msg.attrs);
                    this._flushPendingMessages();
                    // (EPH): set session-id, so we know
                    // which item is us
                    this._sessionId = msg['session-id'];
                    for (const roomId of Object.keys(this._rooms)){
                        const enqueuedUserPresence = this._presence[roomId]?.result?.user;
                        const roomType = this._rooms[roomId]?.roomType;
                        this._tryJoinRoom(roomType, roomId, enqueuedUserPresence);
                    }
                    break;
                }
            case 'add-query-exists':
                {
                    this.notifyOneQueryOnce((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(msg.q));
                    break;
                }
            case 'add-query-ok':
                {
                    const { q, result } = msg;
                    const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
                    if (!this._hasQueryListeners() && !this.querySubs.currentValue[hash]) {
                        break;
                    }
                    const pageInfo = result?.[0]?.data?.['page-info'];
                    const aggregate = result?.[0]?.data?.['aggregate'];
                    const triples = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$model$2f$instaqlResult$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractTriples"])(result);
                    const attrsStore = this.ensureAttrs();
                    const store = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStore"](attrsStore, triples, enableCardinalityInference, this.config.useDateObjects);
                    this.querySubs.updateInPlace((prev)=>{
                        if (!prev[hash]) {
                            this._log.info('Missing value in querySubs', {
                                hash,
                                q
                            });
                            return;
                        }
                        prev[hash].result = {
                            store,
                            attrsStore,
                            pageInfo,
                            aggregate,
                            processedTxId: msg['processed-tx-id']
                        };
                    });
                    this._cleanupPendingMutationsQueries();
                    this.notifyOne(hash);
                    this.notifyOneQueryOnce(hash);
                    this._cleanupPendingMutationsTimeout();
                    break;
                }
            case 'start-sync-ok':
                {
                    this._syncTable.onStartSyncOk(msg);
                    break;
                }
            case 'sync-load-batch':
                {
                    this._syncTable.onSyncLoadBatch(msg);
                    break;
                }
            case 'sync-init-finish':
                {
                    this._syncTable.onSyncInitFinish(msg);
                    break;
                }
            case 'sync-update-triples':
                {
                    this._syncTable.onSyncUpdateTriples(msg);
                    break;
                }
            case 'start-stream-ok':
                {
                    this._instantStream.onStartStreamOk(msg);
                    break;
                }
            case 'stream-flushed':
                {
                    this._instantStream.onStreamFlushed(msg);
                    break;
                }
            case 'append-failed':
                {
                    this._instantStream.onAppendFailed(msg);
                    break;
                }
            case 'stream-append':
                {
                    this._instantStream.onStreamAppend(msg);
                    break;
                }
            case 'refresh-ok':
                {
                    const { computations, attrs } = msg;
                    const processedTxId = msg['processed-tx-id'];
                    if (attrs) {
                        this._setAttrs(attrs);
                    }
                    this._cleanupPendingMutationsTimeout();
                    const rewrittenMutations = this._rewriteMutations(this.ensureAttrs(), this._pendingMutations(), processedTxId);
                    if (rewrittenMutations !== this._pendingMutations()) {
                        // We know we've changed the mutations to fix the attr ids and removed
                        // processed attrs, so we'll persist those changes to prevent optimisticAttrs
                        // from using old attr definitions
                        this.kv.updateInPlace((prev)=>{
                            prev.pendingMutations = rewrittenMutations;
                        });
                    }
                    const mutations = sortedMutationEntries(rewrittenMutations.entries());
                    const updates = computations.map((x)=>{
                        const q = x['instaql-query'];
                        const result = x['instaql-result'];
                        const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
                        const triples = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$model$2f$instaqlResult$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extractTriples"])(result);
                        const attrsStore = this.ensureAttrs();
                        const store = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStore"](attrsStore, triples, enableCardinalityInference, this.config.useDateObjects);
                        const { store: newStore, attrsStore: newAttrsStore } = this._applyOptimisticUpdates(store, attrsStore, mutations, processedTxId);
                        const pageInfo = result?.[0]?.data?.['page-info'];
                        const aggregate = result?.[0]?.data?.['aggregate'];
                        return {
                            q,
                            hash,
                            store: newStore,
                            attrsStore: newAttrsStore,
                            pageInfo,
                            aggregate
                        };
                    });
                    updates.forEach(({ hash, q, store, attrsStore, pageInfo, aggregate })=>{
                        this.querySubs.updateInPlace((prev)=>{
                            if (!prev[hash]) {
                                this._log.error('Missing value in querySubs', {
                                    hash,
                                    q
                                });
                                return;
                            }
                            prev[hash].result = {
                                store,
                                attrsStore,
                                pageInfo,
                                aggregate,
                                processedTxId
                            };
                        });
                    });
                    this._cleanupPendingMutationsQueries();
                    updates.forEach(({ hash })=>{
                        this.notifyOne(hash);
                    });
                    break;
                }
            case 'transact-ok':
                {
                    const { 'client-event-id': eventId, 'tx-id': txId } = msg;
                    this._inFlightMutationEventIds.delete(eventId);
                    const muts = this._rewriteMutations(this.ensureAttrs(), this._pendingMutations());
                    const prevMutation = muts.get(eventId);
                    if (!prevMutation) {
                        break;
                    }
                    // update pendingMutation with server-side tx-id
                    this._updatePendingMutations((prev)=>{
                        prev.set(eventId, {
                            ...prev.get(eventId),
                            'tx-id': txId,
                            confirmed: Date.now()
                        });
                    });
                    const newAttrs = [];
                    for (const step of prevMutation['tx-steps']){
                        if (step[0] === 'add-attr') {
                            const attr = step[1];
                            newAttrs.push(attr);
                        }
                    }
                    if (newAttrs.length) {
                        const existingAttrs = Object.values(this.ensureAttrs().attrs);
                        this._setAttrs([
                            ...existingAttrs,
                            ...newAttrs
                        ]);
                    }
                    this._finishTransaction('synced', eventId);
                    this._cleanupPendingMutationsTimeout();
                    break;
                }
            case 'patch-presence':
                {
                    const roomId = msg['room-id'];
                    this._trySetRoomConnected(roomId, true);
                    this._patchPresencePeers(roomId, msg['edits']);
                    this._notifyPresenceSubs(roomId);
                    break;
                }
            case 'refresh-presence':
                {
                    const roomId = msg['room-id'];
                    this._trySetRoomConnected(roomId, true);
                    this._setPresencePeers(roomId, msg['data']);
                    this._notifyPresenceSubs(roomId);
                    break;
                }
            case 'server-broadcast':
                {
                    const room = msg['room-id'];
                    const topic = msg.topic;
                    this._trySetRoomConnected(room, true);
                    this._notifyBroadcastSubs(room, topic, msg);
                    break;
                }
            case 'join-room-ok':
                {
                    const loadingRoomId = msg['room-id'];
                    const joinedRoom = this._rooms[loadingRoomId];
                    if (!joinedRoom) {
                        if (this._roomsPendingLeave[loadingRoomId]) {
                            this._tryLeaveRoom(loadingRoomId);
                            delete this._roomsPendingLeave[loadingRoomId];
                        }
                        break;
                    }
                    this._trySetRoomConnected(loadingRoomId, true);
                    this._flushEnqueuedRoomData(loadingRoomId);
                    break;
                }
            case 'leave-room-ok':
                {
                    const roomId = msg['room-id'];
                    this._trySetRoomConnected(roomId, false);
                    break;
                }
            case 'join-room-error':
                const errorRoomId = msg['room-id'];
                const errorRoom = this._rooms[errorRoomId];
                if (errorRoom) {
                    errorRoom.error = msg['error'];
                }
                this._notifyPresenceSubs(errorRoomId);
                break;
            case 'error':
                this._handleReceiveError(msg);
                break;
            default:
                this._log.info('Unknown op', msg.op, msg);
                break;
        }
    }
    createWriteStream(opts) {
        return this._instantStream.createWriteStream(opts);
    }
    createReadStream(opts) {
        return this._instantStream.createReadStream(opts);
    }
    _pendingMutations() {
        return this.kv.currentValue.pendingMutations ?? new Map();
    }
    _updatePendingMutations(f) {
        this.kv.updateInPlace((prev)=>{
            const muts = prev.pendingMutations ?? new Map();
            prev.pendingMutations = muts;
            f(muts);
        });
    }
    /**
     * @param {'timeout' | 'error'} status
     * @param {string} eventId
     * @param {{message?: string, type?: string, status?: number, hint?: unknown}} errorMsg
     */ _handleMutationError(status, eventId, errorMsg) {
        const mut = this._pendingMutations().get(eventId);
        if (mut && (status !== 'timeout' || !mut['tx-id'])) {
            this._updatePendingMutations((prev)=>{
                prev.delete(eventId);
                return prev;
            });
            this._inFlightMutationEventIds.delete(eventId);
            const errDetails = {
                message: errorMsg.message,
                hint: errorMsg.hint
            };
            this.notifyAll();
            this.notifyAttrsSubs();
            this.notifyMutationErrorSubs(errDetails);
            this._finishTransaction(status, eventId, errorMsg);
        }
    }
    _handleReceiveError(msg) {
        console.log('error', msg);
        const eventId = msg['client-event-id'];
        // This might not be a mutation, but it can't hurt to delete it
        this._inFlightMutationEventIds.delete(eventId);
        const prevMutation = this._pendingMutations().get(eventId);
        const errorMessage = {
            message: msg.message || 'Uh-oh, something went wrong. Ping Joe & Stopa.'
        };
        if (msg.hint) {
            errorMessage.hint = msg.hint;
        }
        if (prevMutation) {
            this._handleMutationError('error', eventId, msg);
            return;
        }
        if (msg['original-event']?.hasOwnProperty('q') && msg['original-event']?.op === 'add-query') {
            const q = msg['original-event']?.q;
            const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
            this.notifyQueryError((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q), errorMessage);
            this.notifyQueryOnceError(q, hash, eventId, errorMessage);
            return;
        }
        const isInitError = msg['original-event']?.op === 'init';
        if (isInitError) {
            if (msg.type === 'record-not-found' && msg.hint?.['record-type'] === 'app-user') {
                // User has been logged out
                this.changeCurrentUser(null);
                return;
            }
            // We failed to init
            this._setStatus(STATUS.ERRORED, errorMessage);
            this.notifyAll();
            return;
        }
        switch(msg['original-event']?.op){
            case 'resync-table':
                {
                    this._syncTable.onResyncError(msg);
                    return;
                }
            case 'start-sync':
                {
                    this._syncTable.onStartSyncError(msg);
                    return;
                }
            case 'start-stream':
            case 'append-stream':
            case 'subscribe-stream':
            case 'unsubscribe-stream':
                {
                    this._instantStream.onRecieveError(msg);
                    return;
                }
        }
        // We've caught some error which has no corresponding listener.
        // Let's console.error to let the user know.
        const errorObj = {
            ...msg
        };
        delete errorObj.message;
        delete errorObj.hint;
        console.error(msg.message, errorObj);
        if (msg.hint) {
            console.error('This error comes with some debugging information. Here it is: \n', msg.hint);
        }
    }
    notifyQueryOnceError(q, hash, eventId, e) {
        const r = this.queryOnceDfds[hash]?.find((r)=>r.eventId === eventId);
        if (!r) return;
        r.dfd.reject(e);
        this._completeQueryOnce(q, hash, r.dfd);
    }
    _setAttrs(attrs) {
        this.attrs = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AttrsStoreClass"](attrs.reduce((acc, attr)=>{
            acc[attr.id] = attr;
            return acc;
        }, {}), this._linkIndex);
        this.notifyAttrsSubs();
    }
    // ---------------------------
    // Queries
    getPreviousResult = (q)=>{
        const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
        return this.dataForQuery(hash)?.data;
    };
    _startQuerySub(q, hash) {
        const eventId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
        this.querySubs.updateInPlace((prev)=>{
            prev[hash] = prev[hash] || {
                q,
                result: null,
                eventId
            };
            prev[hash].lastAccessed = Date.now();
        });
        this._trySendAuthed(eventId, {
            op: 'add-query',
            q
        });
        return eventId;
    }
    subscribeTable(q, cb) {
        return this._syncTable.subscribe(q, cb);
    }
    /**
     *  When a user subscribes to a query the following side effects occur:
     *
     *  - We update querySubs to include the new query
     *  - We update queryCbs to include the new cb
     *  - If we already have a result for the query we call cb immediately
     *  - We send the server an `add-query` message
     *
     *  Returns an unsubscribe function
     */ subscribeQuery(q, cb, opts) {
        if (!this.config.disableValidation) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$queryValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateQuery"])(q, this.config.schema);
        }
        if (opts && 'ruleParams' in opts) {
            q = {
                $$ruleParams: opts['ruleParams'],
                ...q
            };
        }
        const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
        const prevResult = this.getPreviousResult(q);
        if (prevResult) {
            cb(prevResult);
        }
        this.queryCbs[hash] = this.queryCbs[hash] ?? [];
        this.queryCbs[hash].push({
            q,
            cb
        });
        this._startQuerySub(q, hash);
        return ()=>{
            this._unsubQuery(q, hash, cb);
        };
    }
    queryOnce(q, opts) {
        if (!this.config.disableValidation) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$queryValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateQuery"])(q, this.config.schema);
        }
        if (opts && 'ruleParams' in opts) {
            q = {
                $$ruleParams: opts['ruleParams'],
                ...q
            };
        }
        const dfd = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$Deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Deferred"]();
        if (!this._isOnline) {
            dfd.reject(new Error("We can't run `queryOnce`, because the device is offline."));
            return dfd.promise;
        }
        if (!this.querySubs) {
            dfd.reject(new Error("We can't run `queryOnce` on the backend. Use adminAPI.query instead: https://www.instantdb.com/docs/backend#query"));
            return dfd.promise;
        }
        const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(q);
        const eventId = this._startQuerySub(q, hash);
        this.queryOnceDfds[hash] = this.queryOnceDfds[hash] ?? [];
        this.queryOnceDfds[hash].push({
            q,
            dfd,
            eventId
        });
        setTimeout(()=>dfd.reject(new Error('Query timed out')), QUERY_ONCE_TIMEOUT);
        return dfd.promise;
    }
    _completeQueryOnce(q, hash, dfd) {
        if (!this.queryOnceDfds[hash]) return;
        this.queryOnceDfds[hash] = this.queryOnceDfds[hash].filter((r)=>r.dfd !== dfd);
        this._cleanupQuery(q, hash);
    }
    _unsubQuery(q, hash, cb) {
        if (!this.queryCbs[hash]) return;
        this.queryCbs[hash] = this.queryCbs[hash].filter((r)=>r.cb !== cb);
        this._cleanupQuery(q, hash);
    }
    _hasQueryListeners(hash) {
        return !!(this.queryCbs[hash]?.length || this.queryOnceDfds[hash]?.length);
    }
    _cleanupQuery(q, hash) {
        const hasListeners = this._hasQueryListeners(hash);
        if (hasListeners) return;
        delete this.queryCbs[hash];
        delete this.queryOnceDfds[hash];
        delete this._dataForQueryCache[hash];
        this.querySubs.unloadKey(hash);
        this._trySendAuthed((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
            op: 'remove-query',
            q
        });
    }
    // When we `pushTx`, it's possible that we don't yet have `this.attrs`
    // This means that `tx-steps` in `pendingMutations` will include `add-attr`
    // commands for attrs that already exist.
    //
    // This will also affect `add-triple` and `retract-triple` which
    // reference attr-ids that do not match the server.
    //
    // We fix this by rewriting `tx-steps` in each `pendingMutation`.
    // We remove `add-attr` commands for attrs that already exist.
    // We update `add-triple` and `retract-triple` commands to use the
    // server attr-ids.
    /**
     *
     * @param {s.AttrsStore} attrs
     * @param {any} muts
     * @param {number} [processedTxId]
     */ _rewriteMutations(attrs, muts, processedTxId) {
        if (!attrs) return muts;
        if (!muts) return new Map();
        const findExistingAttr = (attr)=>{
            const [_, etype, label] = attr['forward-identity'];
            const existing = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByFwdIdentName"](attrs, etype, label);
            return existing;
        };
        const findReverseAttr = (attr)=>{
            const [_, etype, label] = attr['forward-identity'];
            const revAttr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAttrByReverseIdentName"](attrs, etype, label);
            return revAttr;
        };
        const mapping = {
            attrIdMap: {},
            refSwapAttrIds: new Set()
        };
        let mappingChanged = false;
        const rewriteTxSteps = (txSteps, txId)=>{
            const retTxSteps = [];
            for (const txStep of txSteps){
                const [action] = txStep;
                // Handles add-attr
                // If existing, we drop it, and track it
                // to update add/retract triples
                if (action === 'add-attr') {
                    const [_action, attr] = txStep;
                    const existing = findExistingAttr(attr);
                    if (existing && attr.id !== existing.id) {
                        mapping.attrIdMap[attr.id] = existing.id;
                        mappingChanged = true;
                        continue;
                    }
                    if (attr['value-type'] === 'ref') {
                        const revAttr = findReverseAttr(attr);
                        if (revAttr) {
                            mapping.attrIdMap[attr.id] = revAttr.id;
                            mapping.refSwapAttrIds.add(attr.id);
                            mappingChanged = true;
                            continue;
                        }
                    }
                }
                if (processedTxId && txId && processedTxId >= txId && action === 'add-attr' || action === 'update-attr' || action === 'delete-attr') {
                    mappingChanged = true;
                    continue;
                }
                // Handles add-triple|retract-triple
                // If in mapping, we update the attr-id
                const newTxStep = mappingChanged ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instaml$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rewriteStep"](mapping, txStep) : txStep;
                retTxSteps.push(newTxStep);
            }
            return mappingChanged ? retTxSteps : txSteps;
        };
        const rewritten = new Map();
        for (const [k, mut] of muts.entries()){
            rewritten.set(k, {
                ...mut,
                'tx-steps': rewriteTxSteps(mut['tx-steps'], mut['tx-id'])
            });
        }
        if (!mappingChanged) {
            return muts;
        }
        return rewritten;
    }
    _rewriteMutationsSorted(attrs, muts) {
        return sortedMutationEntries(this._rewriteMutations(attrs, muts).entries());
    }
    // ---------------------------
    // Transact
    /**
     * @returns {s.AttrsStore}
     */ optimisticAttrs() {
        const pendingMutationSteps = [
            ...this._pendingMutations().values()
        ] // hack due to Map()
        .flatMap((x)=>x['tx-steps']);
        const deletedAttrIds = new Set(pendingMutationSteps.filter(([action, _attr])=>action === 'delete-attr').map(([_action, id])=>id));
        const pendingAttrs = [];
        for (const [_action, attr] of pendingMutationSteps){
            if (_action === 'add-attr') {
                pendingAttrs.push(attr);
            } else if (_action === 'update-attr' && attr.id && this.attrs?.getAttr(attr.id)) {
                const fullAttr = {
                    ...this.attrs.getAttr(attr.id),
                    ...attr
                };
                pendingAttrs.push(fullAttr);
            }
        }
        if (!deletedAttrIds.size && !pendingAttrs.length) {
            return this.attrs || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AttrsStoreClass"]({}, this._linkIndex);
        }
        const attrs = {
            ...this.attrs?.attrs || {}
        };
        for (const attr of pendingAttrs){
            attrs[attr.id] = attr;
        }
        for (const id of deletedAttrIds){
            delete attrs[id];
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AttrsStoreClass"](attrs, this._linkIndex);
    }
    /** Runs instaql on a query and a store */ dataForQuery(hash, applyOptimistic = true) {
        const errorMessage = this._errorMessage;
        if (errorMessage) {
            return {
                error: errorMessage
            };
        }
        if (!this.querySubs) return;
        if (!this.kv.currentValue.pendingMutations) return;
        const querySubVersion = this.querySubs.version();
        const querySubs = this.querySubs.currentValue;
        const pendingMutationsVersion = this.kv.version();
        const pendingMutations = this._pendingMutations();
        const { q, result } = querySubs[hash] || {};
        if (!result) return;
        const cached = this._dataForQueryCache[hash];
        if (cached && querySubVersion === cached.querySubVersion && pendingMutationsVersion === cached.pendingMutationsVersion) {
            return cached;
        }
        let store = result.store;
        let attrsStore = result.attrsStore;
        const { pageInfo, aggregate, processedTxId } = result;
        const mutations = this._rewriteMutationsSorted(attrsStore, pendingMutations);
        if (applyOptimistic) {
            const optimisticResult = this._applyOptimisticUpdates(store, attrsStore, mutations, processedTxId);
            store = optimisticResult.store;
            attrsStore = optimisticResult.attrsStore;
        }
        const resp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instaql$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
            store: store,
            attrsStore: attrsStore,
            pageInfo,
            aggregate
        }, q);
        return {
            data: resp,
            querySubVersion,
            pendingMutationsVersion
        };
    }
    _applyOptimisticUpdates(store, attrsStore, mutations, processedTxId) {
        for (const [_, mut] of mutations){
            if (!mut['tx-id'] || processedTxId && mut['tx-id'] > processedTxId) {
                const result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transact"](store, attrsStore, mut['tx-steps']);
                store = result.store;
                attrsStore = result.attrsStore;
            }
        }
        return {
            store,
            attrsStore
        };
    }
    /** Re-run instaql and call all callbacks with new data */ notifyOne = (hash)=>{
        const cbs = this.queryCbs[hash] ?? [];
        const prevData = this._dataForQueryCache[hash]?.data;
        const resp = this.dataForQuery(hash);
        if (!resp?.data) return;
        this._dataForQueryCache[hash] = resp;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["areObjectsDeepEqual"])(resp.data, prevData)) return;
        cbs.forEach((r)=>r.cb(resp.data));
    };
    notifyOneQueryOnce = (hash)=>{
        const dfds = this.queryOnceDfds[hash] ?? [];
        const data = this.dataForQuery(hash)?.data;
        dfds.forEach((r)=>{
            this._completeQueryOnce(r.q, hash, r.dfd);
            r.dfd.resolve(data);
        });
    };
    notifyQueryError = (hash, error)=>{
        const cbs = this.queryCbs[hash] || [];
        cbs.forEach((r)=>r.cb({
                error
            }));
    };
    /** Re-compute all subscriptions */ notifyAll() {
        Object.keys(this.queryCbs).forEach((hash)=>{
            this.querySubs.waitForKeyToLoad(hash).then(()=>this.notifyOne(hash)).catch(()=>this.notifyOne(hash));
        });
    }
    loadedNotifyAll() {
        this.kv.waitForKeyToLoad('pendingMutations').then(()=>this.notifyAll()).catch(()=>this.notifyAll());
    }
    /** Applies transactions locally and sends transact message to server */ pushTx = (chunks)=>{
        // Throws if transactions are invalid
        if (!this.config.disableValidation) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$transactionValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validateTransactions"])(chunks, this.config.schema);
        }
        try {
            const txSteps = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instaml$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["transform"]({
                attrsStore: this.optimisticAttrs(),
                schema: this.config.schema,
                stores: Object.values(this.querySubs.currentValue).map((sub)=>sub?.result?.store),
                useDateObjects: this.config.useDateObjects
            }, chunks);
            return this.pushOps(txSteps);
        } catch (e) {
            return this.pushOps([], e);
        }
    };
    /**
     * @param {*} txSteps
     * @param {*} [error]
     * @returns
     */ pushOps = (txSteps, error)=>{
        const eventId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
        const mutations = [
            ...this._pendingMutations().values()
        ];
        const order = Math.max(0, ...mutations.map((mut)=>mut.order || 0)) + 1;
        const mutation = {
            op: 'transact',
            'tx-steps': txSteps,
            created: Date.now(),
            error,
            order
        };
        this._updatePendingMutations((prev)=>{
            prev.set(eventId, mutation);
        });
        const dfd = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$Deferred$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Deferred"]();
        this.mutationDeferredStore.set(eventId, dfd);
        this._sendMutation(eventId, mutation);
        this.notifyAll();
        return dfd.promise;
    };
    shutdown() {
        this._log.info('[shutdown]', this.config.appId);
        this._isShutdown = true;
        this._transport?.close();
    }
    /**
     * Sends mutation to server and schedules a timeout to cancel it if
     * we don't hear back in time.
     * Note: If we're offline we don't schedule a timeout, we'll schedule it
     * later once we're back online and send the mutation again
     *
     */ _sendMutation(eventId, mutation) {
        if (mutation.error) {
            this._handleMutationError('error', eventId, {
                message: mutation.error.message
            });
            return;
        }
        if (this.status !== STATUS.AUTHENTICATED) {
            this._finishTransaction('enqueued', eventId);
            return;
        }
        const timeoutMs = Math.max(6000, Math.min(this._inFlightMutationEventIds.size + 1, // Defensive code in case we don't clean up in flight mutation event ids
        this._pendingMutations().size + 1) * 6000);
        if (!this._isOnline) {
            this._finishTransaction('enqueued', eventId);
        } else {
            this._trySend(eventId, mutation);
            setTimeout(()=>{
                if (!this._isOnline) {
                    return;
                }
                // If we are here, this means that we have sent this mutation, we are online
                // but we have not received a response. If it's this long, something must be wrong,
                // so we error with a timeout.
                this._handleMutationError('timeout', eventId, {
                    message: 'transaction timed out'
                });
            }, timeoutMs);
        }
    }
    // ---------------------------
    // Websocket
    /** Send messages we accumulated while we were connecting */ _flushPendingMessages() {
        const subs = Object.keys(this.queryCbs).map((hash)=>{
            return this.querySubs.currentValue[hash];
        });
        // Note: we should not have any nulls in subs, but we're
        // doing this defensively just in case.
        const safeSubs = subs.filter((x)=>x);
        safeSubs.forEach(({ eventId, q })=>{
            this._trySendAuthed(eventId, {
                op: 'add-query',
                q
            });
        });
        Object.values(this.queryOnceDfds).flat().forEach(({ eventId, q })=>{
            this._trySendAuthed(eventId, {
                op: 'add-query',
                q
            });
        });
        const rewrittenMutations = this._rewriteMutations(this.ensureAttrs(), this._pendingMutations());
        if (rewrittenMutations !== this._pendingMutations()) {
            // Persist rewritten mutations to avoid stale attr ids in future txs.
            this.kv.updateInPlace((prev)=>{
                prev.pendingMutations = rewrittenMutations;
            });
        }
        const muts = sortedMutationEntries(rewrittenMutations.entries());
        muts.forEach(([eventId, mut])=>{
            if (!mut['tx-id']) {
                this._sendMutation(eventId, mut);
            }
        });
        this._syncTable.flushPending();
    }
    /**
     * Clean up pendingMutations that all queries have seen
     */ _cleanupPendingMutationsQueries() {
        let minProcessedTxId = Number.MAX_SAFE_INTEGER;
        for (const { result } of Object.values(this.querySubs.currentValue)){
            if (result?.processedTxId) {
                minProcessedTxId = Math.min(minProcessedTxId, result?.processedTxId);
            }
        }
        this._updatePendingMutations((prev)=>{
            for (const [eventId, mut] of Array.from(prev.entries())){
                if (mut['tx-id'] && mut['tx-id'] <= minProcessedTxId) {
                    prev.delete(eventId);
                }
            }
        });
    }
    /**
     * After mutations is confirmed by server, we give each query 30 sec
     * to update its results. If that doesn't happen, we assume query is
     * unaffected by this mutation and itâ€™s safe to delete it from local queue
     */ _cleanupPendingMutationsTimeout() {
        if (this._pendingMutations().size < this._pendingMutationCleanupThreshold) {
            return;
        }
        const now = Date.now();
        this._updatePendingMutations((prev)=>{
            for (const [eventId, mut] of Array.from(prev.entries())){
                if (mut.confirmed && mut.confirmed + this._pendingTxCleanupTimeout < now) {
                    prev.delete(eventId);
                }
            }
        });
    }
    _trySendAuthed(...args) {
        if (this.status !== STATUS.AUTHENTICATED) {
            return;
        }
        this._trySend(...args);
    }
    _trySend(eventId, msg, opts) {
        if (!this._transport.isOpen()) {
            return;
        }
        if (!ignoreLogging[msg.op]) {
            this._log.info('[send]', this._transport.id, msg.op, {
                'client-event-id': eventId,
                ...msg
            });
        }
        switch(msg.op){
            case 'transact':
                {
                    this._inFlightMutationEventIds.add(eventId);
                    break;
                }
            case 'init':
                {
                    // New connection, so we can't have any mutations in flight
                    this._inFlightMutationEventIds.clear();
                }
        }
        this._transport.send({
            'client-event-id': eventId,
            ...msg
        });
    }
    _transportOnOpen = (e)=>{
        const targetTransport = e.target;
        if (this._transport !== targetTransport) {
            this._log.info('[socket][open]', targetTransport.id, 'skip; this is no longer the current transport');
            return;
        }
        this._log.info('[socket][open]', this._transport.id);
        this._setStatus(STATUS.OPENED);
        this.getCurrentUser().then((resp)=>{
            this._trySend((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
                op: 'init',
                'app-id': this.config.appId,
                'refresh-token': resp.user?.['refresh_token'],
                versions: this.versions,
                // If an admin token is provided for an app, we will
                // skip all permission checks. This is an advanced feature,
                // to let users write internal tools
                // This option is not exposed in `Config`, as it's
                // not ready for prime time
                '__admin-token': this.config.__adminToken
            });
        }).catch((e)=>{
            this._log.error('[socket][error]', targetTransport.id, e);
        });
    };
    _transportOnMessage = (e)=>{
        const targetTransport = e.target;
        const m = e.message;
        if (this._transport !== targetTransport) {
            this._log.info('[socket][message]', targetTransport.id, m, 'skip; this is no longer the current transport');
            return;
        }
        if (!this._wsOk && targetTransport.type === 'ws') {
            this._wsOk = true;
        }
        // Try to reconnect via websocket the next time we connect
        this._transportType = 'ws';
        if (Array.isArray(e.message)) {
            for (const msg of e.message){
                this._handleReceive(targetTransport.id, msg);
            }
        } else {
            this._handleReceive(targetTransport.id, e.message);
        }
    };
    _transportOnError = (e)=>{
        const targetTransport = e.target;
        if (this._transport !== targetTransport) {
            this._log.info('[socket][error]', targetTransport.id, 'skip; this is no longer the current transport');
            return;
        }
        this._log.error('[socket][error]', targetTransport.id, e);
    };
    _scheduleReconnect = ()=>{
        // If we couldn't connect with a websocket last time, try sse
        if (!this._wsOk && this._transportType !== 'sse') {
            this._transportType = 'sse';
            this._reconnectTimeoutMs = 0;
        }
        setTimeout(()=>{
            this._reconnectTimeoutMs = Math.min(this._reconnectTimeoutMs + 1000, 10000);
            if (!this._isOnline) {
                this._log.info('[socket][close]', this._transport.id, 'we are offline, no need to start socket');
                return;
            }
            this._startSocket();
        }, this._reconnectTimeoutMs);
    };
    _transportOnClose = (e)=>{
        const targetTransport = e.target;
        if (this._transport !== targetTransport) {
            this._log.info('[socket][close]', targetTransport.id, 'skip; this is no longer the current transport');
            return;
        }
        this._setStatus(STATUS.CLOSED);
        for (const room of Object.values(this._rooms)){
            room.isConnected = false;
        }
        if (this._isShutdown) {
            this._log.info('[socket][close]', targetTransport.id, 'Reactor has been shut down and will not reconnect');
            return;
        }
        this._log.info('[socket][close]', targetTransport.id, 'schedule reconnect, ms =', this._reconnectTimeoutMs);
        this._scheduleReconnect();
    };
    _startSocket() {
        // Reset whether we support websockets each time we connect
        // new networks may not support websockets
        this._wsOk = null;
        if (this._isShutdown) {
            this._log.info('[socket][start]', this.config.appId, 'Reactor has been shut down and will not start a new socket');
            return;
        }
        if (this._transport && this._transport.isConnecting()) {
            // Our current websocket is in a 'connecting' state.
            // There's no need to start another one, as the socket is
            // effectively fresh.
            this._log.info('[socket][start]', this._transport.id, 'maintained as current transport, we were still in a connecting state');
            return;
        }
        const prevTransport = this._transport;
        this._transport = createTransport({
            transportType: this._transportType,
            appId: this.config.appId,
            apiURI: this.config.apiURI,
            wsURI: this.config.websocketURI,
            EventSourceImpl: this._EventSource
        });
        this._transport.onopen = this._transportOnOpen;
        this._transport.onmessage = this._transportOnMessage;
        this._transport.onclose = this._transportOnClose;
        this._transport.onerror = this._transportOnError;
        this._log.info('[socket][start]', this._transport.id);
        if (prevTransport?.isOpen()) {
            // When the network dies, it doesn't always mean that our
            // socket connection will fire a close event.
            //
            // We _could_ re-use the old socket, if the network drop was a
            // few seconds. But, to be safe right now we always create a new socket.
            //
            // This means that we have to make sure to kill the previous one ourselves.
            // c.f https://issues.chromium.org/issues/41343684
            this._log.info('[socket][start]', this._transport.id, 'close previous transport id = ', prevTransport.id);
            prevTransport.close();
        }
    }
    /**
     * Given a key, returns a stable local id, unique to this device and app.
     *
     * This can be useful if you want to create guest ids for example.
     *
     * Note: If the user deletes their local storage, this id will change.
     *
     */ async getLocalId(name) {
        const k = `localToken_${name}`;
        if (this.kv.currentValue[k]) {
            return this.kv.currentValue[k];
        }
        const current = await this.kv.waitForKeyToLoad(k);
        if (current) {
            return current;
        }
        const newId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
        this.kv.updateInPlace((prev)=>{
            if (prev[k]) return;
            prev[k] = newId;
        });
        return await this.kv.waitForKeyToLoad(k);
    }
    // ----
    // Auth
    _replaceUrlAfterOAuth() {
        if (typeof URL === 'undefined') {
            return;
        }
        const url = new URL(window.location.href);
        if (url.searchParams.get(OAUTH_REDIRECT_PARAM)) {
            const startUrl = url.toString();
            url.searchParams.delete(OAUTH_REDIRECT_PARAM);
            url.searchParams.delete('code');
            url.searchParams.delete('error');
            const newPath = url.pathname + (url.searchParams.size ? '?' + url.searchParams : '') + url.hash;
            // Note: In next.js, this will revert to the old state if user navigates
            //       back. We would need to allow framework specific routing to work
            //       around that problem.
            history.replaceState(history.state, '', newPath);
            // navigation is part of the HTML spec, but not supported by Safari
            // or Firefox yet:
            // https://developer.mozilla.org/en-US/docs/Web/API/Navigation_API#browser_compatibility
            if (// @ts-ignore (waiting for ts support)
            typeof navigation === 'object' && // @ts-ignore (waiting for ts support)
            typeof navigation.addEventListener === 'function' && // @ts-ignore (waiting for ts support)
            typeof navigation.removeEventListener === 'function') {
                let ran = false;
                // The next.js app router will reset the URL when the router loads.
                // This puts it back after the router loads.
                const listener = (e)=>{
                    if (!ran) {
                        ran = true;
                        // @ts-ignore (waiting for ts support)
                        navigation.removeEventListener('navigate', listener);
                        if (!e.userInitiated && e.navigationType === 'replace' && e.destination?.url === startUrl) {
                            history.replaceState(history.state, '', newPath);
                        }
                    }
                };
                // @ts-ignore (waiting for ts support)
                navigation.addEventListener('navigate', listener);
            }
        }
    }
    /**
     *
     * @returns Promise<null | {error: {message: string}}>
     */ async _oauthLoginInit() {
        if (typeof window === 'undefined' || typeof window.location === 'undefined' || typeof URLSearchParams === 'undefined') {
            return null;
        }
        const params = new URLSearchParams(window.location.search);
        if (!params.get(OAUTH_REDIRECT_PARAM)) {
            return null;
        }
        const error = params.get('error');
        if (error) {
            this._replaceUrlAfterOAuth();
            return {
                error: {
                    message: error
                }
            };
        }
        const code = params.get('code');
        if (!code) {
            return null;
        }
        this._replaceUrlAfterOAuth();
        try {
            const currentUser = await this._getCurrentUser();
            const isGuest = currentUser?.type === 'guest';
            const { user } = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["exchangeCodeForToken"]({
                apiURI: this.config.apiURI,
                appId: this.config.appId,
                code,
                refreshToken: isGuest ? currentUser.refresh_token : undefined
            });
            this.setCurrentUser(user);
            return null;
        } catch (e) {
            if (e?.body?.type === 'record-not-found' && e?.body?.hint?.['record-type'] === 'app-oauth-code' && await this._hasCurrentUser()) {
                // We probably just weren't able to clean up the URL, so
                // let's just ignore this error
                return null;
            }
            const message = e?.body?.message || 'Error logging in.';
            return {
                error: {
                    message
                }
            };
        }
    }
    async _waitForOAuthCallbackResponse() {
        return await this._oauthCallbackResponse;
    }
    __subscribeMutationErrors(cb) {
        this.mutationErrorCbs.push(cb);
        return ()=>{
            this.mutationErrorCbs = this.mutationErrorCbs.filter((x)=>x !== cb);
        };
    }
    subscribeAuth(cb) {
        this.authCbs.push(cb);
        const currUserCached = this._currentUserCached;
        if (!currUserCached.isLoading) {
            cb(this._currentUserCached);
        }
        let unsubbed = false;
        this.getCurrentUser().then((resp)=>{
            if (unsubbed) return;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["areObjectsDeepEqual"])(resp, currUserCached)) return;
            cb(resp);
        });
        return ()=>{
            unsubbed = true;
            this.authCbs = this.authCbs.filter((x)=>x !== cb);
        };
    }
    async getAuth() {
        const { user, error } = await this.getCurrentUser();
        if (error) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantError"]('Could not get current user: ' + error.message);
        }
        return user;
    }
    subscribeConnectionStatus(cb) {
        this.connectionStatusCbs.push(cb);
        return ()=>{
            this.connectionStatusCbs = this.connectionStatusCbs.filter((x)=>x !== cb);
        };
    }
    subscribeAttrs(cb) {
        this.attrsCbs.push(cb);
        if (this.attrs) {
            cb(this.attrs.attrs);
        }
        return ()=>{
            this.attrsCbs = this.attrsCbs.filter((x)=>x !== cb);
        };
    }
    notifyAuthSubs(user) {
        this.authCbs.forEach((cb)=>cb(user));
    }
    notifyMutationErrorSubs(error) {
        this.mutationErrorCbs.forEach((cb)=>cb(error));
    }
    notifyAttrsSubs() {
        if (!this.attrs) return;
        const oas = this.optimisticAttrs();
        this.attrsCbs.forEach((cb)=>cb(oas.attrs));
    }
    notifyConnectionStatusSubs(status) {
        this.connectionStatusCbs.forEach((cb)=>cb(status));
    }
    async setCurrentUser(user) {
        this.kv.updateInPlace((prev)=>{
            prev[currentUserKey] = user;
        });
        await this.kv.waitForKeyToLoad(currentUserKey);
    }
    getCurrentUserCached() {
        return this._currentUserCached;
    }
    async _getCurrentUser() {
        const user = await this.kv.waitForKeyToLoad(currentUserKey);
        return typeof user === 'string' ? JSON.parse(user) : user;
    }
    async getCurrentUser() {
        const oauthResp = await this._waitForOAuthCallbackResponse();
        if (oauthResp?.error) {
            const errorV = {
                error: oauthResp.error,
                user: undefined
            };
            this._currentUserCached = {
                isLoading: false,
                ...errorV
            };
            return errorV;
        }
        try {
            const user = await this._getCurrentUser();
            const userV = {
                user: user,
                error: undefined
            };
            this._currentUserCached = {
                isLoading: false,
                ...userV
            };
            return userV;
        } catch (e) {
            return {
                user: undefined,
                isLoading: false,
                error: {
                    message: e?.message || 'Error loading user'
                }
            };
        }
    }
    async _hasCurrentUser() {
        const user = await this.kv.waitForKeyToLoad(currentUserKey);
        return typeof user === 'string' ? JSON.parse(user) != null : user != null;
    }
    async changeCurrentUser(newUser) {
        const { user: oldUser } = await this.getCurrentUser();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["areObjectsDeepEqual"])(oldUser, newUser)) {
            // We were already logged in as the newUser, don't
            // bother updating
            return;
        }
        await this.setCurrentUser(newUser);
        // We need to remove all `result` from querySubs,
        // as they are no longer valid for the new user
        await this.updateUser(newUser);
        try {
            this._broadcastChannel?.postMessage({
                type: 'auth'
            });
        } catch (error) {
            console.error('Error posting message to broadcast channel', error);
        }
    }
    async syncUserToEndpoint(user) {
        if (!this.config.firstPartyPath) return;
        try {
            await fetch(this.config.firstPartyPath + '/', {
                method: 'POST',
                body: JSON.stringify({
                    type: 'sync-user',
                    appId: this.config.appId,
                    user: user
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
        } catch (error) {
            this._log.error('Error syncing user with external endpoint', error);
        }
    }
    async updateUser(newUser) {
        try {
            await this.syncUserToEndpoint(newUser);
        } catch (error) {
            this._log.error('Error syncing user with external endpoint', error);
        }
        const newV = {
            error: undefined,
            user: newUser
        };
        this._currentUserCached = {
            isLoading: false,
            ...newV
        };
        this._dataForQueryCache = {};
        this.querySubs.updateInPlace((prev)=>{
            Object.keys(prev).forEach((k)=>{
                delete prev[k].result;
            });
        });
        this._reconnectTimeoutMs = 0;
        this._transport.close();
        this._oauthCallbackResponse = null;
        this.notifyAuthSubs(newV);
    }
    sendMagicCode({ email }) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sendMagicCode"]({
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            email: email
        });
    }
    async signInWithMagicCode({ email, code }) {
        const currentUser = await this.getCurrentUser();
        const isGuest = currentUser?.user?.type === 'guest';
        const res = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["verifyMagicCode"]({
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            email,
            code,
            refreshToken: isGuest ? currentUser.user.refresh_token : undefined
        });
        await this.changeCurrentUser(res.user);
        return res;
    }
    async signInWithCustomToken(authToken) {
        const res = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["verifyRefreshToken"]({
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            refreshToken: authToken
        });
        await this.changeCurrentUser(res.user);
        return res;
    }
    async signInAsGuest() {
        const res = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["signInAsGuest"]({
            apiURI: this.config.apiURI,
            appId: this.config.appId
        });
        await this.changeCurrentUser(res.user);
        return res;
    }
    potentiallyInvalidateToken(currentUser, opts) {
        const refreshToken = currentUser?.user?.refresh_token;
        if (!refreshToken) {
            return;
        }
        const wantsToSkip = opts.invalidateToken === false;
        if (wantsToSkip) {
            this._log.info('[auth-invalidate] skipped invalidateToken');
            return;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["signOut"]({
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            refreshToken
        }).then(()=>{
            this._log.info('[auth-invalidate] completed invalidateToken');
        }).catch((e)=>{});
    }
    async signOut(opts) {
        const currentUser = await this.getCurrentUser();
        this.potentiallyInvalidateToken(currentUser, opts);
        await this.changeCurrentUser(null);
    }
    /**
     * Creates an OAuth authorization URL.
     *
     * @param {Object} params - The parameters to create the authorization URL.
     * @param {string} params.clientName - The name of the client requesting authorization.
     * @param {string} params.redirectURL - The URL to redirect users to after authorization.
     * @returns {string} The created authorization URL.
     */ createAuthorizationURL({ clientName, redirectURL }) {
        const { apiURI, appId } = this.config;
        return `${apiURI}/runtime/oauth/start?app_id=${appId}&client_name=${clientName}&redirect_uri=${redirectURL}`;
    }
    /**
     * @param {Object} params
     * @param {string} params.code - The code received from the OAuth service.
     * @param {string} [params.codeVerifier] - The code verifier used to generate the code challenge.
     */ async exchangeCodeForToken({ code, codeVerifier }) {
        const currentUser = await this.getCurrentUser();
        const isGuest = currentUser?.user?.type === 'guest';
        const res = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["exchangeCodeForToken"]({
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            code: code,
            codeVerifier,
            refreshToken: isGuest ? currentUser.user.refresh_token : undefined
        });
        await this.changeCurrentUser(res.user);
        return res;
    }
    issuerURI() {
        const { apiURI, appId } = this.config;
        return `${apiURI}/runtime/${appId}`;
    }
    /**
     * @param {Object} params
     * @param {string} params.clientName - The name of the client requesting authorization.
     * @param {string} params.idToken - The id_token from the external service
     * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service
     */ async signInWithIdToken({ idToken, clientName, nonce }) {
        const currentUser = await this.getCurrentUser();
        const refreshToken = currentUser?.user?.refresh_token;
        const res = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$authAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["signInWithIdToken"]({
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            idToken,
            clientName,
            nonce,
            refreshToken
        });
        await this.changeCurrentUser(res.user);
        return res;
    }
    // --------
    // Rooms
    /**
     * @param {string} roomType
     * @param {string} roomId
     * @param {any | null | undefined} [initialPresence] -- initial presence data to send when joining the room
     * @returns () => void
     */ joinRoom(roomType, roomId, initialPresence) {
        let needsToSendJoin = false;
        if (!this._rooms[roomId]) {
            needsToSendJoin = true;
            this._rooms[roomId] = {
                roomType,
                isConnected: false,
                error: undefined
            };
        }
        this._presence[roomId] = this._presence[roomId] || {};
        const previousResult = this._presence[roomId].result;
        if (initialPresence && !previousResult) {
            this._presence[roomId].result = this._presence[roomId].result || {};
            this._presence[roomId].result.user = initialPresence;
            this._notifyPresenceSubs(roomId);
        }
        if (needsToSendJoin) {
            this._tryJoinRoom(roomType, roomId, initialPresence);
        }
        return ()=>{
            this._cleanupRoom(roomId);
        };
    }
    _cleanupRoom(roomId) {
        if (!this._presence[roomId]?.handlers?.length && !Object.keys(this._broadcastSubs[roomId] ?? {}).length) {
            const isConnected = this._rooms[roomId]?.isConnected;
            delete this._rooms[roomId];
            delete this._presence[roomId];
            delete this._broadcastSubs[roomId];
            if (isConnected) {
                this._tryLeaveRoom(roomId);
            } else {
                this._roomsPendingLeave[roomId] = true;
            }
        }
    }
    // --------
    // Presence
    // TODO: look into typing again
    getPresence(roomType, roomId, opts = {}) {
        const room = this._rooms[roomId];
        const presence = this._presence[roomId];
        if (!room || !presence || !presence.result) return null;
        return {
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$presence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["buildPresenceSlice"])(presence.result, opts, this._sessionId),
            isLoading: !room.isConnected,
            error: room.error
        };
    }
    // TODO: look into typing again
    publishPresence(roomType, roomId, partialData) {
        const room = this._rooms[roomId];
        const presence = this._presence[roomId];
        if (!room || !presence) {
            return;
        }
        presence.result = presence.result || {};
        const data = {
            ...presence.result.user,
            ...partialData
        };
        presence.result.user = data;
        if (!room.isConnected) {
            return;
        }
        this._trySetPresence(roomId, data);
        this._notifyPresenceSubs(roomId);
    }
    _trySetPresence(roomId, data) {
        this._trySendAuthed((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
            op: 'set-presence',
            'room-id': roomId,
            data
        });
    }
    _tryJoinRoom(roomType, roomId, data) {
        this._trySendAuthed((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
            op: 'join-room',
            'room-type': roomType,
            'room-id': roomId,
            data
        });
        delete this._roomsPendingLeave[roomId];
    }
    _tryLeaveRoom(roomId) {
        this._trySendAuthed((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
            op: 'leave-room',
            'room-id': roomId
        });
    }
    _trySetRoomConnected(roomId, isConnected) {
        const room = this._rooms[roomId];
        if (room) {
            room.isConnected = isConnected;
        }
    }
    // TODO: look into typing again
    subscribePresence(roomType, roomId, opts, cb) {
        const leaveRoom = this.joinRoom(roomType, roomId, // Oct 28, 2025
        // Note: initialData is deprecated.
        // Keeping here for backwards compatibility
        opts.initialPresence || opts.initialData);
        const handler = {
            ...opts,
            roomId,
            cb,
            prev: null
        };
        this._presence[roomId] = this._presence[roomId] || {};
        this._presence[roomId].handlers = this._presence[roomId].handlers || [];
        this._presence[roomId].handlers.push(handler);
        this._notifyPresenceSub(roomId, handler);
        return ()=>{
            this._presence[roomId].handlers = this._presence[roomId]?.handlers?.filter((x)=>x !== handler) ?? [];
            leaveRoom();
        };
    }
    _notifyPresenceSubs(roomId) {
        this._presence[roomId]?.handlers?.forEach((handler)=>{
            this._notifyPresenceSub(roomId, handler);
        });
    }
    _notifyPresenceSub(roomId, handler) {
        const slice = this.getPresence('', roomId, handler);
        if (!slice) {
            return;
        }
        if (handler.prev && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$presence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasPresenceResponseChanged"])(slice, handler.prev)) {
            return;
        }
        handler.prev = slice;
        handler.cb(slice);
    }
    _patchPresencePeers(roomId, edits) {
        const peers = this._presence[roomId]?.result?.peers || {};
        let sessions = Object.fromEntries(Object.entries(peers).map(([k, v])=>[
                k,
                {
                    data: v
                }
            ]));
        const myPresence = this._presence[roomId]?.result;
        const newSessions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])(sessions, (draft)=>{
            for (let [path, op, value] of edits){
                switch(op){
                    case '+':
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["insertInMutative"])(draft, path, value);
                        break;
                    case 'r':
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assocInMutative"])(draft, path, value);
                        break;
                    case '-':
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dissocInMutative"])(draft, path);
                        break;
                }
            }
            // Ignore our own edits
            delete draft[this._sessionId];
        });
        this._setPresencePeers(roomId, newSessions);
    }
    _setPresencePeers(roomId, data) {
        const sessions = {
            ...data
        };
        // no need to keep track of `user`
        delete sessions[this._sessionId];
        const peers = Object.fromEntries(Object.entries(sessions).map(([k, v])=>[
                k,
                v.data
            ]));
        this._presence = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mutative$2f$dist$2f$mutative$2e$esm$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])(this._presence, (draft)=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$object$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assocInMutative"])(draft, [
                roomId,
                'result',
                'peers'
            ], peers);
        });
    }
    // --------
    // Broadcast
    publishTopic({ roomType, roomId, topic, data }) {
        const room = this._rooms[roomId];
        if (!room) {
            return;
        }
        if (!room.isConnected) {
            this._broadcastQueue[roomId] = this._broadcastQueue[roomId] ?? [];
            this._broadcastQueue[roomId].push({
                topic,
                roomType,
                data
            });
            return;
        }
        this._tryBroadcast(roomId, roomType, topic, data);
    }
    _tryBroadcast(roomId, roomType, topic, data) {
        this._trySendAuthed((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(), {
            op: 'client-broadcast',
            'room-id': roomId,
            roomType,
            topic,
            data
        });
    }
    subscribeTopic(roomType, roomId, topic, cb) {
        const leaveRoom = this.joinRoom(roomType, roomId);
        this._broadcastSubs[roomId] = this._broadcastSubs[roomId] || {};
        this._broadcastSubs[roomId][topic] = this._broadcastSubs[roomId][topic] || [];
        this._broadcastSubs[roomId][topic].push(cb);
        this._presence[roomId] = this._presence[roomId] || {};
        return ()=>{
            this._broadcastSubs[roomId][topic] = this._broadcastSubs[roomId][topic].filter((x)=>x !== cb);
            if (!this._broadcastSubs[roomId][topic].length) {
                delete this._broadcastSubs[roomId][topic];
            }
            leaveRoom();
        };
    }
    _notifyBroadcastSubs(room, topic, msg) {
        this._broadcastSubs?.[room]?.[topic]?.forEach((cb)=>{
            const data = msg.data?.data;
            const peer = msg.data['peer-id'] === this._sessionId ? this._presence[room]?.result?.user : this._presence[room]?.result?.peers?.[msg.data['peer-id']];
            return cb(data, peer);
        });
    }
    // --------
    // Storage
    async uploadFile(path, file, opts) {
        const currentUser = await this.getCurrentUser();
        const refreshToken = currentUser?.user?.refresh_token;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$StorageAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uploadFile"]({
            ...opts,
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            path: path,
            file,
            refreshToken: refreshToken
        });
    }
    async deleteFile(path) {
        const currentUser = await this.getCurrentUser();
        const refreshToken = currentUser?.user?.refresh_token;
        const result = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$StorageAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deleteFile"]({
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            path,
            refreshToken: refreshToken
        });
        return result;
    }
    // Deprecated Storage API (Jan 2025)
    // ---------------------------------
    async upload(path, file) {
        const currentUser = await this.getCurrentUser();
        const refreshToken = currentUser?.user?.refresh_token;
        const fileName = path || file.name;
        const url = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$StorageAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSignedUploadUrl"]({
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            fileName: fileName,
            refreshToken: refreshToken
        });
        const isSuccess = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$StorageAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["upload"](url, file);
        return isSuccess;
    }
    async getDownloadUrl(path) {
        const currentUser = await this.getCurrentUser();
        const refreshToken = currentUser?.user?.refresh_token;
        const url = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$StorageAPI$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDownloadUrl"]({
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            path: path,
            refreshToken: refreshToken
        });
        return url;
    }
} //# sourceMappingURL=Reactor.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/schema.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "i",
    ()=>i
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/schemaTypes.js [app-client] (ecmascript)");
;
// ==========
// API
/**
 * @deprecated
 * `i.graph` is deprecated. Use `i.schema` instead.
 *
 * @example
 * // Before
 * i.graph(entities, links).withRoomSchema<RoomType>();
 *
 * // After
 * i.schema({ entities, links, rooms })
 *
 * @see
 * https://instantdb.com/docs/modeling-data
 */ function graph(entities, links) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantSchemaDef"](enrichEntitiesWithLinks(entities, links), // (XXX): LinksDef<any> stems from TypeScriptâ€™s inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    links, undefined);
}
/**
 * Creates an entity definition, to be used in conjunction with `i.graph`.
 *
 * @see https://instantdb.com/docs/modeling-data
 * @example
 *   {
 *     posts: i.entity({
 *       title: i.string(),
 *       body: i.string(),
 *     }),
 *     comments: i.entity({
 *       body: i.string(),
 *     })
 *   }
 */ function entity(attrs) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EntityDef"](attrs, {});
}
function string() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('string', true, false);
}
function number() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('number', true, false);
}
function boolean() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('boolean', true, false);
}
function date() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('date', true, false);
}
function json() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('json', true, false);
}
function any() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DataAttrDef"]('json', true, false);
}
// ==========
// internal
function enrichEntitiesWithLinks(entities, links) {
    const linksIndex = {
        fwd: {},
        rev: {}
    };
    for (const linkDef of Object.values(links)){
        linksIndex.fwd[linkDef.forward.on] ||= {};
        linksIndex.rev[linkDef.reverse.on] ||= {};
        linksIndex.fwd[linkDef.forward.on][linkDef.forward.label] = {
            entityName: linkDef.reverse.on,
            cardinality: linkDef.forward.has
        };
        linksIndex.rev[linkDef.reverse.on][linkDef.reverse.label] = {
            entityName: linkDef.forward.on,
            cardinality: linkDef.reverse.has
        };
    }
    const enrichedEntities = Object.fromEntries(Object.entries(entities).map(([name, def])=>[
            name,
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EntityDef"](def.attrs, {
                ...linksIndex.fwd[name],
                ...linksIndex.rev[name]
            })
        ]));
    return enrichedEntities;
}
/**
 * Lets you define a schema for your database.
 *
 * You can define entities, links between entities, and if you use
 * presence, you can define rooms.
 *
 * You can push this schema to your database with the CLI,
 * or use it inside `init`, to get typesafety and autocompletion.
 *
 * @see https://instantdb.com/docs/modeling-data
 * @example
 *   i.schema({
 *     entities: { },
 *     links: { },
 *     rooms: { }
 *   });
 */ function schema({ entities, links, rooms }) {
    const linksDef = links ?? {};
    const roomsDef = rooms ?? {};
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schemaTypes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantSchemaDef"](enrichEntitiesWithLinks(entities, linksDef), // (XXX): LinksDef<any> stems from TypeScript's inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    linksDef, roomsDef);
}
const i = {
    // constructs
    graph,
    schema,
    entity,
    // value types
    string,
    number,
    boolean,
    date,
    json,
    any
}; //# sourceMappingURL=schema.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/devtool.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createDevtool",
    ()=>createDevtool
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$flags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/flags.js [app-client] (ecmascript)");
;
let currentDevtool;
function createDevtool(appId, config) {
    currentDevtool?.dispose();
    const iframeContrainer = createIframeContainer(config);
    const toggler = createToggler(config, toggleView);
    const iframe = createIframe(getSrc(appId));
    function onPostMessage(event) {
        if (event.source !== iframe.element.contentWindow) return;
        if (event.data?.type === 'close' && iframeContrainer.isVisible()) {
            toggleView();
        }
    }
    function onKeyDown(event) {
        const isToggleShortcut = event.shiftKey && event.ctrlKey && event.key === '0';
        const isEsc = event.key === 'Escape' || event.key === 'Esc';
        if (isToggleShortcut) {
            toggleView();
        } else if (isEsc && iframeContrainer.isVisible()) {
            toggleView();
        }
    }
    function toggleView() {
        if (iframeContrainer.isVisible()) {
            iframeContrainer.element.style.display = 'none';
        } else {
            iframeContrainer.element.style.display = 'block';
            // lazily render iframe on first open
            if (!iframeContrainer.element.contains(iframe.element)) {
                iframeContrainer.element.appendChild(iframe.element);
            }
        }
    }
    function dispose() {
        iframeContrainer.element.remove();
        toggler.element.remove();
        removeEventListener('keydown', onKeyDown);
        removeEventListener('message', onPostMessage);
    }
    function create() {
        document.body.appendChild(iframeContrainer.element);
        document.body.appendChild(toggler.element);
        addEventListener('keydown', onKeyDown);
        addEventListener('message', onPostMessage);
        currentDevtool = {
            dispose
        };
    }
    return create();
}
function getSrc(appId) {
    const useLocalDashboard = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$flags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["devBackend"] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$flags$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["devtoolLocalDashboard"];
    const src = `${useLocalDashboard ? 'http://localhost:3000' : 'https://instantdb.com'}/_devtool?appId=${appId}`;
    return src;
}
function createIframe(src) {
    const element = document.createElement('iframe');
    element.src = src;
    element.className = 'instant-devtool-iframe';
    Object.assign(element.style, {
        width: '100%',
        height: '100%',
        backgroundColor: 'white',
        border: 'none'
    });
    return {
        element
    };
}
function createToggler(config, onClick) {
    const logoSVG = `
    <svg width="32" height="32" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect width="512" height="512" fill="black"/>
      <rect x="97.0973" y="91.3297" width="140" height="330" fill="white"/>
    </svg>
  `;
    const element = document.createElement('button');
    element.innerHTML = logoSVG;
    element.className = 'instant-devtool-toggler';
    Object.assign(element.style, {
        // pos
        position: 'fixed',
        ...cssPositionForToggler(config.position),
        height: '32px',
        width: '32px',
        // layout
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: '9010',
        // look
        padding: '0',
        margin: '0',
        border: 'none',
        cursor: 'pointer'
    });
    element.addEventListener('click', onClick);
    return {
        element
    };
}
function cssPositionForToggler(position) {
    switch(position){
        case 'bottom-left':
            return {
                bottom: '24px',
                left: '24px'
            };
        case 'bottom-right':
            return {
                bottom: '24px',
                right: '24px'
            };
        case 'top-right':
            return {
                top: '24px',
                right: '24px'
            };
        case 'top-left':
            return {
                top: '24px',
                left: '24px'
            };
    }
}
function cssPositionForIframeContainer(position) {
    switch(position){
        case 'bottom-left':
            return {
                bottom: '24px',
                right: '24px',
                left: '60px',
                top: '72px'
            };
        case 'bottom-right':
            return {
                bottom: '24px',
                left: '24px',
                right: '60px',
                top: '72px'
            };
        case 'top-right':
            return {
                top: '24px',
                left: '24px',
                right: '60px',
                bottom: '72px'
            };
        case 'top-left':
            return {
                top: '24px',
                right: '24px',
                left: '60px',
                bottom: '72px'
            };
    }
}
function createIframeContainer(config) {
    const element = document.createElement('div');
    Object.assign(element.style, {
        position: 'fixed',
        ...cssPositionForIframeContainer(config.position),
        display: 'block',
        borderRadius: '4px',
        border: '1px #ccc solid',
        boxShadow: '0px 0px 8px #00000044',
        backgroundColor: '#eee',
        zIndex: '999990'
    });
    element.style.display = 'none';
    element.className = 'instant-devtool-container';
    function isVisible() {
        return element.style.display !== 'none';
    }
    return {
        element,
        isVisible
    };
} //# sourceMappingURL=devtool.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/createRouteHandler.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createInstantRouteHandler",
    ()=>createInstantRouteHandler
]);
function createUserSyncResponse(config, user) {
    if (user && user.refresh_token) {
        return new Response(JSON.stringify({
            ok: true
        }), {
            headers: {
                'Content-Type': 'application/json',
                // 7 day expiry
                'Set-Cookie': `instant_user_${config.appId}=${encodeURIComponent(JSON.stringify(user))}; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=604800`
            }
        });
    } else {
        return new Response(JSON.stringify({
            ok: true
        }), {
            headers: {
                'Content-Type': 'application/json',
                // remove the cookie (some browsers)
                'Set-Cookie': `instant_user_${config.appId}=; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=-1`
            }
        });
    }
}
function errorResponse(status, message) {
    return new Response(JSON.stringify({
        ok: false,
        error: message
    }), {
        status,
        headers: {
            'Content-Type': 'application/json'
        }
    });
}
const createInstantRouteHandler = (config)=>{
    return {
        POST: async (req)=>{
            let body;
            try {
                body = await req.json();
            } catch  {
                return errorResponse(400, 'Invalid JSON body');
            }
            if (!body.type) {
                return errorResponse(400, 'Missing "type" field');
            }
            if (body.appId !== config.appId) {
                return errorResponse(403, 'App ID mismatch');
            }
            switch(body.type){
                case 'sync-user':
                    return createUserSyncResponse(config, body.user ?? null);
                default:
                    return errorResponse(400, `Unknown type: ${body.type}`);
            }
        }
    };
}; //# sourceMappingURL=createRouteHandler.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/parseSchemaFromJSON.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseSchemaFromJSON",
    ()=>parseSchemaFromJSON
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/schema.js [app-client] (ecmascript)");
;
const parseSchemaFromJSON = (s)=>{
    // Parse entities
    const entities = {};
    for (const [entityName, entityInfo] of Object.entries(s.entities)){
        const entityDef = entityInfo;
        const attrs = {};
        // Parse attributes
        for (const [attrName, attrInfo] of Object.entries(entityDef.attrs)){
            const attrDef = attrInfo;
            let attr;
            // Create the appropriate attribute type
            switch(attrDef.valueType){
                case 'string':
                    attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].string();
                    break;
                case 'number':
                    attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].number();
                    break;
                case 'boolean':
                    attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].boolean();
                    break;
                case 'date':
                    attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].date();
                    break;
                case 'json':
                    attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].json();
                    break;
                default:
                    attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].json();
            }
            // Apply modifiers
            if (!attrDef.required) {
                attr = attr.optional();
            }
            if (attrDef.config?.indexed) {
                attr = attr.indexed();
            }
            if (attrDef.config?.unique) {
                attr = attr.unique();
            }
            attrs[attrName] = attr;
        }
        entities[entityName] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].entity(attrs);
    }
    // Parse links
    const links = s.links || {};
    // Parse rooms
    const rooms = {};
    if (s.rooms) {
        for (const [roomName, roomInfo] of Object.entries(s.rooms)){
            const roomDef = roomInfo;
            // Parse presence
            const presenceAttrs = {};
            for (const [attrName, attrInfo] of Object.entries(roomDef.presence.attrs)){
                const attrDef = attrInfo;
                let attr;
                switch(attrDef.valueType){
                    case 'string':
                        attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].string();
                        break;
                    case 'number':
                        attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].number();
                        break;
                    case 'boolean':
                        attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].boolean();
                        break;
                    case 'date':
                        attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].date();
                        break;
                    case 'json':
                        attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].json();
                        break;
                    default:
                        attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].json();
                }
                if (!attrDef.required) {
                    attr = attr.optional();
                }
                if (attrDef.config?.indexed) {
                    attr = attr.indexed();
                }
                if (attrDef.config?.unique) {
                    attr = attr.unique();
                }
                presenceAttrs[attrName] = attr;
            }
            // Parse topics
            const topics = {};
            if (roomDef.topics) {
                for (const [topicName, topicInfo] of Object.entries(roomDef.topics)){
                    const topicDef = topicInfo;
                    const topicAttrs = {};
                    for (const [attrName, attrInfo] of Object.entries(topicDef.attrs)){
                        const attrDef = attrInfo;
                        let attr;
                        switch(attrDef.valueType){
                            case 'string':
                                attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].string();
                                break;
                            case 'number':
                                attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].number();
                                break;
                            case 'boolean':
                                attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].boolean();
                                break;
                            case 'date':
                                attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].date();
                                break;
                            case 'json':
                                attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].json();
                                break;
                            default:
                                attr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].json();
                        }
                        if (!attrDef.required) {
                            attr = attr.optional();
                        }
                        if (attrDef.config?.indexed) {
                            attr = attr.indexed();
                        }
                        if (attrDef.config?.unique) {
                            attr = attr.unique();
                        }
                        topicAttrs[attrName] = attr;
                    }
                    topics[topicName] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].entity(topicAttrs);
                }
            }
            rooms[roomName] = {
                presence: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].entity(presenceAttrs),
                topics
            };
        }
    }
    const resultingSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"].schema({
        entities,
        links,
        rooms
    });
    return resultingSchema;
}; //# sourceMappingURL=parseSchemaFromJSON.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/weakHash.js [app-client] (ecmascript) <export default as weakHash>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "weakHash",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/weakHash.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@instantdb/core/dist/esm/framework.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FrameworkClient",
    ()=>FrameworkClient,
    "isServer",
    ()=>isServer
]);
// The FrameworkClient class is a mini version of a query store that allows making queries on both the frontend and backend
// you can register queries, await their results and serialize them over a server/client boundary.
// The class is generic so that it can be a good starting off point to make other ssr adapters.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__weakHash$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/weakHash.js [app-client] (ecmascript) <export default as weakHash>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/store.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instaql$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/instaql.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$linkIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/linkIndex.js [app-client] (ecmascript)");
;
;
;
;
const isServer = typeof window === 'undefined' || 'Deno' in globalThis;
class FrameworkClient {
    params;
    db;
    // stores all of the query promises so that ssr can read them
    // and send the relevant results alongside the html that resulted in the query resolving
    resultMap = new Map();
    queryResolvedCallbacks = [];
    constructor(params){
        this.params = params;
        this.db = params.db;
        this.resultMap = new Map();
    }
    subscribe = (callback)=>{
        this.queryResolvedCallbacks.push(callback);
    };
    // Runs on the client when ssr gets html script tags
    addQueryResult = (queryKey, value)=>{
        this.resultMap.set(queryKey, {
            type: value.type,
            status: 'success',
            data: value,
            promise: null,
            error: null
        });
        // send the result to the client
        if (!isServer) {
            // make sure the attrs are there to create stores
            if (!this.db._reactor.attrs) {
                this.db._reactor._setAttrs(value.attrs);
            }
            this.db._reactor._addQueryData(value.query, value, !!this.db._reactor.config.schema);
        }
    };
    // creates an entry in the results map
    // and returns the same thing added to the map
    query = (_query, opts)=>{
        const { hash, query } = this.hashQuery(_query, opts);
        if (this.db._reactor.status === 'authenticated') {
            const promise = this.db.queryOnce(_query, opts);
            let entry = {
                status: 'pending',
                type: 'session',
                data: undefined,
                error: undefined,
                promise: promise
            };
            promise.then((result)=>{
                entry.status = 'success';
                entry.data = result;
                entry.promise = null;
            });
            promise.catch((error)=>{
                entry.status = 'error';
                entry.error = error;
                entry.promise = null;
            });
            this.resultMap.set(hash, entry);
            return entry;
        }
        const promise = this.getTriplesAndAttrsForQuery(query);
        let entry = {
            status: 'pending',
            type: 'http',
            data: undefined,
            error: undefined,
            promise: promise
        };
        promise.then((result)=>{
            entry.status = 'success';
            entry.data = result;
            entry.promise = null;
        });
        promise.catch((error)=>{
            entry.status = 'error';
            entry.error = error;
            entry.promise = null;
        });
        promise.then((result)=>{
            this.queryResolvedCallbacks.forEach((callback)=>{
                callback({
                    queryHash: hash,
                    query: query,
                    attrs: result.attrs,
                    triples: result.triples,
                    pageInfo: result.pageInfo
                });
            });
        });
        this.resultMap.set(hash, entry);
        return entry;
    };
    getExistingResultForQuery = (_query, opts)=>{
        const { hash } = this.hashQuery(_query, opts);
        return this.resultMap.get(hash);
    };
    // creates a query result from a set of triples, query, and attrs
    // can be run server side or client side
    completeIsomorphic = (query, triples, attrs, pageInfo)=>{
        const attrMap = {};
        attrs.forEach((attr)=>{
            attrMap[attr.id] = attr;
        });
        const enableCardinalityInference = Boolean(this.db?._reactor?.config?.schema) && ('cardinalityInference' in this.db?._reactor?.config ? Boolean(this.db?._reactor.config?.cardinalityInference) : true);
        const attrsStore = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AttrsStoreClass"](attrs.reduce((acc, attr)=>{
            acc[attr.id] = attr;
            return acc;
        }, {}), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$linkIndex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLinkIndex"])(this.db?._reactor.config.schema));
        const store = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStore"](attrsStore, triples, enableCardinalityInference, this.params.db._reactor.config.useDateObjects || false);
        const resp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instaql$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({
            store: store,
            attrsStore: attrsStore,
            pageInfo: pageInfo,
            aggregate: undefined
        }, query);
        return resp;
    };
    hashQuery = (_query, opts)=>{
        if (_query && opts && 'ruleParams' in opts) {
            _query = {
                $$ruleParams: opts['ruleParams'],
                ..._query
            };
        }
        const query = _query ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["coerceQuery"])(_query) : null;
        return {
            hash: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__weakHash$3e$__["weakHash"])(query),
            query: query
        };
    };
    // Run by the server to get triples and attrs
    getTriplesAndAttrsForQuery = async (query)=>{
        try {
            const response = await fetch(`${this.db._reactor.config.apiURI}/runtime/framework/query`, {
                method: 'POST',
                headers: {
                    'app-id': this.params.db._reactor.config.appId,
                    'Content-Type': 'application/json',
                    Authorization: this.params.token ? `Bearer ${this.params.token}` : undefined
                },
                body: JSON.stringify({
                    query: query
                })
            });
            if (!response.ok) {
                throw new Error('Error getting triples from server');
            }
            const data = await response.json();
            const attrs = data?.attrs;
            if (!attrs) {
                throw new Error('No attrs');
            }
            // TODO: make safer
            const triples = data.result?.[0].data?.['datalog-result']?.['join-rows'][0];
            const pageInfo = data.result?.[0]?.data?.['page-info'];
            return {
                attrs,
                triples,
                type: 'http',
                queryHash: this.hashQuery(query).hash,
                query,
                pageInfo
            };
        } catch (err) {
            const errWithMessage = new Error('Error getting triples from framework client');
            errWithMessage.cause = err;
            throw errWithMessage;
        }
    };
} //# sourceMappingURL=framework.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Auth",
    ()=>Auth,
    "InstantCoreDatabase",
    ()=>InstantCoreDatabase,
    "Storage",
    ()=>Storage,
    "StorageInterface",
    ()=>StorageInterface,
    "Streams",
    ()=>Streams,
    "coerceQuery",
    ()=>coerceQuery,
    "init",
    ()=>init,
    "init_experimental",
    ()=>init_experimental
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$Reactor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/Reactor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/instatx.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/weakHash.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/id.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$IndexedDBStorage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/IndexedDBStorage.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$dates$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/dates.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$WindowNetworkListener$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/WindowNetworkListener.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/schema.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$devtool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/devtool.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/version.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$queryValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/queryValidation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$transactionValidation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/transactionValidation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$warningToggle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/warningToggle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/PersistedObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$createRouteHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/createRouteHandler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$parseSchemaFromJSON$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/parseSchemaFromJSON.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$framework$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/framework.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/fetch.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/InstantError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$Connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/Connection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$SyncTable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/SyncTable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$Stream$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/Stream.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const defaultOpenDevtool = true;
// consts
const defaultConfig = {
    apiURI: 'https://api.instantdb.com',
    websocketURI: 'wss://api.instantdb.com/runtime/session'
};
// hmr
function initSchemaHashStore() {
    globalThis.__instantDbSchemaHashStore = globalThis.__instantDbSchemaHashStore ?? new WeakMap();
    return globalThis.__instantDbSchemaHashStore;
}
function initGlobalInstantCoreStore() {
    globalThis.__instantDbStore = globalThis.__instantDbStore ?? {};
    return globalThis.__instantDbStore;
}
function reactorKey(config) {
    // @ts-expect-error
    const adminToken = config.__adminToken;
    return config.appId + '_' + (config.websocketURI || 'default_ws_uri') + '_' + (config.apiURI || 'default_api_uri') + '_' + (adminToken || 'client_only') + '_' + config.useDateObjects;
}
const globalInstantCoreStore = initGlobalInstantCoreStore();
const schemaHashStore = initSchemaHashStore();
/**
 * Functions to log users in and out.
 *
 * @see https://instantdb.com/docs/auth
 */ class Auth {
    db;
    constructor(db){
        this.db = db;
    }
    /**
     * Sends a magic code to the user's email address.
     *
     * Once you send the magic code, see {@link auth.signInWithMagicCode} to let the
     * user verify.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *  db.auth.sendMagicCode({email: "example@gmail.com"})
     *    .catch((err) => console.error(err.body?.message))
     */ sendMagicCode = (params)=>{
        return this.db.sendMagicCode(params);
    };
    /**
     * Verify a magic code that was sent to the user's email address.
     *
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *  db.auth.signInWithMagicCode({email: "example@gmail.com", code: "123456"})
     *       .catch((err) => console.error(err.body?.message))
     */ signInWithMagicCode = (params)=>{
        return this.db.signInWithMagicCode(params);
    };
    /**
     * Sign in a user with a refresh token
     *
     * @see https://instantdb.com/docs/backend#frontend-auth-sign-in-with-token
     *
     * @example
     *   // Get the token from your backend
     *   const token = await fetch('/signin', ...);
     *   //Sign in
     *   db.auth.signInWithToken(token);
     */ signInWithToken = (token)=>{
        return this.db.signInWithCustomToken(token);
    };
    /**
     * Sign in as guest, creating a new user without email
     *
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *   db.auth.signInAsGuest();
     */ signInAsGuest = ()=>{
        return this.db.signInAsGuest();
    };
    /**
     * Create an authorization url to sign in with an external provider.
     *
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *   // Get the authorization url from your backend
     *   const url = db.auth.createAuthorizationUrl({
     *     clientName: "google",
     *     redirectURL: window.location.href,
     *   });
     *
     *   // Put it in a sign in link
     *   <a href={url}>Log in with Google</a>
     */ createAuthorizationURL = (params)=>{
        return this.db.createAuthorizationURL(params);
    };
    /**
     * Sign in with the id_token from an external provider like Google
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   db.auth
     *  .signInWithIdToken({
     *    // Token from external service
     *    idToken: id_token,
     *    // The name you gave the client when you registered it with Instant
     *    clientName: "google",
     *    // The nonce, if any, that you used when you initiated the auth flow
     *    // with the external service.
     *    nonce: your_nonce
     *  })
     *  .catch((err) => console.error(err.body?.message));
     *
     */ signInWithIdToken = (params)=>{
        return this.db.signInWithIdToken(params);
    };
    /**
     * Sign in with the id_token from an external provider like Google
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   db.auth
     *  .exchangeOAuthCode({
     *    // code received in redirect from OAuth callback
     *    code: code
     *    // The PKCE code_verifier, if any, that you used when you
     *    // initiated the auth flow
     *    codeVerifier: your_code_verifier
     *  })
     *  .catch((err) => console.error(err.body?.message));
     *
     */ exchangeOAuthCode = (params)=>{
        return this.db.exchangeCodeForToken(params);
    };
    /**
     * OpenID Discovery path for use with tools like
     * expo-auth-session that use auto-discovery of
     * OAuth parameters.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   const discovery = useAutoDiscovery(
     *     db.auth.issuerURI()
     *   );
     */ issuerURI = ()=>{
        return this.db.issuerURI();
    };
    /**
     * Sign out the current user
     */ signOut = (opts = {
        invalidateToken: true
    })=>{
        return this.db.signOut(opts);
    };
}
/**
 * Functions to manage file storage.
 */ class Storage {
    db;
    constructor(db){
        this.db = db;
    }
    /**
     * Uploads file at the provided path.
     *
     * @see https://instantdb.com/docs/storage
     * @example
     *   const [file] = e.target.files; // result of file input
     *   const data = await db.storage.uploadFile('photos/demo.png', file);
     */ uploadFile = (path, file, opts = {})=>{
        return this.db.uploadFile(path, file, opts);
    };
    /**
     * Deletes a file by path name.
     *
     * @see https://instantdb.com/docs/storage
     * @example
     *   await db.storage.delete('photos/demo.png');
     */ delete = (pathname)=>{
        return this.db.deleteFile(pathname);
    };
    // Deprecated Storage API (Jan 2025)
    // ---------------------------------
    /**
     * @deprecated. Use `db.storage.uploadFile` instead
     * remove in the future.
     */ upload = (pathname, file)=>{
        return this.db.upload(pathname, file);
    };
    /**
     * @deprecated Use `db.storage.uploadFile` instead
     */ put = this.upload;
    /**
     * @deprecated. getDownloadUrl will be removed in the future.
     * Use `useQuery` instead to query and fetch for valid urls
     *
     * db.useQuery({
     *   $files: {
     *     $: {
     *       where: {
     *         path: "moop.png"
     *       }
     *     }
     *   }
     * })
     */ getDownloadUrl = (pathname)=>{
        return this.db.getDownloadUrl(pathname);
    };
}
/**
 * Functions to manage streams.
 */ class Streams {
    db;
    constructor(db){
        this.db = db;
    }
    /**
     * Creates a new ReadableStream for the given clientId.
     *
     * @example
     *   const stream = db.streams.createReadStream({clientId: clientId})
     *   for await (const chunk of stream) {
     *     console.log(chunk);
     *   }
     */ createReadStream = (opts)=>{
        return this.db.createReadStream(opts);
    };
    /**
     * Creates a new WritableStream for the given clientId.
     *
     * @example
     *   const writeStream = db.streams.createWriteStream({clientId: clientId})
     *   const writer = writeStream.getWriter();
     *   writer.write('Hello world');
     *   writer.close();
     */ createWriteStream = (opts)=>{
        return this.db.createWriteStream(opts);
    };
}
// util
function coerceQuery(o) {
    // stringify and parse to remove undefined values
    return JSON.parse(JSON.stringify(o));
}
class InstantCoreDatabase {
    _reactor;
    auth;
    storage;
    streams;
    tx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["txInit"])();
    constructor(reactor){
        this._reactor = reactor;
        this.auth = new Auth(this._reactor);
        this.storage = new Storage(this._reactor);
        this.streams = new Streams(this._reactor);
    }
    /**
     * Use this to write data! You can create, update, delete, and link objects
     *
     * @see https://instantdb.com/docs/instaml
     *
     * @example
     *   // Create a new object in the `goals` namespace
     *   const goalId = id();
     *   db.transact(db.tx.goals[goalId].update({title: "Get fit"}))
     *
     *   // Update the title
     *   db.transact(db.tx.goals[goalId].update({title: "Get super fit"}))
     *
     *   // Delete it
     *   db.transact(db.tx.goals[goalId].delete())
     *
     *   // Or create an association:
     *   todoId = id();
     *   db.transact([
     *    db.tx.todos[todoId].update({ title: 'Go on a run' }),
     *    db.tx.goals[goalId].link({todos: todoId}),
     *  ])
     */ transact(chunks) {
        return this._reactor.pushTx(chunks);
    }
    getLocalId(name) {
        return this._reactor.getLocalId(name);
    }
    /**
     * Use this to query your data!
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *  // listen to all goals
     *  db.subscribeQuery({ goals: {} }, (resp) => {
     *    console.log(resp.data.goals)
     *  })
     *
     *  // goals where the title is "Get Fit"
     *  db.subscribeQuery(
     *    { goals: { $: { where: { title: "Get Fit" } } } },
     *    (resp) => {
     *      console.log(resp.data.goals)
     *    }
     *  )
     *
     *  // all goals, _alongside_ their todos
     *  db.subscribeQuery({ goals: { todos: {} } }, (resp) => {
     *    console.log(resp.data.goals)
     *  });
     */ subscribeQuery(query, cb, opts) {
        return this._reactor.subscribeQuery(query, cb, opts);
    }
    /**
     * Listen for the logged in state. This is useful
     * for deciding when to show a login screen.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   const unsub = db.subscribeAuth((auth) => {
     *     if (auth.user) {
     *     console.log('logged in as', auth.user.email)
     *    } else {
     *      console.log('logged out')
     *    }
     *  })
     */ subscribeAuth(cb) {
        return this._reactor.subscribeAuth(cb);
    }
    /**
     * One time query for the logged in state. This is useful
     * for scenarios where you want to know the current auth
     * state without subscribing to changes.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   const user = await db.getAuth();
     *   console.log('logged in as', user.email)
     */ getAuth() {
        return this._reactor.getAuth();
    }
    /**
     * Listen for connection status changes to Instant. This is useful
     * for building things like connectivity indicators
     *
     * @see https://www.instantdb.com/docs/patterns#connection-status
     * @example
     *   const unsub = db.subscribeConnectionStatus((status) => {
     *     const connectionState =
     *       status === 'connecting' || status === 'opened'
     *         ? 'authenticating'
     *       : status === 'authenticated'
     *         ? 'connected'
     *       : status === 'closed'
     *         ? 'closed'
     *       : status === 'errored'
     *         ? 'errored'
     *       : 'unexpected state';
     *
     *     console.log('Connection status:', connectionState);
     *   });
     */ subscribeConnectionStatus(cb) {
        return this._reactor.subscribeConnectionStatus(cb);
    }
    /**
     * Join a room to publish and subscribe to topics and presence.
     *
     * @see https://instantdb.com/docs/presence-and-topics
     * @example
     * // init
     * const db = init();
     * const room = db.joinRoom(roomType, roomId);
     * // usage
     * const unsubscribeTopic = room.subscribeTopic("foo", console.log);
     * const unsubscribePresence = room.subscribePresence({}, console.log);
     * room.publishTopic("hello", { message: "hello world!" });
     * room.publishPresence({ name: "joe" });
     * // later
     * unsubscribePresence();
     * unsubscribeTopic();
     * room.leaveRoom();
     */ joinRoom(roomType = '_defaultRoomType', roomId = '_defaultRoomId', opts) {
        const leaveRoom = this._reactor.joinRoom(roomType, roomId, opts?.initialPresence);
        return {
            leaveRoom,
            subscribeTopic: (topic, onEvent)=>this._reactor.subscribeTopic(roomType, roomId, topic, onEvent),
            subscribePresence: (opts, onChange)=>this._reactor.subscribePresence(roomType, roomId, opts, onChange),
            publishTopic: (topic, data)=>this._reactor.publishTopic({
                    roomType,
                    roomId,
                    topic,
                    data
                }),
            publishPresence: (data)=>this._reactor.publishPresence(roomType, roomId, data),
            getPresence: (opts)=>this._reactor.getPresence(roomType, roomId, opts)
        };
    }
    shutdown() {
        delete globalInstantCoreStore[reactorKey(this._reactor.config)];
        this._reactor.shutdown();
    }
    /**
     * Use this for one-off queries.
     * Returns local data if available, otherwise fetches from the server.
     * Because we want to avoid stale data, this method will throw an error
     * if the user is offline or there is no active connection to the server.
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *
     *  const resp = await db.queryOnce({ goals: {} });
     *  console.log(resp.data.goals)
     */ queryOnce(query, opts) {
        return this._reactor.queryOnce(query, opts);
    }
    /**
     * @deprecated This is an experimental function that is not yet ready for production use.
     * Use this function to sync an entire namespace.
     * It has many limitations that will be removed in the future:
     * 1. Must be used with an admin token
     * 2. Does not support permissions
     * 3. Does not support where clauses
     * 4. Does not support links
     * It also does not support multiple top-level namespaces. For example,
     *  {posts: {}, users: {}} is invalid. Only `posts` or `users` is allowed, but not both.
     */ _syncTableExperimental(query, cb) {
        return this._reactor.subscribeTable(query, cb);
    }
}
function schemaHash(schema) {
    if (!schema) {
        return '0';
    }
    const fromStore = schemaHashStore.get(schema);
    if (fromStore) {
        return fromStore;
    }
    const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(schema);
    schemaHashStore.set(schema, hash);
    return hash;
}
function schemaChanged(existingClient, newSchema) {
    return schemaHash(existingClient._reactor.config.schema) !== schemaHash(newSchema);
}
/**
 *
 * The first step: init your application!
 *
 * Visit https://instantdb.com/dash to get your `appId` :)
 *
 * @example
 *  import { init } from "@instantdb/core"
 *
 *  const db = init({ appId: "my-app-id" })
 *
 *  // You can also provide a schema for type safety and editor autocomplete!
 *
 *  import { init } from "@instantdb/core"
 *  import schema from ""../instant.schema.ts";
 *
 *  const db = init({ appId: "my-app-id", schema })
 *
 *  // To learn more: https://instantdb.com/docs/modeling-data
 */ function init(// Allows config with missing `useDateObjects`, but keeps `UseDates`
// as a non-nullable in the InstantConfig type.
config, Store, NetworkListener, versions, EventSourceImpl) {
    const configStrict = {
        ...config,
        appId: config.appId?.trim(),
        useDateObjects: config.useDateObjects ?? false
    };
    const existingClient = globalInstantCoreStore[reactorKey(configStrict)];
    if (existingClient) {
        if (schemaChanged(existingClient, configStrict.schema)) {
            existingClient._reactor.updateSchema(configStrict.schema);
        }
        return existingClient;
    }
    const reactor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$Reactor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
        ...defaultConfig,
        ...configStrict,
        cardinalityInference: configStrict.schema ? true : false
    }, Store || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$IndexedDBStorage$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], NetworkListener || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$WindowNetworkListener$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], {
        ...versions || {},
        '@instantdb/core': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
    }, EventSourceImpl);
    const client = new InstantCoreDatabase(reactor);
    globalInstantCoreStore[reactorKey(configStrict)] = client;
    handleDevtool(configStrict.appId, configStrict.devtool);
    return client;
}
function handleDevtool(appId, devtool) {
    if (typeof window === 'undefined' || typeof window.location === 'undefined' || typeof document === 'undefined') {
        return;
    }
    if (typeof devtool === 'boolean' && !devtool) {
        return;
    }
    const config = {
        position: 'bottom-right',
        allowedHosts: [
            'localhost'
        ],
        ...typeof devtool === 'object' ? devtool : {}
    };
    if (!config.allowedHosts.includes(window.location.hostname)) {
        return;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$devtool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDevtool"])(appId, config);
}
/**
 * @deprecated
 * `init_experimental` is deprecated. You can replace it with `init`.
 *
 * @example
 *
 * // Before
 * import { init_experimental } from "@instantdb/core"
 * const db = init_experimental({  ...  });
 *
 * // After
 * import { init } from "@instantdb/core"
 * const db = init({ ...  });
 */ const init_experimental = init;
;
const StorageInterface = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StoreInterface"]; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@instantdb/core/dist/esm/utils/id.js [app-client] (ecmascript) <export default as id>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "id",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/id.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@instantdb/core/dist/esm/SyncTable.js [app-client] (ecmascript) <export CallbackEventType as SyncTableCallbackEventType>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SyncTableCallbackEventType",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$SyncTable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CallbackEventType"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$SyncTable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/SyncTable.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@instantdb/react-common/dist/esm/useQuery.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useQueryInternal",
    ()=>useQueryInternal
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__weakHash$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/weakHash.js [app-client] (ecmascript) <export default as weakHash>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
;
const defaultState = {
    isLoading: true,
    data: undefined,
    pageInfo: undefined,
    error: undefined
};
function stateForResult(result) {
    return {
        isLoading: !Boolean(result),
        data: undefined,
        pageInfo: undefined,
        error: undefined,
        ...result ? result : {}
    };
}
function useQueryInternal(_core, _query, _opts) {
    if (_query && _opts && 'ruleParams' in _opts) {
        _query = {
            $$ruleParams: _opts['ruleParams'],
            ..._query
        };
    }
    const query = _query ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["coerceQuery"])(_query) : null;
    const queryHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$weakHash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__weakHash$3e$__["weakHash"])(query);
    // We use a ref to store the result of the query.
    // This is becuase `useSyncExternalStore` uses `Object.is`
    // to compare the previous and next state.
    // If we don't use a ref, the state will always be considered different, so
    // the component will always re-render.
    const resultCacheRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(stateForResult(_core._reactor.getPreviousResult(query)));
    // Similar to `resultCacheRef`, `useSyncExternalStore` will unsubscribe
    // if `subscribe` changes, so we use `useCallback` to memoize the function.
    const subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useQueryInternal.useCallback[subscribe]": (cb)=>{
            // Update the ref when the query changes to avoid showing stale data
            resultCacheRef.current = stateForResult(_core._reactor.getPreviousResult(query));
            // before the subscribeQuery is connected and calls it's own callback,
            // we might have data in the store via SSR, we need to notify useSyncExternalStore that
            // the data has changed.
            cb();
            // Don't subscribe if query is null
            if (!query) {
                const unsubscribe = {
                    "useQueryInternal.useCallback[subscribe].unsubscribe": ()=>{}
                }["useQueryInternal.useCallback[subscribe].unsubscribe"];
                return unsubscribe;
            }
            const unsubscribe = _core.subscribeQuery(query, {
                "useQueryInternal.useCallback[subscribe].unsubscribe": (result)=>{
                    resultCacheRef.current = {
                        isLoading: !Boolean(result),
                        // @ts-expect-error: ts thinks this will always be overwritten
                        data: undefined,
                        // @ts-expect-error: ts thinks this will always be overwritten
                        pageInfo: undefined,
                        // @ts-expect-error: ts thinks this will always be overwritten
                        error: undefined,
                        ...result
                    };
                    cb();
                }
            }["useQueryInternal.useCallback[subscribe].unsubscribe"]);
            return unsubscribe;
        }
    }["useQueryInternal.useCallback[subscribe]"], // Build a new subscribe function if the query changes
    [
        queryHash
    ]);
    const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, {
        "useQueryInternal.useSyncExternalStore[state]": ()=>resultCacheRef.current
    }["useQueryInternal.useSyncExternalStore[state]"], {
        "useQueryInternal.useSyncExternalStore[state]": ()=>defaultState
    }["useQueryInternal.useSyncExternalStore[state]"]);
    return {
        state,
        query
    };
} //# sourceMappingURL=useQuery.js.map
}),
"[project]/node_modules/@instantdb/react-common/dist/esm/useTimeout.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useTimeout",
    ()=>useTimeout
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
function useTimeout() {
    const timeoutRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useTimeout.useEffect": ()=>{
            clear();
        }
    }["useTimeout.useEffect"], []);
    function set(delay, fn) {
        clear();
        timeoutRef.current = setTimeout(fn, delay);
    }
    function clear() {
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }
    }
    return {
        set,
        clear
    };
} //# sourceMappingURL=useTimeout.js.map
}),
"[project]/node_modules/@instantdb/react-common/dist/esm/InstantReactRoom.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InstantReactRoom",
    ()=>InstantReactRoom,
    "defaultActivityStopTimeout",
    ()=>defaultActivityStopTimeout,
    "rooms",
    ()=>rooms,
    "usePresence",
    ()=>usePresence,
    "usePublishTopic",
    ()=>usePublishTopic,
    "useSyncPresence",
    ()=>useSyncPresence,
    "useTopicEffect",
    ()=>useTopicEffect,
    "useTypingIndicator",
    ()=>useTypingIndicator
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$useTimeout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react-common/dist/esm/useTimeout.js [app-client] (ecmascript)");
;
;
const defaultActivityStopTimeout = 1_000;
function useTopicEffect(room, topic, onEvent) {
    const onEventRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(onEvent);
    onEventRef.current = onEvent;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useTopicEffect.useEffect": ()=>{
            const unsub = room.core._reactor.subscribeTopic(room.type, room.id, topic, {
                "useTopicEffect.useEffect.unsub": (event, peer)=>{
                    onEventRef.current(event, peer);
                }
            }["useTopicEffect.useEffect.unsub"]);
            return unsub;
        }
    }["useTopicEffect.useEffect"], [
        room.id,
        topic
    ]);
}
function usePublishTopic(room, topic) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "usePublishTopic.useEffect": ()=>room.core._reactor.joinRoom(room.type, room.id)
    }["usePublishTopic.useEffect"], [
        room.id
    ]);
    const publishTopic = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "usePublishTopic.useCallback[publishTopic]": (data)=>{
            room.core._reactor.publishTopic({
                roomType: room.type,
                roomId: room.id,
                topic,
                data
            });
        }
    }["usePublishTopic.useCallback[publishTopic]"], [
        room.id,
        topic
    ]);
    return publishTopic;
}
function usePresence(room, opts = {}) {
    const [state, setState] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "usePresence.useState": ()=>{
            return room.core._reactor.getPresence(room.type, room.id, opts) ?? {
                peers: {},
                isLoading: true
            };
        }
    }["usePresence.useState"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "usePresence.useEffect": ()=>{
            const unsub = room.core._reactor.subscribePresence(room.type, room.id, opts, {
                "usePresence.useEffect.unsub": (data)=>{
                    setState(data);
                }
            }["usePresence.useEffect.unsub"]);
            return unsub;
        }
    }["usePresence.useEffect"], [
        room.id,
        opts.user,
        opts.peers?.join(),
        opts.keys?.join()
    ]);
    const publishPresence = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "usePresence.useCallback[publishPresence]": (data)=>{
            room.core._reactor.publishPresence(room.type, room.id, data);
        }
    }["usePresence.useCallback[publishPresence]"], [
        room.type,
        room.id
    ]);
    const ret = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "usePresence.useMemo[ret]": ()=>{
            return {
                ...state,
                publishPresence
            };
        }
    }["usePresence.useMemo[ret]"], [
        state,
        publishPresence
    ]);
    return ret;
}
function useSyncPresence(room, data, deps) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useSyncPresence.useEffect": ()=>room.core._reactor.joinRoom(room.type, room.id, data)
    }["useSyncPresence.useEffect"], [
        room.id
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useSyncPresence.useEffect": ()=>{
            return room.core._reactor.publishPresence(room.type, room.id, data);
        }
    }["useSyncPresence.useEffect"], [
        room.type,
        room.id,
        deps ?? JSON.stringify(data)
    ]);
}
function useTypingIndicator(room, inputName, opts = {}) {
    const timeout = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$useTimeout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useTimeout"])();
    const observedPresence = rooms.usePresence(room, {
        keys: [
            inputName
        ]
    });
    const active = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useTypingIndicator.useMemo[active]": ()=>{
            const presenceSnapshot = room._core._reactor.getPresence(room.type, room.id);
            return opts?.writeOnly ? [] : Object.values(presenceSnapshot?.peers ?? {}).filter({
                "useTypingIndicator.useMemo[active]": (p)=>p[inputName] === true
            }["useTypingIndicator.useMemo[active]"]);
        }
    }["useTypingIndicator.useMemo[active]"], [
        opts?.writeOnly,
        observedPresence
    ]);
    const setActive = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useTypingIndicator.useCallback[setActive]": (isActive)=>{
            room.core._reactor.publishPresence(room.type, room.id, {
                [inputName]: isActive
            });
            if (!isActive) return;
            if (opts?.timeout === null || opts?.timeout === 0) return;
            timeout.set(opts?.timeout ?? defaultActivityStopTimeout, {
                "useTypingIndicator.useCallback[setActive]": ()=>{
                    room.core._reactor.publishPresence(room.type, room.id, {
                        [inputName]: null
                    });
                }
            }["useTypingIndicator.useCallback[setActive]"]);
        }
    }["useTypingIndicator.useCallback[setActive]"], [
        room.type,
        room.id,
        inputName,
        opts?.timeout,
        timeout
    ]);
    const onKeyDown = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useTypingIndicator.useCallback[onKeyDown]": (e)=>{
            const isEnter = opts?.stopOnEnter && e.key === 'Enter';
            const isActive = !isEnter;
            setActive(isActive);
        }
    }["useTypingIndicator.useCallback[onKeyDown]"], [
        opts.stopOnEnter,
        setActive
    ]);
    const onBlur = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useTypingIndicator.useCallback[onBlur]": ()=>{
            setActive(false);
        }
    }["useTypingIndicator.useCallback[onBlur]"], [
        setActive
    ]);
    const inputProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useTypingIndicator.useMemo[inputProps]": ()=>{
            return {
                onKeyDown,
                onBlur
            };
        }
    }["useTypingIndicator.useMemo[inputProps]"], [
        onKeyDown,
        onBlur
    ]);
    return {
        active,
        setActive,
        inputProps
    };
}
const rooms = {
    useTopicEffect,
    usePublishTopic,
    usePresence,
    useSyncPresence,
    useTypingIndicator
};
class InstantReactRoom {
    core;
    /** @deprecated use `core` instead */ _core;
    type;
    id;
    constructor(core, type, id){
        this.core = core;
        this._core = this.core;
        this.type = type;
        this.id = id;
    }
    /**
     * @deprecated
     * `db.room(...).useTopicEffect` is deprecated. You can replace it with `db.rooms.useTopicEffect`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * room.useTopicEffect('emoji', (message, peer) => {  });
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * db.rooms.useTopicEffect(room, 'emoji', (message, peer) => {  });
     */ useTopicEffect = (topic, onEvent)=>{
        rooms.useTopicEffect(this, topic, onEvent);
    };
    /**
     * @deprecated
     * `db.room(...).usePublishTopic` is deprecated. You can replace it with `db.rooms.usePublishTopic`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * const publish = room.usePublishTopic('emoji');
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * const publish = db.rooms.usePublishTopic(room, 'emoji');
     */ usePublishTopic = (topic)=>{
        return rooms.usePublishTopic(this, topic);
    };
    /**
     * @deprecated
     * `db.room(...).usePresence` is deprecated. You can replace it with `db.rooms.usePresence`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * const { peers } = room.usePresence({ keys: ["name", "avatar"] });
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * const { peers } = db.rooms.usePresence(room, { keys: ["name", "avatar"] });
     */ usePresence = (opts = {})=>{
        return rooms.usePresence(this, opts);
    };
    /**
     * @deprecated
     * `db.room(...).useSyncPresence` is deprecated. You can replace it with `db.rooms.useSyncPresence`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * room.useSyncPresence(room, { nickname });
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * db.rooms.useSyncPresence(room, { nickname });
     */ useSyncPresence = (data, deps)=>{
        return rooms.useSyncPresence(this, data, deps);
    };
    /**
     * @deprecated
     * `db.room(...).useTypingIndicator` is deprecated. You can replace it with `db.rooms.useTypingIndicator`.
     *
     * @example
     *
     * // Before
     * const room = db.room('chat', 'room-id');
     * const typing = room.useTypingIndiactor(room, 'chat-input');
     *
     * // After
     * const room = db.room('chat', 'room-id');
     * const typing = db.rooms.useTypingIndiactor(room, 'chat-input');
     */ useTypingIndicator = (inputName, opts = {})=>{
        return rooms.useTypingIndicator(this, inputName, opts);
    };
} //# sourceMappingURL=InstantReactRoom.js.map
}),
"[project]/node_modules/@instantdb/react-common/dist/esm/InstantReactAbstractDatabase.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>InstantReactAbstractDatabase
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/instatx.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/InstantError.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$useQuery$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react-common/dist/esm/useQuery.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$InstantReactRoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react-common/dist/esm/InstantReactRoom.js [app-client] (ecmascript)");
'use client';
;
;
;
;
;
const defaultAuthState = {
    isLoading: true,
    user: undefined,
    error: undefined
};
class InstantReactAbstractDatabase {
    tx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["txInit"])();
    auth;
    storage;
    streams;
    core;
    /** @deprecated use `core` instead */ _core;
    static Store;
    static NetworkListener;
    static EventSourceImpl;
    constructor(config, versions){
        this.core = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["init"])(config, // @ts-expect-error because TS can't resolve subclass statics
        config.Store || this.constructor.Store, // @ts-expect-error because TS can't resolve subclass statics
        this.constructor.NetworkListener, versions, // @ts-expect-error because TS can't resolve subclass statics
        this.constructor.EventSourceImpl);
        this._core = this.core;
        this.auth = this.core.auth;
        this.storage = this.core.storage;
        this.streams = this.core.streams;
    }
    /**
     * Returns a unique ID for a given `name`. It's stored in local storage,
     * so you will get the same ID across sessions.
     *
     * This is useful for generating IDs that could identify a local device or user.
     *
     * @example
     *  const deviceId = await db.getLocalId('device');
     */ getLocalId = (name)=>{
        return this.core.getLocalId(name);
    };
    /**
     * A hook that returns a unique ID for a given `name`. localIds are
     * stored in local storage, so you will get the same ID across sessions.
     *
     * Initially returns `null`, and then loads the localId.
     *
     * @example
     * const deviceId = db.useLocalId('device');
     * if (!deviceId) return null; // loading
     * console.log('Device ID:', deviceId)
     */ useLocalId = (name)=>{
        const [localId, setLocalId] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
            "useEffect": ()=>{
                let mounted = true;
                const f = {
                    "useEffect.f": async ()=>{
                        const id = await this.getLocalId(name);
                        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                        ;
                        setLocalId(id);
                    }
                }["useEffect.f"];
                f();
                return;
            }
        }["useEffect"], [
            name
        ]);
        return localId;
    };
    /**
     * Obtain a handle to a room, which allows you to listen to topics and presence data
     *
     * If you don't provide a `type` or `id`, Instant will default to `_defaultRoomType` and `_defaultRoomId`
     * as the room type and id, respectively.
     *
     * @see https://instantdb.com/docs/presence-and-topics
     *
     * @example
     *  const room = db.room('chat', roomId);
     *  const { peers } = db.rooms.usePresence(room);
     */ room(type = '_defaultRoomType', id = '_defaultRoomId') {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$InstantReactRoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantReactRoom"](this.core, type, id);
    }
    /**
     * Hooks for working with rooms
     *
     * @see https://instantdb.com/docs/presence-and-topics
     *
     * @example
     *  const room = db.room('chat', roomId);
     *  const { peers } = db.rooms.usePresence(room);
     *  const publish = db.rooms.usePublishTopic(room, 'emoji');
     *  // ...
     */ rooms = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$InstantReactRoom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rooms"];
    /**
     * Use this to write data! You can create, update, delete, and link objects
     *
     * @see https://instantdb.com/docs/instaml
     *
     * @example
     *   // Create a new object in the `goals` namespace
     *   const goalId = id();
     *   db.transact(db.tx.goals[goalId].update({title: "Get fit"}))
     *
     *   // Update the title
     *   db.transact(db.tx.goals[goalId].update({title: "Get super fit"}))
     *
     *   // Delete it
     *   db.transact(db.tx.goals[goalId].delete())
     *
     *   // Or create an association:
     *   todoId = id();
     *   db.transact([
     *    db.tx.todos[todoId].update({ title: 'Go on a run' }),
     *    db.tx.goals[goalId].link({todos: todoId}),
     *  ])
     */ transact = (chunks)=>{
        return this.core.transact(chunks);
    };
    /**
     * Use this to query your data!
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *   // listen to all goals
     *   const { isLoading, error, data } = db.useQuery({ goals: {} });
     *
     *   // goals where the title is "Get Fit"
     *   const { isLoading, error, data } = db.useQuery({
     *     goals: { $: { where: { title: 'Get Fit' } } },
     *   });
     *
     *   // all goals, _alongside_ their todos
     *   const { isLoading, error, data } = db.useQuery({
     *     goals: { todos: {} },
     *   });
     *
     *   // skip if `user` is not logged in
     *   const { isLoading, error, data } = db.useQuery(
     *     auth.user ? { goals: {} } : null,
     *   );
     */ useQuery = (query, opts)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$useQuery$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryInternal"])(this.core, query, opts).state;
    };
    /**
     * Listen for the logged in state. This is useful
     * for deciding when to show a login screen.
     *
     * Check out the docs for an example `Login` component too!
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *  function App() {
     *    const { isLoading, user, error } = db.useAuth()
     *    if (isLoading) {
     *      return <div>Loading...</div>
     *    }
     *    if (error) {
     *      return <div>Uh oh! {error.message}</div>
     *    }
     *    if (user) {
     *      return <Main user={user} />
     *    }
     *    return <Login />
     *  }
     *
     */ useAuth = ()=>{
        return this._useAuth();
    };
    _useAuth() {
        // We use a ref to store the result of the query.
        // This is becuase `useSyncExternalStore` uses `Object.is`
        // to compare the previous and next state.
        // If we don't use a ref, the state will always be considered different, so
        // the component will always re-render.
        const resultCacheRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(this.core._reactor._currentUserCached);
        // Similar to `resultCacheRef`, `useSyncExternalStore` will unsubscribe
        // if `subscribe` changes, so we use `useCallback` to memoize the function.
        const subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "useCallback[subscribe]": (cb)=>{
                const unsubscribe = this.core.subscribeAuth({
                    "useCallback[subscribe].unsubscribe": (auth)=>{
                        resultCacheRef.current = {
                            isLoading: false,
                            ...auth
                        };
                        cb();
                    }
                }["useCallback[subscribe].unsubscribe"]);
                return unsubscribe;
            }
        }["useCallback[subscribe]"], []);
        const state = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, {
            "useSyncExternalStore[state]": ()=>resultCacheRef.current
        }["useSyncExternalStore[state]"], {
            "useSyncExternalStore[state]": ()=>defaultAuthState
        }["useSyncExternalStore[state]"]);
        return state;
    }
    /**
     * Subscribe to the currently logged in user.
     * If the user is not logged in, this hook with throw an Error.
     * You will want to protect any calls of this hook with a
     * <db.SignedIn> component, or your own logic based on db.useAuth()
     *
     * @see https://instantdb.com/docs/auth
     * @throws Error indicating user not signed in
     * @example
     *  function UserDisplay() {
     *    const user = db.useUser()
     *    return <div>Logged in as: {user.email}</div>
     *  }
     *
     *  <db.SignedIn>
     *    <UserDisplay />
     *  </db.SignedIn>
     *
     */ useUser = ()=>{
        const { user } = this.useAuth();
        if (!user) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$InstantError$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InstantError"]('useUser must be used within an auth-protected route');
        }
        return user;
    };
    /**
     * One time query for the logged in state. This is useful
     * for scenarios where you want to know the current auth
     * state without subscribing to changes.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   const user = await db.getAuth();
     *   console.log('logged in as', user.email)
     */ getAuth() {
        return this.core.getAuth();
    }
    /**
     * Listen for connection status changes to Instant. Use this for things like
     * showing connection state to users
     *
     * @see https://www.instantdb.com/docs/patterns#connection-status
     * @example
     *  function App() {
     *    const status = db.useConnectionStatus()
     *    const connectionState =
     *      status === 'connecting' || status === 'opened'
     *        ? 'authenticating'
     *      : status === 'authenticated'
     *        ? 'connected'
     *      : status === 'closed'
     *        ? 'closed'
     *      : status === 'errored'
     *        ? 'errored'
     *      : 'unexpected state';
     *
     *    return <div>Connection state: {connectionState}</div>
     *  }
     */ useConnectionStatus = ()=>{
        const statusRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(this.core._reactor.status);
        const subscribe = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
            "useCallback[subscribe]": (cb)=>{
                const unsubscribe = this.core.subscribeConnectionStatus({
                    "useCallback[subscribe].unsubscribe": (newStatus)=>{
                        if (newStatus !== statusRef.current) {
                            statusRef.current = newStatus;
                            cb();
                        }
                    }
                }["useCallback[subscribe].unsubscribe"]);
                return unsubscribe;
            }
        }["useCallback[subscribe]"], []);
        const status = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(subscribe, {
            "useSyncExternalStore[status]": ()=>statusRef.current
        }["useSyncExternalStore[status]"], {
            "useSyncExternalStore[status]": // For SSR, always return 'connecting' as the initial state
            ()=>'connecting'
        }["useSyncExternalStore[status]"]);
        return status;
    };
    /**
     * Use this for one-off queries.
     * Returns local data if available, otherwise fetches from the server.
     * Because we want to avoid stale data, this method will throw an error
     * if the user is offline or there is no active connection to the server.
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *
     *  const resp = await db.queryOnce({ goals: {} });
     *  console.log(resp.data.goals)
     */ queryOnce = (query, opts)=>{
        return this.core.queryOnce(query, opts);
    };
    /**
     * Only render children if the user is signed in.
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *  <db.SignedIn>
     *    <MyComponent />
     *  </db.SignedIn>
     *
     */ SignedIn = ({ children })=>{
        const auth = this.useAuth();
        if (auth.isLoading || auth.error || !auth.user) return null;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
            children: children
        });
    };
    /**
     * Only render children if the user is signed out.
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *  <db.SignedOut>
     *    <MyComponent />
     *  </db.SignedOut>
     *
     */ SignedOut = ({ children })=>{
        const auth = this.useAuth();
        if (auth.isLoading || auth.error || auth.user) return null;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
            children: children
        });
    };
} //# sourceMappingURL=InstantReactAbstractDatabase.js.map
}),
"[project]/node_modules/@instantdb/react-common/dist/esm/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$InstantReactAbstractDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react-common/dist/esm/InstantReactAbstractDatabase.js [app-client] (ecmascript)");
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@instantdb/react-common/dist/esm/InstantReactAbstractDatabase.js [app-client] (ecmascript) <export default as InstantReactAbstractDatabase>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InstantReactAbstractDatabase",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$InstantReactAbstractDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$InstantReactAbstractDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react-common/dist/esm/InstantReactAbstractDatabase.js [app-client] (ecmascript)");
}),
"[project]/node_modules/eventsource-parser/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ParseError",
    ()=>ParseError,
    "createParser",
    ()=>createParser
]);
class ParseError extends Error {
    constructor(message, options){
        super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
    }
}
function noop(_arg) {}
function createParser(callbacks) {
    if (typeof callbacks == "function") throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
    const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
    let incompleteLine = "", isFirstChunk = !0, id, data = "", eventType = "";
    function feed(newChunk) {
        const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
        for (const line of complete)parseLine(line);
        incompleteLine = incomplete, isFirstChunk = !1;
    }
    function parseLine(line) {
        if (line === "") {
            dispatchEvent();
            return;
        }
        if (line.startsWith(":")) {
            onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
            return;
        }
        const fieldSeparatorIndex = line.indexOf(":");
        if (fieldSeparatorIndex !== -1) {
            const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
            processField(field, value, line);
            return;
        }
        processField(line, "", line);
    }
    function processField(field, value, line) {
        switch(field){
            case "event":
                eventType = value;
                break;
            case "data":
                data = `${data}${value}
`;
                break;
            case "id":
                id = value.includes("\0") ? void 0 : value;
                break;
            case "retry":
                /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \`retry\` value: "${value}"`, {
                    type: "invalid-retry",
                    value,
                    line
                }));
                break;
            default:
                onError(new ParseError(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`, {
                    type: "unknown-field",
                    field,
                    value,
                    line
                }));
                break;
        }
    }
    function dispatchEvent() {
        data.length > 0 && onEvent({
            id,
            event: eventType || void 0,
            // If the data buffer's last character is a U+000A LINE FEED (LF) character,
            // then remove the last character from the data buffer.
            data: data.endsWith(`
`) ? data.slice(0, -1) : data
        }), id = void 0, data = "", eventType = "";
    }
    function reset(options = {}) {
        incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = !0, id = void 0, data = "", eventType = "", incompleteLine = "";
    }
    return {
        feed,
        reset
    };
}
function splitLines(chunk) {
    const lines = [];
    let incompleteLine = "", searchIndex = 0;
    for(; searchIndex < chunk.length;){
        const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
        let lineEnd = -1;
        if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
            incompleteLine = chunk.slice(searchIndex);
            break;
        } else {
            const line = chunk.slice(searchIndex, lineEnd);
            lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
        }
    }
    return [
        lines,
        incompleteLine
    ];
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/eventsource/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ErrorEvent",
    ()=>ErrorEvent,
    "EventSource",
    ()=>EventSource
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventsource$2d$parser$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/eventsource-parser/dist/index.js [app-client] (ecmascript)");
;
class ErrorEvent extends Event {
    /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */ constructor(type, errorEventInitDict){
        var _a, _b;
        super(type), this.code = (_a = errorEventInitDict == null ? void 0 : errorEventInitDict.code) != null ? _a : void 0, this.message = (_b = errorEventInitDict == null ? void 0 : errorEventInitDict.message) != null ? _b : void 0;
    }
    /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */ [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
        return inspect(inspectableError(this), options);
    }
    /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */ [Symbol.for("Deno.customInspect")](inspect, options) {
        return inspect(inspectableError(this), options);
    }
}
function syntaxError(message) {
    const DomException = globalThis.DOMException;
    return typeof DomException == "function" ? new DomException(message, "SyntaxError") : new SyntaxError(message);
}
function flattenError(err) {
    return err instanceof Error ? "errors" in err && Array.isArray(err.errors) ? err.errors.map(flattenError).join(", ") : "cause" in err && err.cause instanceof Error ? `${err}: ${flattenError(err.cause)}` : err.message : `${err}`;
}
function inspectableError(err) {
    return {
        type: err.type,
        message: err.message,
        code: err.code,
        defaultPrevented: err.defaultPrevented,
        cancelable: err.cancelable,
        timeStamp: err.timeStamp
    };
}
var __typeError = (msg)=>{
    throw TypeError(msg);
}, __accessCheck = (obj, member, msg)=>member.has(obj) || __typeError("Cannot " + msg), __privateGet = (obj, member, getter)=>(__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj)), __privateAdd = (obj, member, value)=>member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value), __privateSet = (obj, member, value, setter)=>(__accessCheck(obj, member, "write to private field"), member.set(obj, value), value), __privateMethod = (obj, member, method)=>(__accessCheck(obj, member, "access private method"), method), _readyState, _url, _redirectUrl, _withCredentials, _fetch, _reconnectInterval, _reconnectTimer, _lastEventId, _controller, _parser, _onError, _onMessage, _onOpen, _EventSource_instances, connect_fn, _onFetchResponse, _onFetchError, getRequestOptions_fn, _onEvent, _onRetryChange, failConnection_fn, scheduleReconnect_fn, _reconnect;
class EventSource extends EventTarget {
    constructor(url, eventSourceInitDict){
        var _a, _b;
        super(), __privateAdd(this, _EventSource_instances), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, __privateAdd(this, _readyState), __privateAdd(this, _url), __privateAdd(this, _redirectUrl), __privateAdd(this, _withCredentials), __privateAdd(this, _fetch), __privateAdd(this, _reconnectInterval), __privateAdd(this, _reconnectTimer), __privateAdd(this, _lastEventId, null), __privateAdd(this, _controller), __privateAdd(this, _parser), __privateAdd(this, _onError, null), __privateAdd(this, _onMessage, null), __privateAdd(this, _onOpen, null), __privateAdd(this, _onFetchResponse, async (response)=>{
            var _a2;
            __privateGet(this, _parser).reset();
            const { body, redirected, status, headers } = response;
            if (status === 204) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
                return;
            }
            if (redirected ? __privateSet(this, _redirectUrl, new URL(response.url)) : __privateSet(this, _redirectUrl, void 0), status !== 200) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, `Non-200 status code (${status})`, status);
                return;
            }
            if (!(headers.get("content-type") || "").startsWith("text/event-stream")) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, 'Invalid content type, expected "text/event-stream"', status);
                return;
            }
            if (__privateGet(this, _readyState) === this.CLOSED) return;
            __privateSet(this, _readyState, this.OPEN);
            const openEvent = new Event("open");
            if ((_a2 = __privateGet(this, _onOpen)) == null || _a2.call(this, openEvent), this.dispatchEvent(openEvent), typeof body != "object" || !body || !("getReader" in body)) {
                __privateMethod(this, _EventSource_instances, failConnection_fn).call(this, "Invalid response body, expected a web ReadableStream", status), this.close();
                return;
            }
            const decoder = new TextDecoder(), reader = body.getReader();
            let open = !0;
            do {
                const { done, value } = await reader.read();
                value && __privateGet(this, _parser).feed(decoder.decode(value, {
                    stream: !done
                })), done && (open = !1, __privateGet(this, _parser).reset(), __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this));
            }while (open)
        }), __privateAdd(this, _onFetchError, (err)=>{
            __privateSet(this, _controller, void 0), !(err.name === "AbortError" || err.type === "aborted") && __privateMethod(this, _EventSource_instances, scheduleReconnect_fn).call(this, flattenError(err));
        }), __privateAdd(this, _onEvent, (event)=>{
            typeof event.id == "string" && __privateSet(this, _lastEventId, event.id);
            const messageEvent = new MessageEvent(event.event || "message", {
                data: event.data,
                origin: __privateGet(this, _redirectUrl) ? __privateGet(this, _redirectUrl).origin : __privateGet(this, _url).origin,
                lastEventId: event.id || ""
            });
            __privateGet(this, _onMessage) && (!event.event || event.event === "message") && __privateGet(this, _onMessage).call(this, messageEvent), this.dispatchEvent(messageEvent);
        }), __privateAdd(this, _onRetryChange, (value)=>{
            __privateSet(this, _reconnectInterval, value);
        }), __privateAdd(this, _reconnect, ()=>{
            __privateSet(this, _reconnectTimer, void 0), __privateGet(this, _readyState) === this.CONNECTING && __privateMethod(this, _EventSource_instances, connect_fn).call(this);
        });
        try {
            if (url instanceof URL) __privateSet(this, _url, url);
            else if (typeof url == "string") __privateSet(this, _url, new URL(url, getBaseURL()));
            else throw new Error("Invalid URL");
        } catch  {
            throw syntaxError("An invalid or illegal string was specified");
        }
        __privateSet(this, _parser, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventsource$2d$parser$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createParser"])({
            onEvent: __privateGet(this, _onEvent),
            onRetry: __privateGet(this, _onRetryChange)
        })), __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _reconnectInterval, 3e3), __privateSet(this, _fetch, (_a = eventSourceInitDict == null ? void 0 : eventSourceInitDict.fetch) != null ? _a : globalThis.fetch), __privateSet(this, _withCredentials, (_b = eventSourceInitDict == null ? void 0 : eventSourceInitDict.withCredentials) != null ? _b : !1), __privateMethod(this, _EventSource_instances, connect_fn).call(this);
    }
    /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */ get readyState() {
        return __privateGet(this, _readyState);
    }
    /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */ get url() {
        return __privateGet(this, _url).href;
    }
    /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */ get withCredentials() {
        return __privateGet(this, _withCredentials);
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */ get onerror() {
        return __privateGet(this, _onError);
    }
    set onerror(value) {
        __privateSet(this, _onError, value);
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */ get onmessage() {
        return __privateGet(this, _onMessage);
    }
    set onmessage(value) {
        __privateSet(this, _onMessage, value);
    }
    /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */ get onopen() {
        return __privateGet(this, _onOpen);
    }
    set onopen(value) {
        __privateSet(this, _onOpen, value);
    }
    addEventListener(type, listener, options) {
        const listen = listener;
        super.addEventListener(type, listen, options);
    }
    removeEventListener(type, listener, options) {
        const listen = listener;
        super.removeEventListener(type, listen, options);
    }
    /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */ close() {
        __privateGet(this, _reconnectTimer) && clearTimeout(__privateGet(this, _reconnectTimer)), __privateGet(this, _readyState) !== this.CLOSED && (__privateGet(this, _controller) && __privateGet(this, _controller).abort(), __privateSet(this, _readyState, this.CLOSED), __privateSet(this, _controller, void 0));
    }
}
_readyState = /* @__PURE__ */ new WeakMap(), _url = /* @__PURE__ */ new WeakMap(), _redirectUrl = /* @__PURE__ */ new WeakMap(), _withCredentials = /* @__PURE__ */ new WeakMap(), _fetch = /* @__PURE__ */ new WeakMap(), _reconnectInterval = /* @__PURE__ */ new WeakMap(), _reconnectTimer = /* @__PURE__ */ new WeakMap(), _lastEventId = /* @__PURE__ */ new WeakMap(), _controller = /* @__PURE__ */ new WeakMap(), _parser = /* @__PURE__ */ new WeakMap(), _onError = /* @__PURE__ */ new WeakMap(), _onMessage = /* @__PURE__ */ new WeakMap(), _onOpen = /* @__PURE__ */ new WeakMap(), _EventSource_instances = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/ connect_fn = function() {
    __privateSet(this, _readyState, this.CONNECTING), __privateSet(this, _controller, new AbortController()), __privateGet(this, _fetch)(__privateGet(this, _url), __privateMethod(this, _EventSource_instances, getRequestOptions_fn).call(this)).then(__privateGet(this, _onFetchResponse)).catch(__privateGet(this, _onFetchError));
}, _onFetchResponse = /* @__PURE__ */ new WeakMap(), _onFetchError = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/ getRequestOptions_fn = function() {
    var _a;
    const init = {
        // [spec] Let `corsAttributeState` be `Anonymous`â€¦
        // [spec] â€¦will have their mode set to "cors"â€¦
        mode: "cors",
        redirect: "follow",
        headers: {
            Accept: "text/event-stream",
            ...__privateGet(this, _lastEventId) ? {
                "Last-Event-ID": __privateGet(this, _lastEventId)
            } : void 0
        },
        cache: "no-store",
        signal: (_a = __privateGet(this, _controller)) == null ? void 0 : _a.signal
    };
    return "window" in globalThis && (init.credentials = this.withCredentials ? "include" : "same-origin"), init;
}, _onEvent = /* @__PURE__ */ new WeakMap(), _onRetryChange = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/ failConnection_fn = function(message, code) {
    var _a;
    __privateGet(this, _readyState) !== this.CLOSED && __privateSet(this, _readyState, this.CLOSED);
    const errorEvent = new ErrorEvent("error", {
        code,
        message
    });
    (_a = __privateGet(this, _onError)) == null || _a.call(this, errorEvent), this.dispatchEvent(errorEvent);
}, /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/ scheduleReconnect_fn = function(message, code) {
    var _a;
    if (__privateGet(this, _readyState) === this.CLOSED) return;
    __privateSet(this, _readyState, this.CONNECTING);
    const errorEvent = new ErrorEvent("error", {
        code,
        message
    });
    (_a = __privateGet(this, _onError)) == null || _a.call(this, errorEvent), this.dispatchEvent(errorEvent), __privateSet(this, _reconnectTimer, setTimeout(__privateGet(this, _reconnect), __privateGet(this, _reconnectInterval)));
}, _reconnect = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/ EventSource.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/ EventSource.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/ EventSource.CLOSED = 2;
Object.defineProperty(EventSource, Symbol.for("eventsource.supports-fetch-override"), {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1
});
function getBaseURL() {
    const doc = "document" in globalThis ? globalThis.document : void 0;
    return doc && typeof doc == "object" && "baseURI" in doc && typeof doc.baseURI == "string" ? doc.baseURI : void 0;
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@instantdb/react/dist/esm/InstantReactWebDatabase.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>InstantReactWebDatabase
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react-common/dist/esm/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$InstantReactAbstractDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__InstantReactAbstractDatabase$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react-common/dist/esm/InstantReactAbstractDatabase.js [app-client] (ecmascript) <export default as InstantReactAbstractDatabase>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventsource$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/eventsource/dist/index.js [app-client] (ecmascript)");
;
;
class InstantReactWebDatabase extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$InstantReactAbstractDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__InstantReactAbstractDatabase$3e$__["InstantReactAbstractDatabase"] {
    static EventSourceImpl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventsource$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventSource"];
} //# sourceMappingURL=InstantReactWebDatabase.js.map
}),
"[project]/node_modules/@instantdb/react/dist/esm/version.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$version$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/version/dist/esm/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$version$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/version/dist/esm/version.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$version$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"];
 //# sourceMappingURL=version.js.map
}),
"[project]/node_modules/@instantdb/react/dist/esm/init.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "init",
    ()=>init,
    "init_experimental",
    ()=>init_experimental
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$esm$2f$InstantReactWebDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react/dist/esm/InstantReactWebDatabase.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react/dist/esm/version.js [app-client] (ecmascript)");
;
;
function init(// Allows config with missing `useDateObjects`, but keeps `UseDates`
// as a non-nullable in the InstantConfig type.
config) {
    const configStrict = {
        ...config,
        useDateObjects: config.useDateObjects ?? false
    };
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$esm$2f$InstantReactWebDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](configStrict, {
        '@instantdb/react': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
    });
}
const init_experimental = init; //# sourceMappingURL=init.js.map
}),
"[project]/node_modules/@instantdb/react/dist/esm/Cursors.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Cursors",
    ()=>Cursors
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
;
function Cursors({ as = 'div', spaceId: _spaceId, room, className, style, userCursorColor, children, renderCursor, propagate, zIndex }) {
    const spaceId = _spaceId || `cursors-space-default--${String(room.type)}-${room.id}`;
    const cursorsPresence = room.usePresence({
        keys: [
            spaceId
        ]
    });
    const fullPresence = room._core._reactor.getPresence(room.type, room.id);
    function publishCursor(rect, touch) {
        const x = touch.clientX;
        const y = touch.clientY;
        const xPercent = (x - rect.left) / rect.width * 100;
        const yPercent = (y - rect.top) / rect.height * 100;
        cursorsPresence.publishPresence({
            [spaceId]: {
                x,
                y,
                xPercent,
                yPercent,
                color: userCursorColor
            }
        });
    }
    function onMouseMove(e) {
        if (!propagate) {
            e.stopPropagation();
        }
        const rect = e.currentTarget.getBoundingClientRect();
        publishCursor(rect, e);
    }
    function onMouseOut(e) {
        cursorsPresence.publishPresence({
            [spaceId]: undefined
        });
    }
    function onTouchMove(e) {
        if (e.touches.length !== 1) {
            return;
        }
        const touch = e.touches[0];
        if (touch.target instanceof Element) {
            if (!propagate) {
                e.stopPropagation();
            }
            const rect = touch.target.getBoundingClientRect();
            publishCursor(rect, touch);
        }
    }
    function onTouchEnd(e) {
        cursorsPresence.publishPresence({
            [spaceId]: undefined
        });
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(as, {
        onMouseMove,
        onMouseOut,
        onTouchMove,
        onTouchEnd,
        className,
        style: {
            position: 'relative',
            ...style
        }
    }, [
        children,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
            style: {
                ...absStyles,
                ...inertStyles,
                zIndex: zIndex !== undefined ? zIndex : defaultZ
            },
            children: Object.entries(cursorsPresence.peers).map(([id, presence])=>{
                const cursor = presence[spaceId];
                if (!cursor) return null;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("div", {
                    style: {
                        ...absStyles,
                        transform: `translate(${cursor.xPercent}%, ${cursor.yPercent}%)`,
                        transformOrigin: '0 0',
                        transition: 'transform 100ms'
                    },
                    children: renderCursor ? renderCursor({
                        color: cursor.color,
                        presence: fullPresence?.peers[id]
                    }) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Cursor, {
                        ...cursor
                    })
                }, id);
            })
        }, spaceId)
    ]);
}
function Cursor({ color }) {
    const size = 35;
    const fill = color || 'black';
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("svg", {
        style: {
            height: size,
            width: size
        },
        viewBox: `0 0 ${size} ${size}`,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                fill: "rgba(0,0,0,.2)",
                transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)",
                children: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z"
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z"
                    })
                ]
            }),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                fill: "white",
                transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)",
                children: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z"
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z"
                    })
                ]
            }),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])("g", {
                fill: fill,
                transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)",
                children: [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z"
                    }),
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])("path", {
                        d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z"
                    })
                ]
            })
        ]
    });
}
const absStyles = {
    position: 'absolute',
    top: 0,
    left: 0,
    bottom: 0,
    right: 0
};
const inertStyles = {
    overflow: 'hidden',
    pointerEvents: 'none',
    userSelect: 'none'
};
const defaultZ = 99999; //# sourceMappingURL=Cursors.js.map
}),
"[project]/node_modules/@instantdb/react/dist/esm/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$id$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__id$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/id.js [app-client] (ecmascript) <export default as id>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$instatx$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/instatx.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/schema.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/fetch.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$SyncTable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__CallbackEventType__as__SyncTableCallbackEventType$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/SyncTable.js [app-client] (ecmascript) <export CallbackEventType as SyncTableCallbackEventType>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$warningToggle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/warningToggle.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$utils$2f$PersistedObject$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/utils/PersistedObject.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$core$2f$dist$2f$esm$2f$createRouteHandler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/core/dist/esm/createRouteHandler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react-common/dist/esm/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2d$common$2f$dist$2f$esm$2f$InstantReactAbstractDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__InstantReactAbstractDatabase$3e$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react-common/dist/esm/InstantReactAbstractDatabase.js [app-client] (ecmascript) <export default as InstantReactAbstractDatabase>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$esm$2f$InstantReactWebDatabase$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react/dist/esm/InstantReactWebDatabase.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$esm$2f$init$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react/dist/esm/init.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$instantdb$2f$react$2f$dist$2f$esm$2f$Cursors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@instantdb/react/dist/esm/Cursors.js [app-client] (ecmascript)");
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    assign: null,
    searchParamsToUrlQuery: null,
    urlQueryToSearchParams: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    assign: function() {
        return assign;
    },
    searchParamsToUrlQuery: function() {
        return searchParamsToUrlQuery;
    },
    urlQueryToSearchParams: function() {
        return urlQueryToSearchParams;
    }
});
function searchParamsToUrlQuery(searchParams) {
    const query = {};
    for (const [key, value] of searchParams.entries()){
        const existing = query[key];
        if (typeof existing === 'undefined') {
            query[key] = value;
        } else if (Array.isArray(existing)) {
            existing.push(value);
        } else {
            query[key] = [
                existing,
                value
            ];
        }
    }
    return query;
}
function stringifyUrlQueryParam(param) {
    if (typeof param === 'string') {
        return param;
    }
    if (typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
        return String(param);
    } else {
        return '';
    }
}
function urlQueryToSearchParams(query) {
    const searchParams = new URLSearchParams();
    for (const [key, value] of Object.entries(query)){
        if (Array.isArray(value)) {
            for (const item of value){
                searchParams.append(key, stringifyUrlQueryParam(item));
            }
        } else {
            searchParams.set(key, stringifyUrlQueryParam(value));
        }
    }
    return searchParams;
}
function assign(target, ...searchParamsList) {
    for (const searchParams of searchParamsList){
        for (const key of searchParams.keys()){
            target.delete(key);
        }
        for (const [key, value] of searchParams.entries()){
            target.append(key, value);
        }
    }
    return target;
} //# sourceMappingURL=querystring.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
// Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    formatUrl: null,
    formatWithValidation: null,
    urlObjectKeys: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatUrl: function() {
        return formatUrl;
    },
    formatWithValidation: function() {
        return formatWithValidation;
    },
    urlObjectKeys: function() {
        return urlObjectKeys;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _querystring = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-client] (ecmascript)"));
const slashedProtocols = /https?|ftp|gopher|file/;
function formatUrl(urlObj) {
    let { auth, hostname } = urlObj;
    let protocol = urlObj.protocol || '';
    let pathname = urlObj.pathname || '';
    let hash = urlObj.hash || '';
    let query = urlObj.query || '';
    let host = false;
    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';
    if (urlObj.host) {
        host = auth + urlObj.host;
    } else if (hostname) {
        host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname);
        if (urlObj.port) {
            host += ':' + urlObj.port;
        }
    }
    if (query && typeof query === 'object') {
        query = String(_querystring.urlQueryToSearchParams(query));
    }
    let search = urlObj.search || query && `?${query}` || '';
    if (protocol && !protocol.endsWith(':')) protocol += ':';
    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
    } else if (!host) {
        host = '';
    }
    if (hash && hash[0] !== '#') hash = '#' + hash;
    if (search && search[0] !== '?') search = '?' + search;
    pathname = pathname.replace(/[?#]/g, encodeURIComponent);
    search = search.replace('#', '%23');
    return `${protocol}${host}${pathname}${search}${hash}`;
}
const urlObjectKeys = [
    'auth',
    'hash',
    'host',
    'hostname',
    'href',
    'path',
    'pathname',
    'port',
    'protocol',
    'query',
    'search',
    'slashes'
];
function formatWithValidation(url) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (url !== null && typeof url === 'object') {
            Object.keys(url).forEach((key)=>{
                if (!urlObjectKeys.includes(key)) {
                    console.warn(`Unknown key passed via urlObject into url.format: ${key}`);
                }
            });
        }
    }
    return formatUrl(url);
} //# sourceMappingURL=format-url.js.map
}),
"[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useMergedRef", {
    enumerable: true,
    get: function() {
        return useMergedRef;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
function useMergedRef(refA, refB) {
    const cleanupA = (0, _react.useRef)(null);
    const cleanupB = (0, _react.useRef)(null);
    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.
    // (this happens often if the user doesn't pass a ref to Link/Form/Image)
    // But this can cause us to leak a cleanup-ref into user code (previously via `<Link legacyBehavior>`),
    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs
    // (because it hasn't been updated for React 19)
    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.
    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.
    return (0, _react.useCallback)((current)=>{
        if (current === null) {
            const cleanupFnA = cleanupA.current;
            if (cleanupFnA) {
                cleanupA.current = null;
                cleanupFnA();
            }
            const cleanupFnB = cleanupB.current;
            if (cleanupFnB) {
                cleanupB.current = null;
                cleanupFnB();
            }
        } else {
            if (refA) {
                cleanupA.current = applyRef(refA, current);
            }
            if (refB) {
                cleanupB.current = applyRef(refB, current);
            }
        }
    }, [
        refA,
        refB
    ]);
}
function applyRef(refA, current) {
    if (typeof refA === 'function') {
        const cleanup = refA(current);
        if (typeof cleanup === 'function') {
            return cleanup;
        } else {
            return ()=>refA(null);
        }
    } else {
        refA.current = current;
        return ()=>{
            refA.current = null;
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-merged-ref.js.map
}),
"[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    DecodeError: null,
    MiddlewareNotFoundError: null,
    MissingStaticPage: null,
    NormalizeError: null,
    PageNotFoundError: null,
    SP: null,
    ST: null,
    WEB_VITALS: null,
    execOnce: null,
    getDisplayName: null,
    getLocationOrigin: null,
    getURL: null,
    isAbsoluteUrl: null,
    isResSent: null,
    loadGetInitialProps: null,
    normalizeRepeatedSlashes: null,
    stringifyError: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DecodeError: function() {
        return DecodeError;
    },
    MiddlewareNotFoundError: function() {
        return MiddlewareNotFoundError;
    },
    MissingStaticPage: function() {
        return MissingStaticPage;
    },
    NormalizeError: function() {
        return NormalizeError;
    },
    PageNotFoundError: function() {
        return PageNotFoundError;
    },
    SP: function() {
        return SP;
    },
    ST: function() {
        return ST;
    },
    WEB_VITALS: function() {
        return WEB_VITALS;
    },
    execOnce: function() {
        return execOnce;
    },
    getDisplayName: function() {
        return getDisplayName;
    },
    getLocationOrigin: function() {
        return getLocationOrigin;
    },
    getURL: function() {
        return getURL;
    },
    isAbsoluteUrl: function() {
        return isAbsoluteUrl;
    },
    isResSent: function() {
        return isResSent;
    },
    loadGetInitialProps: function() {
        return loadGetInitialProps;
    },
    normalizeRepeatedSlashes: function() {
        return normalizeRepeatedSlashes;
    },
    stringifyError: function() {
        return stringifyError;
    }
});
const WEB_VITALS = [
    'CLS',
    'FCP',
    'FID',
    'INP',
    'LCP',
    'TTFB'
];
function execOnce(fn) {
    let used = false;
    let result;
    return (...args)=>{
        if (!used) {
            used = true;
            result = fn(...args);
        }
        return result;
    };
}
// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);
function getLocationOrigin() {
    const { protocol, hostname, port } = window.location;
    return `${protocol}//${hostname}${port ? ':' + port : ''}`;
}
function getURL() {
    const { href } = window.location;
    const origin = getLocationOrigin();
    return href.substring(origin.length);
}
function getDisplayName(Component) {
    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}
function isResSent(res) {
    return res.finished || res.headersSent;
}
function normalizeRepeatedSlashes(url) {
    const urlParts = url.split('?');
    const urlNoQuery = urlParts[0];
    return urlNoQuery // first we replace any non-encoded backslashes with forward
    // then normalize repeated forward slashes
    .replace(/\\/g, '/').replace(/\/\/+/g, '/') + (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '');
}
async function loadGetInitialProps(App, ctx) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (App.prototype?.getInitialProps) {
            const message = `"${getDisplayName(App)}.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`;
            throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
                value: "E394",
                enumerable: false,
                configurable: true
            });
        }
    }
    // when called from _app `ctx` is nested in `ctx`
    const res = ctx.res || ctx.ctx && ctx.ctx.res;
    if (!App.getInitialProps) {
        if (ctx.ctx && ctx.Component) {
            // @ts-ignore pageProps default
            return {
                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
            };
        }
        return {};
    }
    const props = await App.getInitialProps(ctx);
    if (res && isResSent(res)) {
        return props;
    }
    if (!props) {
        const message = `"${getDisplayName(App)}.getInitialProps()" should resolve to an object. But found "${props}" instead.`;
        throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (Object.keys(props).length === 0 && !ctx.ctx) {
            console.warn(`${getDisplayName(App)} returned an empty object from \`getInitialProps\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`);
        }
    }
    return props;
}
const SP = typeof performance !== 'undefined';
const ST = SP && [
    'mark',
    'measure',
    'getEntriesByName'
].every((method)=>typeof performance[method] === 'function');
class DecodeError extends Error {
}
class NormalizeError extends Error {
}
class PageNotFoundError extends Error {
    constructor(page){
        super();
        this.code = 'ENOENT';
        this.name = 'PageNotFoundError';
        this.message = `Cannot find module for page: ${page}`;
    }
}
class MissingStaticPage extends Error {
    constructor(page, message){
        super();
        this.message = `Failed to load static file for page: ${page} ${message}`;
    }
}
class MiddlewareNotFoundError extends Error {
    constructor(){
        super();
        this.code = 'ENOENT';
        this.message = `Cannot find the middleware module`;
    }
}
function stringifyError(error) {
    return JSON.stringify({
        message: error.message,
        stack: error.stack
    });
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isLocalURL", {
    enumerable: true,
    get: function() {
        return isLocalURL;
    }
});
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)");
const _hasbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/has-base-path.js [app-client] (ecmascript)");
function isLocalURL(url) {
    // prevent a hydration mismatch on href for url with anchor refs
    if (!(0, _utils.isAbsoluteUrl)(url)) return true;
    try {
        // absolute urls can be local if they are on the same origin
        const locationOrigin = (0, _utils.getLocationOrigin)();
        const resolved = new URL(url, locationOrigin);
        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);
    } catch (_) {
        return false;
    }
} //# sourceMappingURL=is-local-url.js.map
}),
"[project]/node_modules/next/dist/shared/lib/utils/error-once.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "errorOnce", {
    enumerable: true,
    get: function() {
        return errorOnce;
    }
});
let errorOnce = (_)=>{};
if ("TURBOPACK compile-time truthy", 1) {
    const errors = new Set();
    errorOnce = (msg)=>{
        if (!errors.has(msg)) {
            console.error(msg);
        }
        errors.add(msg);
    };
} //# sourceMappingURL=error-once.js.map
}),
"[project]/node_modules/next/dist/client/app-dir/link.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    useLinkStatus: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    /**
 * A React component that extends the HTML `<a>` element to provide
 * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)
 * and client-side navigation. This is the primary way to navigate between routes in Next.js.
 *
 * @remarks
 * - Prefetching is only enabled in production.
 *
 * @see https://nextjs.org/docs/app/api-reference/components/link
 */ default: function() {
        return LinkComponent;
    },
    useLinkStatus: function() {
        return useLinkStatus;
    }
});
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _formaturl = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-client] (ecmascript)");
const _approutercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)");
const _usemergedref = __turbopack_context__.r("[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)");
const _utils = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)");
const _addbasepath = __turbopack_context__.r("[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
const _links = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/links.js [app-client] (ecmascript)");
const _islocalurl = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [app-client] (ecmascript)");
const _types = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/segment-cache/types.js [app-client] (ecmascript)");
const _erroronce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/error-once.js [app-client] (ecmascript)");
function isModifiedEvent(event) {
    const eventTarget = event.currentTarget;
    const target = eventTarget.getAttribute('target');
    return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
    event.nativeEvent && event.nativeEvent.which === 2;
}
function linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate) {
    if (typeof window !== 'undefined') {
        const { nodeName } = e.currentTarget;
        // anchors inside an svg have a lowercase nodeName
        const isAnchorNodeName = nodeName.toUpperCase() === 'A';
        if (isAnchorNodeName && isModifiedEvent(e) || e.currentTarget.hasAttribute('download')) {
            // ignore click for browserâ€™s default behavior
            return;
        }
        if (!(0, _islocalurl.isLocalURL)(href)) {
            if (replace) {
                // browser default behavior does not replace the history state
                // so we need to do it manually
                e.preventDefault();
                location.replace(href);
            }
            // ignore click for browserâ€™s default behavior
            return;
        }
        e.preventDefault();
        if (onNavigate) {
            let isDefaultPrevented = false;
            onNavigate({
                preventDefault: ()=>{
                    isDefaultPrevented = true;
                }
            });
            if (isDefaultPrevented) {
                return;
            }
        }
        const { dispatchNavigateAction } = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/app-router-instance.js [app-client] (ecmascript)");
        _react.default.startTransition(()=>{
            dispatchNavigateAction(as || href, replace ? 'replace' : 'push', scroll ?? true, linkInstanceRef.current);
        });
    }
}
function formatStringOrUrl(urlObjOrString) {
    if (typeof urlObjOrString === 'string') {
        return urlObjOrString;
    }
    return (0, _formaturl.formatUrl)(urlObjOrString);
}
function LinkComponent(props) {
    const [linkStatus, setOptimisticLinkStatus] = (0, _react.useOptimistic)(_links.IDLE_LINK_STATUS);
    let children;
    const linkInstanceRef = (0, _react.useRef)(null);
    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, onNavigate, ref: forwardedRef, unstable_dynamicOnHover, ...restProps } = props;
    children = childrenProp;
    if (legacyBehavior && (typeof children === 'string' || typeof children === 'number')) {
        children = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
            children: children
        });
    }
    const router = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);
    const prefetchEnabled = prefetchProp !== false;
    const fetchStrategy = prefetchProp !== false ? getFetchStrategyFromPrefetchProp(prefetchProp) : _types.FetchStrategy.PPR;
    if ("TURBOPACK compile-time truthy", 1) {
        function createPropError(args) {
            return Object.defineProperty(new Error(`Failed prop type: The prop \`${args.key}\` expects a ${args.expected} in \`<Link>\`, but got \`${args.actual}\` instead.` + (typeof window !== 'undefined' ? "\nOpen your browser's console to view the Component stack trace." : '')), "__NEXT_ERROR_CODE", {
                value: "E319",
                enumerable: false,
                configurable: true
            });
        }
        // TypeScript trick for type-guarding:
        const requiredPropsGuard = {
            href: true
        };
        const requiredProps = Object.keys(requiredPropsGuard);
        requiredProps.forEach((key)=>{
            if (key === 'href') {
                if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: props[key] === null ? 'null' : typeof props[key]
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                const _ = key;
            }
        });
        // TypeScript trick for type-guarding:
        const optionalPropsGuard = {
            as: true,
            replace: true,
            scroll: true,
            shallow: true,
            passHref: true,
            prefetch: true,
            unstable_dynamicOnHover: true,
            onClick: true,
            onMouseEnter: true,
            onTouchStart: true,
            legacyBehavior: true,
            onNavigate: true
        };
        const optionalProps = Object.keys(optionalPropsGuard);
        optionalProps.forEach((key)=>{
            const valType = typeof props[key];
            if (key === 'as') {
                if (props[key] && valType !== 'string' && valType !== 'object') {
                    throw createPropError({
                        key,
                        expected: '`string` or `object`',
                        actual: valType
                    });
                }
            } else if (key === 'onClick' || key === 'onMouseEnter' || key === 'onTouchStart' || key === 'onNavigate') {
                if (props[key] && valType !== 'function') {
                    throw createPropError({
                        key,
                        expected: '`function`',
                        actual: valType
                    });
                }
            } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'legacyBehavior' || key === 'unstable_dynamicOnHover') {
                if (props[key] != null && valType !== 'boolean') {
                    throw createPropError({
                        key,
                        expected: '`boolean`',
                        actual: valType
                    });
                }
            } else if (key === 'prefetch') {
                if (props[key] != null && valType !== 'boolean' && props[key] !== 'auto') {
                    throw createPropError({
                        key,
                        expected: '`boolean | "auto"`',
                        actual: valType
                    });
                }
            } else {
                // TypeScript trick for type-guarding:
                const _ = key;
            }
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (props.locale) {
            (0, _warnonce.warnOnce)('The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization');
        }
        if (!asProp) {
            let href;
            if (typeof hrefProp === 'string') {
                href = hrefProp;
            } else if (typeof hrefProp === 'object' && typeof hrefProp.pathname === 'string') {
                href = hrefProp.pathname;
            }
            if (href) {
                const hasDynamicSegment = href.split('/').some((segment)=>segment.startsWith('[') && segment.endsWith(']'));
                if (hasDynamicSegment) {
                    throw Object.defineProperty(new Error(`Dynamic href \`${href}\` found in <Link> while using the \`/app\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`), "__NEXT_ERROR_CODE", {
                        value: "E267",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
    }
    const { href, as } = _react.default.useMemo({
        "LinkComponent.useMemo": ()=>{
            const resolvedHref = formatStringOrUrl(hrefProp);
            return {
                href: resolvedHref,
                as: asProp ? formatStringOrUrl(asProp) : resolvedHref
            };
        }
    }["LinkComponent.useMemo"], [
        hrefProp,
        asProp
    ]);
    // This will return the first child, if multiple are provided it will throw an error
    let child;
    if (legacyBehavior) {
        if (children?.$$typeof === Symbol.for('react.lazy')) {
            throw Object.defineProperty(new Error(`\`<Link legacyBehavior>\` received a direct child that is either a Server Component, or JSX that was loaded with React.lazy(). This is not supported. Either remove legacyBehavior, or make the direct child a Client Component that renders the Link's \`<a>\` tag.`), "__NEXT_ERROR_CODE", {
                value: "E863",
                enumerable: false,
                configurable: true
            });
        }
        if ("TURBOPACK compile-time truthy", 1) {
            if (onClick) {
                console.warn(`"onClick" was passed to <Link> with \`href\` of \`${hrefProp}\` but "legacyBehavior" was set. The legacy behavior requires onClick be set on the child of next/link`);
            }
            if (onMouseEnterProp) {
                console.warn(`"onMouseEnter" was passed to <Link> with \`href\` of \`${hrefProp}\` but "legacyBehavior" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`);
            }
            try {
                child = _react.default.Children.only(children);
            } catch (err) {
                if (!children) {
                    throw Object.defineProperty(new Error(`No children were passed to <Link> with \`href\` of \`${hrefProp}\` but one child is required https://nextjs.org/docs/messages/link-no-children`), "__NEXT_ERROR_CODE", {
                        value: "E320",
                        enumerable: false,
                        configurable: true
                    });
                }
                throw Object.defineProperty(new Error(`Multiple children were passed to <Link> with \`href\` of \`${hrefProp}\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` + (typeof window !== 'undefined' ? " \nOpen your browser's console to view the Component stack trace." : '')), "__NEXT_ERROR_CODE", {
                    value: "E266",
                    enumerable: false,
                    configurable: true
                });
            }
        } else //TURBOPACK unreachable
        ;
    } else {
        if ("TURBOPACK compile-time truthy", 1) {
            if (children?.type === 'a') {
                throw Object.defineProperty(new Error('Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'), "__NEXT_ERROR_CODE", {
                    value: "E209",
                    enumerable: false,
                    configurable: true
                });
            }
        }
    }
    const childRef = legacyBehavior ? child && typeof child === 'object' && child.ref : forwardedRef;
    // Use a callback ref to attach an IntersectionObserver to the anchor tag on
    // mount. In the future we will also use this to keep track of all the
    // currently mounted <Link> instances, e.g. so we can re-prefetch them after
    // a revalidation or refresh.
    const observeLinkVisibilityOnMount = _react.default.useCallback({
        "LinkComponent.useCallback[observeLinkVisibilityOnMount]": (element)=>{
            if (router !== null) {
                linkInstanceRef.current = (0, _links.mountLinkInstance)(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus);
            }
            return ({
                "LinkComponent.useCallback[observeLinkVisibilityOnMount]": ()=>{
                    if (linkInstanceRef.current) {
                        (0, _links.unmountLinkForCurrentNavigation)(linkInstanceRef.current);
                        linkInstanceRef.current = null;
                    }
                    (0, _links.unmountPrefetchableInstance)(element);
                }
            })["LinkComponent.useCallback[observeLinkVisibilityOnMount]"];
        }
    }["LinkComponent.useCallback[observeLinkVisibilityOnMount]"], [
        prefetchEnabled,
        href,
        router,
        fetchStrategy,
        setOptimisticLinkStatus
    ]);
    const mergedRef = (0, _usemergedref.useMergedRef)(observeLinkVisibilityOnMount, childRef);
    const childProps = {
        ref: mergedRef,
        onClick (e) {
            if ("TURBOPACK compile-time truthy", 1) {
                if (!e) {
                    throw Object.defineProperty(new Error(`Component rendered inside next/link has to pass click event to "onClick" prop.`), "__NEXT_ERROR_CODE", {
                        value: "E312",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
            if (!legacyBehavior && typeof onClick === 'function') {
                onClick(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onClick === 'function') {
                child.props.onClick(e);
            }
            if (!router) {
                return;
            }
            if (e.defaultPrevented) {
                return;
            }
            linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate);
        },
        onMouseEnter (e) {
            if (!legacyBehavior && typeof onMouseEnterProp === 'function') {
                onMouseEnterProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === 'function') {
                child.props.onMouseEnter(e);
            }
            if (!router) {
                return;
            }
            if ("TURBOPACK compile-time truthy", 1) {
                return;
            }
            //TURBOPACK unreachable
            ;
            const upgradeToDynamicPrefetch = undefined;
        },
        onTouchStart: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : function onTouchStart(e) {
            if (!legacyBehavior && typeof onTouchStartProp === 'function') {
                onTouchStartProp(e);
            }
            if (legacyBehavior && child.props && typeof child.props.onTouchStart === 'function') {
                child.props.onTouchStart(e);
            }
            if (!router) {
                return;
            }
            if (!prefetchEnabled) {
                return;
            }
            const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;
            (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);
        }
    };
    // If the url is absolute, we can bypass the logic to prepend the basePath.
    if ((0, _utils.isAbsoluteUrl)(as)) {
        childProps.href = as;
    } else if (!legacyBehavior || passHref || child.type === 'a' && !('href' in child.props)) {
        childProps.href = (0, _addbasepath.addBasePath)(as);
    }
    let link;
    if (legacyBehavior) {
        if ("TURBOPACK compile-time truthy", 1) {
            (0, _erroronce.errorOnce)('`legacyBehavior` is deprecated and will be removed in a future ' + 'release. A codemod is available to upgrade your components:\n\n' + 'npx @next/codemod@latest new-link .\n\n' + 'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components');
        }
        link = /*#__PURE__*/ _react.default.cloneElement(child, childProps);
    } else {
        link = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
            ...restProps,
            ...childProps,
            children: children
        });
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(LinkStatusContext.Provider, {
        value: linkStatus,
        children: link
    });
}
const LinkStatusContext = /*#__PURE__*/ (0, _react.createContext)(_links.IDLE_LINK_STATUS);
const useLinkStatus = ()=>{
    return (0, _react.useContext)(LinkStatusContext);
};
function getFetchStrategyFromPrefetchProp(prefetchProp) {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        return prefetchProp === null || prefetchProp === 'auto' ? _types.FetchStrategy.PPR : // (although invalid values should've been filtered out by prop validation in dev)
        _types.FetchStrategy.Full;
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=link.js.map
}),
"[project]/node_modules/next/navigation.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation.js [app-client] (ecmascript)");
}),
]);

//# sourceMappingURL=node_modules_c9903438._.js.map